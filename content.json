[{"title":"爬虫学到什么程度可以去找工作","date":"2018-05-29T14:52:52.000Z","path":"2018/05/29/爬虫学到什么程度可以去找工作/","text":"这是崔斯特的第五十一篇原创文章 分享下我的经验与教训 (๑• . •๑) 最近很多朋友问我，我在自学爬虫，学到什么程度可以去找工作呢？ 这篇文章会说说我自己的心得体验，关于爬虫、关于工作，仅供参考。 学到哪种程度暂且把目标定位初级爬虫工程师，简单列一下吧： （必要部分） 语言选择：一般是了解Python、Java、Golang之一 熟悉多线程编程、网络编程、HTTP协议相关 开发过完整爬虫项目（最好有全站爬虫经验，这个下面会说到） 反爬相关，cookie、ip池、验证码等等 熟练使用分布式 （非必要，建议） 了解消息队列，如RabbitMQ、Kafka、Redis等 具有数据挖掘、自然语言处理、信息检索、机器学习经验 熟悉APP数据采集、中间人代理 大数据处理（Hive/MR/Spark/Storm） 数据库Mysql，redis，mongdb 熟悉Git操作、linux环境开发 读懂js代码，这个真的很重要 如何提升随便看看知乎上的教程就可以入门了，就Python而言，会requests当然是不够的，还需要了解scrapy和pyspider这两个框架，scrapy_redis也是需要理解原理的。 分布式如何搭建、如何解决其中遇到内存、速度问题。 参考 scrapy-redis 和 scrapy 有什么区别？ 什么叫全站爬取最简单的拿拉钩来举例，搜索关键词，有30页，不要以为把这30页爬完就是全站爬取了，你应该想方法把所有数据全部爬下来。 什么办法，通过筛选缩小范围，慢慢来就OK了。 同时，每个职位还会有推荐职位，再写一个采集推荐的爬虫。 这个过程需要注意的是如何去重，Mongo可以、redis也可以 参考 Scrapy中如何提高数据的插入速度 实际项目经验这个面试中肯定会被人问道，如： 你爬过哪些网站 日均最大采集量是多少 你遇到哪些棘手问题，如何解决 等等 那么怎么找项目呢？比如我要爬微博数据，去Github中搜索下，项目还算少吗？ 语言选择我自己建议是Python、Java、Golang最好都了解，Java爬虫的也很多，但是网上教程几乎都是Python的，悲哀。 最后说下Golang，Golang真的很牛逼，说个数字，Golang可以每分钟下载网页数量 2W ，Python可以吗~~ 宣传下自己的刷题项目 Leetcode Solutions By All Language 关于反爬常见的 UA、Refer等需要了解是什么东西，有些验证的ID如何产生的，是否必要；关于IP池这块我不了解，不多说，需要注意的是如何设计拉黑机制；模拟登陆也是必要的，fuck-login 可以研究下代码，或者提PR。 如何判断能力足够很简单，给个任务，爬取知乎上所有问题。 你会如何思考并设计这个项目？ 欢迎留言指出 以上仅为个人看法，若有不足之处请指出","tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://zhangslob.github.io/tags/爬虫/"}]},{"title":"你写过哪些让你睡不好觉的BUG","date":"2018-05-28T15:38:35.000Z","path":"2018/05/28/你写过哪些让你睡不好觉的BUG/","text":"这是崔斯特的第五十篇原创文章 你写过什么有趣的BUG？ (๑• . •๑) 今天，聊聊 BUG。 今天下午发现程序中一个BUG，紧急修复之后重新上线，debug上测试没毛病，OK上正式环境。build完之后，程序一直有问题，没法读数据，头疼啊，自己看的眼睛都要瞎了，找不到原因。 增加更多日志，给出错的地方每一条都打印出日志来，看看到底是哪里出了问题。改完，上debug，好的没毛病，上正式环境，根据日志我大概判断出是那里的问题了，改，线下测试，debug测试，都没问题，再上正式版，还是不行。 这个时候已经精疲力竭了，想砸电脑！！！ 为什么debug环境可以，正式环境不行啊？？ 然后程序就跑起来了，是的，就跑起来了。下班，回家。（已经快10点了） 回到家，洗完澡，写完这篇文章，再去检查日志，so far so good！！开心~ 现在我再仔细想了想，可能是这样：线上服务器和数据库压力比较大，程序子线程没有跑起来、或者数据库没建索引、查询时间过久（明天去验证下，因为之前一直没遇到类似问题） 不管了，我要睡觉了。 来讨论下，你写过什么让你睡不好觉的BUG？","tags":[{"name":"BUG","slug":"BUG","permalink":"https://zhangslob.github.io/tags/BUG/"}]},{"title":"git大法好，push需谨慎","date":"2018-05-26T07:38:28.000Z","path":"2018/05/26/git大法好，push需谨慎/","text":"这是崔斯特的第四十九篇原创文章 注意自己的账号安全 (๑• . •๑) 在每次git push前，请检查你的提交文件 故事是这样来的。（我又开始讲故事了） 前几天在 Github上找一些资料，碰巧看到一个合适的，就把他 clone 下来，准备在本地跑着试试看效果，但是在运行的时候却发现提示错误，根绝错误提示原因我发现是缺少了一个名为config.py的文件。 经验告诉我，这应该是一个写有相关配置的文件。现在缺少了这个文件，整个程序就没法运行，自己写的话又不知道格式什么的。 那我该怎么办？ 最后我还是找到了，在Github上。我去该项目上看到作者提交了很多次的commit，从历史的提交中我找到了相关信息。这是一个包含有作者相关数据库的文件，我已经通知作者，让他去删除此项目。 看下图，每个开源项目都会显示所有的commits，每次提交都会把git工作目录下所有文件提交（当然你可以指定具体的文件，我习惯git add .）。即使你下今天把密码删除了，但是你昨天提交的密码还是会保存到commits中，别人还是可以找到。 例如你现在看到的项目 Leetcode-Solutions ，你可以从commit中进入，查看到历史contributors的每一次提交的完整文件， 如：很久之前的提交 所以看到这里，你就有必要想想自己有没有把任何个人隐私数据提交到 Github 上，如果有，建议还是删除项目吧。 当然，这有一个前提，就是你的项目是公开的（Public），如果是私有的（Private），就不用考虑了。 创建私有项目是收费的，一般适合公司和组织。 最后首尾呼应： git大法好，push需谨慎","tags":[{"name":"Git","slug":"Git","permalink":"https://zhangslob.github.io/tags/Git/"}]},{"title":"Python最假的库：Faker","date":"2018-05-22T13:14:35.000Z","path":"2018/05/22/Python最假的库：Faker/","text":"这是崔斯特的第四十八篇原创文章 好假啊 (๑• . •๑) 先申明下，这里说的Faker和LOL的大魔王没有任何关系，只是恰好重名而已。 故事由来最近做一个项目时需要随机生成人的名字，百度之后，我是这样写的 123456789101112131415def random_first_name(): \"\"\"百家姓中选择一个\"\"\" name = ['赵', '钱', '孙', '李', '周', '吴', '郑', '王', '冯', '陈', '褚', '卫', '蒋', '沈', '韩', '杨', '朱', '秦', '尤', '许', '何', '吕', '施', '张', '孔', '曹', '严', '华', '金', '魏', '陶', '姜', '戚', '谢', '邹', '喻', '柏', '水', '窦', '章', '云', '苏', '潘', '葛', '奚', '范', '彭', '郎', '鲁', '韦', '昌', '马', '苗', '凤', '花', '方', '俞', '任', '袁', '柳'] return random.choice(name)def random_last_name(): \"\"\"生成随机汉语\"\"\" head = random.randint(0xb0, 0xf7) body = random.randint(0xa1, 0xf9) # 在head区号为55的那一块最后5个汉字是乱码,为了方便缩减下范围 val = f'&#123;head:x&#125;&#123;body:x&#125;' str_ = bytes.fromhex(val).decode('gb2312') return str_name = random_first_name() + random_last_name() 前辈在review的时候说怎么这么复杂，Python中有一个专门生成各类假数据的库：Faker，你去了解下。 Faker项目地址：faker 安装：pip install Faker 中文生成假数据：Language zh_CN 那么Faker能生成那些假数据了？ 1234from faker import Fakerfake = Faker(locale='zh_CN')# 初始化 地址1234567891011121314fake.street_name()# '广州街fake.city_suffix()# '县'fake.street_address()# '香港路B座'fake.longitude()# -98.702031fake.district()# '璧山' 汽车12fake.license_plate()# HZL 767 银行12345678fake.bban()# 'KLUX5928618542924'fake.bank_country()# 'GB'fake.iban()# 'GB04BPNH0448315286040' 条形码12345678fake.ean(length=13)# '0994331656275'fake.ean8()# '51309350'fake.ean13()# '8336323543385' 公司1234567891011fake.company_prefix()# '鸿睿思博'fake.bs()# 'embrace strategic schemas'fake.company_suffix()# '科技有限公司'fake.company()# '昂歌信息网络有限公司' 信用卡1234567891011121314fake.credit_card_security_code(card_type=None)# '360'fake.credit_card_full(card_type=None)# 'Diners Club / Carte Blanche\\n林 莘\\n30311852484679 10/19\\nCVC: 388\\n'fake.credit_card_number(card_type=None)# '30240280288941'fake.credit_card_expire(start=\"now\", end=\"+10y\", date_format=\"%m/%y\")# '11/26'fake.credit_card_provider(card_type=None)# 'Maestro' 互联网1234567891011121314151617181920212223242526fake.domain_word(*args, **kwargs)# 'jin'fake.company_email(*args, **kwargs)# 'zoulei@hou.com'fake.free_email(*args, **kwargs)# 'vxu@yahoo.com'fake.ipv4_private(network=False, address_class=None)# '10.202.214.57'fake.ascii_safe_email(*args, **kwargs)# 'baiyan@example.net'fake.email(*args, **kwargs)# 'minggao@gmail.com'fake.image_url(width=None, height=None)# 'https://www.lorempixel.com/817/102'fake.uri_page()# 'category'fake.ipv4_network_class()# 'c' 姓名1234567891011121314151617181920212223242526272829303132333435363738394041fake.first_name_female()# '秀华'fake.name_male()# '郏杰'fake.suffix_female()# ''fake.first_name()# '东'fake.prefix_female()# ''fake.last_name_male()# '扶'fake.last_name()# '荣'fake.name_female()# '曹红'fake.suffix_male()# ''fake.last_name_female()# '辛'fake.last_romanized_name()# 'Zhang'fake.first_romanized_name()# 'Min'fake.romanized_name()# 'Xiuying Qiao'fake.name()# '钟想' 电话12345678fake.phone_number()# '18874465626'fake.msisdn()# '8086764507444'fake.phonenumber_prefix()# 155 user_agent这个大家应该很熟悉，常用的就是 fake-useragent这个库12345678910111213141516171819202122232425262728293031323334353637fake.mac_platform_token()# 'Macintosh; Intel Mac OS X 10_12_1'fake.firefox()# ('Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_9_4; rv:1.9.4.20) '# 'Gecko/2012-05-03 04:16:34 Firefox/3.6.10')fake.windows_platform_token()# 'Windows 95'fake.safari()# ('Mozilla/5.0 (iPod; U; CPU iPhone OS 3_1 like Mac OS X; sat-IN) '# 'AppleWebKit/533.2.4 (KHTML, like Gecko) Version/3.0.5 Mobile/8B113 '# 'Safari/6533.2.4')fake.chrome(version_from=13, version_to=63, build_from=800, build_to=899)# ('Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/5331 (KHTML, like Gecko) '# 'Chrome/52.0.838.0 Safari/5331')fake.opera()# 'Opera/8.83.(X11; Linux i686; ce-RU) Presto/2.9.169 Version/10.00'fake.mac_processor()# 'Intel'fake.user_agent()# ('Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_9 rv:3.0; pa-IN) '# 'AppleWebKit/532.47.6 (KHTML, like Gecko) Version/4.0.1 Safari/532.47.6')fake.linux_platform_token()# 'X11; Linux x86_64'fake.linux_processor()# 'i686'fake.internet_explorer()# 'Mozilla/5.0 (compatible; MSIE 5.0; Windows NT 5.01; Trident/3.1)' 这里举例的都是中文的，当然也有其他语言的，小伙伴可以去官网看看。 最近在和小伙伴刷题，欢迎加入 Leetcode Solutions By All Language","tags":[{"name":"Faker","slug":"Faker","permalink":"https://zhangslob.github.io/tags/Faker/"}]},{"title":"强大的异步爬虫 with aiohttp","date":"2018-05-16T09:00:07.000Z","path":"2018/05/16/强大的异步爬虫-aiohttp/","text":"这是崔斯特的第四十七篇原创文章 异步了解下 (๑• . •๑) 看到现在网络上大多讲的都是requests、scrapy，却没有说到爬虫中的神器：aiohttp aiohttp 介绍aiohttp是什么，官网上有这样一句话介绍：Async HTTP client/server for asyncio and Python，翻译过来就是 asyncio和Python的异步HTTP客户端/服务器 主要特点是： 支持客户端和HTTP服务器。 无需使用Callback Hell即可支持Server WebSockets和Client WebSockets。 Web服务器具有中间件，信号和可插拔路由。 emmmm，好吧，还是来看代码吧 Client example: 1234567891011121314import aiohttpimport asyncioasync def fetch(session, url): async with session.get(url) as response: return await response.text()async def main(): async with aiohttp.ClientSession() as session: html = await fetch(session, 'http://httpbin.org/headers') print(html)loop = asyncio.get_event_loop()loop.run_until_complete(main()) output: 1&#123;\"headers\":&#123;\"Accept\":\"*/*\",\"Accept-Encoding\":\"gzip, deflate\",\"Connection\":\"close\",\"Host\":\"httpbin.org\",\"User-Agent\":\"Python/3.6 aiohttp/3.2.1\"&#125;&#125; Server example: 123456789101112from aiohttp import webasync def handle(request): name = request.match_info.get('name', \"Anonymous\") text = \"Hello, \" + name return web.Response(text=text)app = web.Application()app.add_routes([web.get('/', handle), web.get('/&#123;name&#125;', handle)])web.run_app(app) output: 12======== Running on http://0.0.0.0:8080 ========(Press CTRL+C to quit) aiohttp 与 requests去翻一下官方文档 Client Quickstart，让我感觉非常熟悉，很多用法和requests相似。 1234async with aiohttp.ClientSession() as session: async with session.get('http://httpbin.org/get') as resp: print(resp.status) print(await resp.text()) 首先，官方推荐使用ClientSession来管理会话，这不就是requests中的session吗？用法也类似，使用session.get()去发送get请求，返回的resp中就有我们所需要的数据了，用法也和requests一样，text（）文本，.json()直接打印返回的json数据，headers什么的也一样，更多内容参考官方文档Response object 既然已经有requests了，那为什么还要说aiohttp了？重点来了，aiohttp是异步的。在python3.5中，加入了asyncio/await 关键字，使得回调的写法更加直观和人性化。而aiohttp是一个提供异步web服务的库，asyncio可以实现单线程并发IO操作。 requests写爬虫是同步的，是等待网页下载好才会执行下面的解析、入库操作，如果在下载网页时间太长会导致阻塞，使用multiprocessing或者 threading加速爬虫也是一种方法。 我们现在使用的aiohttp是异步的，简单来说，就是不需要等待，你尽管去下载网页就好了，我不用傻傻的等待你完成才进行下一步，我还有别的活要干。这样就极大的提高了下载网页的效率。 另外，Scrapy也是异步的，是基于Twisted事件驱动的。在任何情况下，都不要写阻塞的代码。阻塞的代码包括： 访问文件、数据库或者Web 产生新的进程并需要处理新进程的输出，如运行shell命令 执行系统层次操作的代码，如等待系统队列 代码实例这里是使用aiohttp的一个爬虫实例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import asyncioimport aiohttpfrom bs4 import BeautifulSoupimport loggingclass AsnycGrab(object): def __init__(self, url_list, max_threads): self.urls = url_list self.results = &#123;&#125; self.max_threads = max_threads def __parse_results(self, url, html): try: soup = BeautifulSoup(html, 'html.parser') title = soup.find('title').get_text() except Exception as e: raise e if title: self.results[url] = title async def get_body(self, url): async with aiohttp.ClientSession() as session: async with session.get(url, timeout=30) as response: assert response.status == 200 html = await response.read() return response.url, html async def get_results(self, url): url, html = await self.get_body(url) self.__parse_results(url, html) return 'Completed' async def handle_tasks(self, task_id, work_queue): while not work_queue.empty(): current_url = await work_queue.get() try: task_status = await self.get_results(current_url) except Exception as e: logging.exception('Error for &#123;&#125;'.format(current_url), exc_info=True) def eventloop(self): q = asyncio.Queue() [q.put_nowait(url) for url in self.urls] loop = asyncio.get_event_loop() tasks = [self.handle_tasks(task_id, q, ) for task_id in range(self.max_threads)] loop.run_until_complete(asyncio.wait(tasks)) loop.close()if __name__ == '__main__': async_example = AsnycGrab(['http://edmundmartin.com', 'https://www.udemy.com', 'https://github.com/', 'https://zhangslob.github.io/', 'https://www.zhihu.com/'], 5) async_example.eventloop() print(async_example.results) 需要注意的是，你需要时刻在你的代码中使用异步操作，你如果在代码中使用同步操作，爬虫并不会报错，但是速度可能会受影响。 其他异步库因为爬虫不仅仅只有下载这块，还会有操作数据库，这里提供两个异步库：aioredis、motor 123456789101112131415import asyncioimport aioredisloop = asyncio.get_event_loop()async def go(): conn = await aioredis.create_connection( 'redis://localhost', loop=loop) await conn.execute('set', 'my-key', 'value') val = await conn.execute('get', 'my-key') print(val) conn.close() await conn.wait_closed()loop.run_until_complete(go())# will print 'value' 文档：aioredis 123456789101112131415import motor.motor_asyncioclient = motor.motor_asyncio.AsyncIOMotorClient('mongodb://localhost:27017')db = client['test_database']collection = db['test_collection']async def do_insert(): document = &#123;'key': 'value'&#125; result = await db.test_collection.insert_one(document) print('result %s' % repr(result.inserted_id)) async def do_find_one(): document = await db.test_collection.find_one(&#123;'i': &#123;'$lt': 1&#125;&#125;) pprint.pprint(document) 文档：motor 本文仅仅介绍了aiohttp作为Client的用法， 有兴趣的朋友可以去研究下作为Server的用法，同样很强大。","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zhangslob.github.io/tags/Leetcode/"}]},{"title":"Leetcode Solutions（一） two-sum","date":"2018-05-15T10:22:26.000Z","path":"2018/05/15/Leetcode Solutions（一）/","text":"这是崔斯特的第四十六篇原创文章 开始刷题咯 (๑• . •๑) Two Sum 题目给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。 示例:1234给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 解题思路Goa + b = target 也可以看成是 a = target - b 在map[整数]整数的序号中，可以查询到a的序号。这样就不用嵌套两个for循环了。 12345678910func twoSum(nums []int, target int) []int &#123; m := make(map[int]int, len(nums)) for i, b := range nums &#123; if j, ok := m[target-b]; ok &#123; return []int&#123;j, i&#125; &#125; m[nums[i]] = i &#125; return nil&#125; Python 由于要找到符合题意的数组元素的下标，所以先要将原来的数组深拷贝一份，然后排序。 然后在排序后的数组中找两个数使它们相加为target。这个思路比较明显：使用两个指针，一个指向头，一个指向尾，两个指针向中间移动并检查两个指针指向的数的和是否为target。如果找到了这两个数，再将这两个数在原数组中的位置找出来就可以了。 要注意的一点是：在原来数组中找下标时，需要一个从头找，一个从尾找，要不无法通过。如这个例子：numbers=[0,1,2,0]; target=0。如果都从头开始找，就会有问题。 12345678910class Solution: def twoSum(self, nums, target): if len(nums) &lt;= 1: return False d = dict() for i in range(len(nums)): if nums[i] in d: return [d[nums[i]], i] else: d[target - nums[i]] = i","tags":[{"name":"Leetcode","slug":"Leetcode","permalink":"https://zhangslob.github.io/tags/Leetcode/"}]},{"title":"告别win10，拥抱linux","date":"2018-05-12T05:49:33.000Z","path":"2018/05/12/告别win10，拥抱linux/","text":"这是崔斯特的第四十五篇原创文章 安装linux操作系统 (๑• . •๑) win10 升级先问你一个问题，你讨厌win10升级系统吗？ 我的回答：是，明明已经把自动更新关闭了，可是还是会有“易升”，win10易升一直卸载不掉。所以就想试试别的系统。 linux是最好的选择。黑苹果暂时不考虑。 喜欢linux的理由 深度桌面 深度终端（配合zsh超赞的） 除了颜值外，程序兼容性会更好，安装各种东西会很方便。作为一名程序员，熟悉linux下基本操作也是必要的。 我自己试过，爬虫会跑的更快。 手动滑稽 选择linux哪个版本目前我使用过deepin和ubuntu18，对于完全的小白来说，我推荐deepin也就是深度操作系统，深度商店收入的应用可以基本满足，ubuntu很多应用安装起来比较麻烦，如果你喜欢折腾，那就上手ubuntu吧。 如果你和我一样 喜欢xxx，那就试试deepin和ubuntu18共存。 我现在的开机界面（渣渣像素） 如何安装linux安装deepin使用U盘安装 先去下载： ISO文件 深度启动盘制作工具 然后安装启动盘制作工具，然后选择刚才下载的ISO文件，下一步选择你的U盘，然后就开始安装了。 下一步，重启电脑，一般情况下电脑默认是从硬盘启动，因此，在使用U盘安装系统之前，您需要先进入电脑的BIOS界面将U盘设置为第一启动项。 台式机一般为 Delete 键、笔记本一般为 F2 或 F10 或 F12 键，即可进入 BIOS 设置界面。 将深度操作系统光盘插入电脑光驱中。 启动电脑，将光盘设置为第一启动项。 进入安装界面，选择需要安装的语言。 如果还不会，这里有官方录制的视频哦 深度安装器+深度探索频道第七期+深度操作系统官方出品 还有一种更加简单的方式就是下载 深度系统安装器 然后就是傻瓜操作了，记得关闭下 安全启动 小歪并不推荐使用第二种方式安装，在笔记本上怎么都没有效果，在台式上一次成功。所以大家有U盘的尽量使用U盘吧 安装ubuntu需要用到上面提到过的深度启动盘制作工具，然后去下载 ISO文件，然后就是和上面安装方法一样的，进行操作即可。 有没有很简单。 我的ubuntu界面，用得少，所以没美化 感受我使用deepin有一个月了，写代码用deepin，家里的台式还是win7，因为deepin虽然有steam，但是吃鸡不支持在linux下运行。 deepin完全可以满足我的办公需求，Pycharm、sublime、typora、chrome、网易云音乐等等都有，用起来很舒服，至少现在是这样感觉。但是有时候deepin也会卡死。 强烈建议上手linux，可以学到很多命令行操作，安装deepin就好，到时候你的电脑会Windows与deepin共存，根据场景选择系统。 有时间写一篇deepin美化与安装应用相关的东西，看到这一定要点赞哦。","tags":[{"name":"linux","slug":"linux","permalink":"https://zhangslob.github.io/tags/linux/"}]},{"title":"linux下安装python3.6","date":"2018-05-11T14:26:54.000Z","path":"2018/05/11/linux下安装python3-6/","text":"这是崔斯特的第四十四篇原创文章 linux操作 (๑• . •๑) 1234567891011121314151617181920212223sudo sed -i 's\\archive.ubuntu.com\\mirrors.aliyun.com\\g' /etc/apt/sources.listsudo apt-get updatecd /home/sudo apt-get install gcc make zlib1g-dev -ysudo apt-get install libbz2-dev libsqlite3-dev libxml2-dev libffi-dev libssl-dev -ysudo apt install wget -ywget http://mirrors.sohu.com/python/3.6.2/Python-3.6.2.tgz # 可以换成你想要的版本tar -xvf Python-3.6.2.tgzcd Python-3.6.2./configure --prefix=/home/usr/python36/sudo makesudo make installcd ../usr/python36/bin/sudo mkdir -p ~/.pip/sudo cat &lt;&lt; EOF &gt; ~/.pip/pip.conf[global]trusted-host=mirrors.aliyun.comindex-url=http://mirrors.aliyun.com/pypi/simple/EOFsudo apt-get install libmysqlclient-dev -yln -s /home/usr/python36/bin/pip3 /usr/bin/pip36ln -s /home/usr/python36/bin/python3 /usr/bin/python36 以后就可以使用 pip36 python36来进行操作。 如果在命令行中输入scrapy提示没这个命令，可以试试python36 -m scrapy","tags":[{"name":"linux","slug":"linux","permalink":"https://zhangslob.github.io/tags/linux/"}]},{"title":"护眼神器了解下","date":"2018-05-08T14:05:24.000Z","path":"2018/05/08/护眼神器了解下/","text":"这是崔斯特的第四十三篇原创文章 保护眼睛 (๑• . •๑) 整天面对屏幕，护眼是必须的，下面推荐几款小歪使用过的软件。 flux官网：https://justgetflux.com/ 使用起来非常简单，是我之前非常喜欢的一款产品，会随着一天之内光线强弱改变屏幕的颜色。但是在linux上似乎不起作用，安装之后，屏幕颜色没有发生任何变化，于是我放弃了，选择另一款软件 == redshift网站：https://github.com/jonls/redshift Ubuntu下sudo apt-get install redshift就可以安装，打开方式是在命令行输入redshift -v -t 4500:2500，然后颜色就会变得非常舒服。 如果在你的电脑上 redshift 有时不工作，检查是否开启了多个 redshift。 Safe Eyes网站：http://slgobinath.github.io/SafeEyes/ 这款应用会自动关闭屏幕，间隔一段时间会有休息，这个是否好好放松下自己的眼睛。 这个好像只能安装在linux上 大家还有什么推荐的呢？欢迎评论指出","tags":[{"name":"护眼","slug":"护眼","permalink":"https://zhangslob.github.io/tags/护眼/"}]},{"title":"awesome_crawl(一)：腾讯新闻","date":"2018-05-01T13:52:11.000Z","path":"2018/05/01/awesome-crawl-一-：腾讯新闻/","text":"这是崔斯特的第四十二篇原创文章 awesome (๑• . •๑) 项目地址：https://github.com/zhangslob/awesome_crawl awesome_crawl（优美的爬虫）1、腾讯新闻的全站爬虫采集策略 从网站地图出发，找出所有子分类，从每个子分类中再寻找详情页面的链接。 首先寻找每条新闻的ID，然后移动端采集具体内容。 再去找一些推荐新闻的接口，做一个“泛爬虫”。 说明 整套系统中分为两部分，一套是生产者，专门去采集qq新闻的链接，然后存放到redis中，一套是消费者，从redis中读取这些链接，解析详情数据。所有配置文件都是爬虫中的custom_settings中，可以自定义。 如果需要设置代理，请在middlewares.ProxyMiddleware中设置。 qq_list: 这个爬虫是生产者。运行之后，在你的redis服务器中会出现qq_detail:start_urls，即种子链接 qq_detail: 这个爬虫是生消费者，运行之后会消费redis里面的数据，如下图： 你可以自行添加更多爬虫去采集种子链接，如从首页进入匹配，从推荐入口： 12345678910111213141516171819import requestsurl = \"https://pacaio.match.qq.com/xw/recommend\"querystring = &#123;\"num\":\"10^\",\"callback\":\"__jp0\"&#125;headers = &#123; 'accept-encoding': \"gzip, deflate, br\", 'accept-language': \"zh-CN,zh;q=0.9,en;q=0.8\", 'user-agent': \"Mozilla/5.0 (iPhone; CPU iPhone OS 11_0 like Mac OS X) AppleWebKit/604.1.38 (KHTML, like Gecko) Version/11.0 Mobile/15A372 Safari/604.1\", 'accept': \"*/*\", 'referer': \"https://xw.qq.com/m/recommend/\", 'authority': \"pacaio.match.qq.com\", 'cache-control': \"no-cache\", &#125;response = requests.request(\"GET\", url, headers=headers, params=querystring)print(response.text) 等等，你所需要做的仅仅是把这些抓到的种子链接塞到redis里面，也就是启用qq_news.pipelines.RedisStartUrlsPipeline这个中间件。 TODO 增加更多新闻链接的匹配，从推荐接口处获得更多种子链接 增加“泛爬虫”，采集种子链接 数据库字段检验 redis中数据为空爬虫自动关闭（目前redis数据被消费完之后爬虫并不会自动关闭，如下图）","tags":[{"name":"awesome_crawl","slug":"awesome-crawl","permalink":"https://zhangslob.github.io/tags/awesome-crawl/"},{"name":"scrapy","slug":"scrapy","permalink":"https://zhangslob.github.io/tags/scrapy/"}]},{"title":"scrapy-redis 和 scrapy 有什么区别？","date":"2018-04-21T10:03:14.000Z","path":"2018/04/21/有什么区别？/","text":"这是崔斯特的第四十一篇原创文章 分布式爬虫 (๑• . •๑) 最近在工作中一直使用 redis 来管理分发爬虫任务，让我对 scrapy-redis 有很深刻的理解，下面让我慢慢说来。 在所有的问题开始之前，要先有一个前提：你使用 Scrapy 框架做开发 结论scrapy-redis 与 Scrapy的关系就像电脑与固态硬盘一样，是电脑中的一个插件，能让电脑更快的运行。 Scrapy 是一个爬虫框架，scrapy-redis 则是这个框架上可以选择的插件，它可以让爬虫跑的更快。 为什么使用 scrapy-redis首先，在实际开发中，我们总会对爬虫速度表示不满，为啥这么慢，能不能跑快点。除了爬虫本身的优化，我们就要引入分布式爬虫的概念。 我自己对分布式爬虫的理解就是：多个爬虫执行同一个任务 这里说下，Scrapy本身是不支持分布式的，因为它的任务管理和去重全部是在机器内存中实现的。 在 Scrapy 中最出名的分布式插件就是scrapy-redis了，scrapy-redis的作用就是让你的爬虫快、更快、超级快。 scrapy-redis 如何工作最简单的方式是使用redis替换机器内存，那么具体如何操作呢？非常简单，你只需要在 settings.py 中加上三代码，就能让你的爬虫变为分布式。 12345SCHEDULER = \"scrapy_redis.scheduler.Scheduler\"DUPEFILTER_CLASS = \"scrapy_redis.dupefilter.RFPDupeFilter\"REDIS_START_URLS_AS_SET = True SCHEDULER 是任务分发与调度，把所有的爬虫开始的请求都放在redis里面，所有爬虫都去redis里面读取请求。DUPEFILTER_CLASS 是去重队列，负责所有请求的去重，REDIS_START_URLS_AS_SET指的是使用redis里面的set类型（简单完成去重），如果你没有设置，默认会选用list。 如果你现在运行你的爬虫，你可以在redis中看到出现了这两个key: 12spider_name:dupefilterspider_name:requests 格式是set，即不会有重复数据。前者就是redis的去重队列，对应DUPEFILTER_CLASS，后者是redis的请求调度，把里面的请求分发给爬虫，对应SCHEDULER。（里面的数据不会自动删除，如果你第二次跑，需要提前清空里面的数据） scrapy-redis 优点速度快scrapy-redis 使用redis这个速度非常快的非关系型（NoSQL）内存键值数据库，速度快是最重要原因（但是也会产生负面想过，下面会说到）。 为什么是scrapy-redis而不是scrapy-mongo呢，大家可以仔细想想。 用法简单前人已经造好轮子了，scrapy-redis。我们直接拿来用就好，而用法也像上面提到的在 settings.py 文件中配置。在文档中还有另一种用法，即Feeding a Spider from Redis run the spider:scrapy runspider myspider.py push urls to redis:redis-cli lpush myspider:start_urls http://google.com（建议把lpush换为zset） 其实这种用法就是先打开一个爬虫，他会一直在redis里面寻找key为 myspider:start_urls，如果存在，就提取里面的url。当然你也可以在爬虫中指定redis_key，默认的是爬虫的名字加上:start_urls 去重简单爬虫中去重是一件大事，使用了scrapy-redis后就很简单了。上面提到过使用redis的set类型就可以很容易达到这个目标了，即REDIS_START_URLS_AS_SET = True。 scrapy-redis 缺点内存问题为什么使用分布式爬虫，当然是因为会有很多链接需要跑，或者说会存放很多个myspider:start_urls到redis中，Redis是key-value数据库，面对key的内存搜索，优势明显，但是Redis吃的是纯内存，myspider:start_urls是一个有一个像https://www.zhihu.com/people/cuishite的链接，会占用大量的内存空间。之前就因为这个原因redis崩溃过无数次，那么如何优化？ 网络上有的方法是 scrapy_redis去重优化（已有7亿条数据），附Demo福利，可以参考下。如果你有好的解决方法，欢迎私信告诉我。（保密原因就不介绍我们的处理方法了） Usage这个其实不算做问题，只是官方文档上我觉得的小BUG，在这里 Usage 1234# Store scraped item in redis for post-processing.ITEM_PIPELINES = &#123; 'scrapy_redis.pipelines.RedisPipeline': 300&#125; Pipeline是这样写的1234567891011121314def _process_item(self, item, spider): key = self.item_key(item, spider) data = self.serialize(item) self.server.rpush(key, data) return itemdef item_key(self, item, spider): \"\"\"Returns redis key based on given spider. Override this function to use a different key depending on the item and/or spider. \"\"\" return self.key % &#123;'spider': spider.name&#125; 看不懂为什么要把数据储存在redis里面，这不又加大redis储存负担吗？对于新手来说真的不友好，或许可以考虑提一个pr。 redis可视化工具最后介绍两个redis可视化工具 RedisDesktopManager 比较出名的工具，但是经常会崩溃 kedis 国人开发的免费工具，这个界面还是可以的","tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://zhangslob.github.io/tags/爬虫/"},{"name":"scrapy","slug":"scrapy","permalink":"https://zhangslob.github.io/tags/scrapy/"}]},{"title":"来codewars与我一起玩耍吧","date":"2018-04-12T13:25:13.000Z","path":"2018/04/12/来codewars与我一起玩耍吧/","text":"这是崔斯特的第四十篇原创文章 并肩作战 (๑• . •๑) 先看一道题目如何使用代码表示“石头、剪刀、布”之间的关系。 即：石头 &gt; 剪刀，剪刀 &gt; 布， 剪刀 &gt; 布 当时我想了很多，构造一个字典，和数字对应，但是应该如何表示“大小”关系呢？想破脑袋都想不出来，最后看了答案，形如 dict = {&#39;a&#39;: &#39;b&#39;, &#39;b&#39;: &#39;c&#39;, &#39;c&#39;: &#39;a&#39;} 简直是妙啊！！！ 原题在这里，Rock Paper Scissors!，可以自己试试看。 我觉得很妙的解法 CodeWars这是CodeWars上的一题，我觉得挺有意思的。CodeWars其实和leetcode差不多，但是我更喜欢有这几点。 界面 看着挺舒服的，同时提供了测试代码。 够简单真的，CodeWars上有些题目真的很简单，适合我这种新手，哈哈，比如： 123456# Complete the solution so that it reverses the string value passed into it.## solution('world') # returns 'dlrow'def solution(string): return string[::-1] 还可以选择问题类型。 可以自己出题，还可以邀请队友www.codewars.com/r/UsAiUQcodewars 点一下，就可以成为我的盟友。 点一下，玩一年，装逼不花一分钱！ 可以上榜leaderboard 第二名竟然是国人唉，不知是哪位大佬。希望有更多中国人可以出现在上面。 后话目前我也还是一个萌新，希望大佬能带带我。 我在Github上开了一个仓库，codewars_python 里面都是用 python的解题方法，但是现在还只有几题而已，希望大家可以一起来参与，多提pr。 1234567891011121314151617181920212223# -*- coding: utf-8 -*-# ATM machines allow 4 or 6 digit PIN codes and PIN codes cannot contain anything but exactly 4 digits or exactly 6 digits.# If the function is passed a valid PIN string, return true, else return false.# eg:# validate_pin(\"1234\") == True# validate_pin(\"12345\") == False# validate_pin(\"a234\") == False# My Solutiuondef validate_pin(pin): #return true or false return pin.isdigit() if len(pin) == 4 or len(pin) == 6 else False # Wonderful Solutiuon def validate_pin(pin): return len(pin) in (4, 6) and pin.isdigit()","tags":[{"name":"算法","slug":"算法","permalink":"https://zhangslob.github.io/tags/算法/"},{"name":"codewars","slug":"codewars","permalink":"https://zhangslob.github.io/tags/codewars/"}]},{"title":"Scrapy中如何提高数据的插入速度","date":"2018-03-28T13:18:32.000Z","path":"2018/03/28/Scrapy中如何提高数据的插入速度/","text":"这是崔斯特的第三十九篇原创文章 长期更新 (๑• . •๑) 速度问题最近工作中遇到这么一个问题，全站抓取时采用分布式：爬虫A与爬虫B，爬虫A给爬虫B喂饼，爬虫B由于各种原因运行的比较慢，达不到预期效果，所以必须对爬虫B进行优化。 提升Scrapy运行速度有很多方法，国外有大佬说过 Speed up web scraper Here’s a collection of things to try: use latest scrapy version (if not using already) check if non-standard middlewares are used try to increase CONCURRENT_REQUESTS_PER_DOMAIN, CONCURRENT_REQUESTS settings (docs)turn off logging LOG_ENABLED = False (docs) try yielding an item in a loop instead of collecting items into the items list and returning themuse local cache DNS (see this thread) check if this site is using download threshold and limits your download speed (see this thread)log cpu and memory usage during the spider run - see if there are any problems there try run the same spider under scrapyd service see if grequests + lxml will perform better (ask if you need any help with implementing this solution) try running Scrapy on pypy, see Running Scrapy on PyPy 大致看了下，确实可以提高爬虫运行速度，但是对于海量数据（这里说的是百万级）还需要考虑一点的就是数据插入问题，这里我们使用的是 Mongo。 官方示例让我们先从官方文档开始 Write items to MongoDB 123456789101112131415161718192021222324252627import pymongoclass MongoPipeline(object): collection_name = 'scrapy_items' def __init__(self, mongo_uri, mongo_db): self.mongo_uri = mongo_uri self.mongo_db = mongo_db @classmethod def from_crawler(cls, crawler): return cls( mongo_uri=crawler.settings.get('MONGO_URI'), mongo_db=crawler.settings.get('MONGO_DATABASE', 'items') ) def open_spider(self, spider): self.client = pymongo.MongoClient(self.mongo_uri) self.db = self.client[self.mongo_db] def close_spider(self, spider): self.client.close() def process_item(self, item, spider): self.db[self.collection_name].insert_one(dict(item)) return item 比较简单，这里插入使用的方法是 insert_one，继续文档： insert_one(document, bypass_document_validation=False, session=None) Insert a single document.1234567&gt;&gt;&gt; db.test.count(&#123;'x': 1&#125;)0&gt;&gt;&gt; result = db.test.insert_one(&#123;'x': 1&#125;)&gt;&gt;&gt; result.inserted_idObjectId('54f112defba522406c9cc208')&gt;&gt;&gt; db.test.find_one(&#123;'x': 1&#125;)&#123;u'x': 1, u'_id': ObjectId('54f112defba522406c9cc208')&#125; 以前经常使用的 insert 方法，已经不被赞同 insert(doc_or_docs, manipulate=True, check_keys=True, continue_on_error=False, **kwargs) Insert a document(s) into this collection.123DEPRECATED - Use insert_one() or insert_many() instead.Changed in version 3.0: Removed the safe parameter. Pass w=0 for unacknowledged write operations. insert 简单理解就是插入，把我们采集到的 item 插入到数据库，这样存在一个很严重的问题，就是去重 去重晚上有一种很流行的写法，使用 update命令，如： self.db[self.collection_name].update({&#39;id&#39;: item[&#39;id&#39;]}, {&#39;$set&#39;: dict(item)}, True) 解释为： 比较重要的一点就在于process_item，在这里使用了update方法，第一个参数传入查询条件，这里使用的是id，第二个参数传入字典类型的对象，就是我们的item，第三个参数传入True，这样就可以保证，如果查询数据存在的话就更新，不存在的话就插入。这样就可以保证去重了。 这确实是一种很简单的方法，其实原理很简单，就是在每次插入数据前，对数据库中查询，是否有该 ID，如果没有就插入，如果有就放弃。 对于数据量比较少的项目，这确实是一种很简单的方法，很简单就完成了目标。 但是，我们现在说的是百万级数据，如果每一条数据在插入前，都需要去查询该数据是否在数据库，那会多么耗时，效率会大大较低，那么还有什么好办法呢？ 索引MongoDB 索引索引能够实现高效地查询。没有索引，MongoDB 就必须扫描集合中的所有文档，才能找到匹配查询语句的文档。这种扫描毫无效率可言，需要处理大量的数据。 索引是一种特殊的数据结构，将一小块数据集保存为容易遍历的形式。索引能够存储某种特殊字段或字段集的值，并按照索引指定的方式将字段值进行排序。 我们可以借助索引，使用 insert_one方法提高效率。代码实现： 123456789101112131415161718class MongoDBPipeline(object): def open_spider(self, spider): self.client = mongodb_client self.db = self.client.get_database() self.collection = self.db['test'] # 添加唯一索引 self.collection.create_index('id', unique=True) def close_spider(self, spider): self.client.close() def process_item(self, item, spider): try: self.collection.insert_one(dict(item)) return item except DuplicateKeyError: spider.logger.debug(' duplicate key error collection') return item 其实很简单，就是在 open_spider先创建唯一索引，然后再插入数据。注意需要在process_item中使用异常处理，因为很有可能插入重复数据，到时候就会输出日志。 其他方法mongo 除了 insert_one方法还有一种，insert_many insert_many(documents, ordered=True, bypass_document_validation=False, session=None) Insert an iterable of documents.1234567&gt;&gt;&gt; db.test.count()0&gt;&gt;&gt; result = db.test.insert_many([&#123;'x': i&#125; for i in range(2)])&gt;&gt;&gt; result.inserted_ids[ObjectId('54f113fffba522406c9cc20e'), ObjectId('54f113fffba522406c9cc20f')]&gt;&gt;&gt; db.test.count()2 这样插入的数据不再是一条，而是很多， What’s the difference between insert(), insertOne() and insertMany() methods on MongoDB 大佬有写到，可以去看看。 同时插入多条数据，减轻数据库压力。但是这个“多”到底还是多少，目前不得而知。 结语除了更多机器和更多节点，还有很多方法可以提升 Scrapy运行速度。 今天说到的是管道阻塞问题，还有其他地方也可以优化，还需要努力。","tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://zhangslob.github.io/tags/爬虫/"},{"name":"Scrapy","slug":"Scrapy","permalink":"https://zhangslob.github.io/tags/Scrapy/"}]},{"title":"Hi，这里是我的爬虫笔记","date":"2018-03-25T13:37:15.000Z","path":"2018/03/25/Hi，这里是我的爬虫笔记/","text":"这是崔斯特的第三十八篇原创文章 长期更新 (๑• . •๑) 平时有个习惯，会把自己的笔记写在有道云里面，现在做个整理。会长期更新，因为我是BUG制造机。 解析xpath提取所有节点文本1&lt;div id=\"test3\"&gt;我左青龙，&lt;span id=\"tiger\"&gt;右白虎，&lt;ul&gt;上朱雀，&lt;li&gt;下玄武。&lt;/li&gt;&lt;/ul&gt;老牛在当中，&lt;/span&gt;龙头在胸口。&lt;div&gt; 使用xpath的string(.) 123456789101112#!/usr/bin/env python# -*- coding: utf-8 -*-from scrapy.selector import Selectortext = '&lt;div id=\"test3\"&gt;我左青龙，&lt;span id=\"tiger\"&gt;右白虎，&lt;ul&gt;上朱雀，&lt;li&gt;下玄武。&lt;/li&gt;&lt;/ul&gt;老牛在当中，&lt;/span&gt;龙头在胸口。&lt;div&gt;'s = Selector(text=text)data = s.xpath('//div[@id=\"test3\"]')info = data.xpath('string(.)').extract()[0]print(info)# output: 我左青龙，右白虎，上朱雀，下玄武。老牛在当中，龙头在胸口。 如何解决详情页面元素改变这个问题是这样产生的，在很多PC站，比如链家，这个页面有这些字段A，但是下个页面这个字段A没了，取而代之的是字段B，在xpath定位时就失效了。这个问题很常见，大体思路是这样的。 创建一个包含所有字段的dict: data = {}.fromkeys((&#39;url&#39;, &#39;price&#39;, &#39;address&#39;)) 然后根据网页中是否有字段来取值，例如，有’url’就取对应的value，没有则为空 这样就可以完美解决匹配不全问题 Scrapy 相关文件编写逻辑文件和解析部分分开写，匹配文件目录是utils/parse/，爬虫文件目录是spiders/ Scrapy 中文乱码在 setting 文件中设置：FEED_EXPORT_ENCODING = &#39;utf-8&#39; Scrapy 使用Mongopipelines.py 首先我们要从settings文件中读取数据的地址、端口、数据库名称。 拿到数据库的基本信息后进行连接。 将数据写入数据库（update制定唯一键） 关闭数据库 注意：只有打开和关闭是只执行一次，而写入操作会根据具体的写入次数而定。Redis 无需关闭12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import pymongo class MongoDBPipeline(object): \"\"\" 1、连接数据库操作 \"\"\" def __init__(self,mongourl,mongoport,mongodb): ''' 初始化mongodb数据的url、端口号、数据库名称 :param mongourl: :param mongoport: :param mongodb: ''' self.mongourl = mongourl self.mongoport = mongoport self.mongodb = mongodb @classmethod def from_crawler(cls,crawler): \"\"\" 1、读取settings里面的mongodb数据的url、port、DB。 :param crawler: :return: \"\"\" return cls( mongourl = crawler.settings.get(\"MONGO_URL\"), mongoport = crawler.settings.get(\"MONGO_PORT\"), mongodb = crawler.settings.get(\"MONGO_DB\") ) def open_spider(self,spider): ''' 1、连接mongodb数据 :param spider: :return: ''' self.client = pymongo.MongoClient(self.mongourl,self.mongoport) self.db = self.client[self.mongodb] def process_item(self,item,spider): ''' 1、将数据写入数据库 :param item: :param spider: :return: ''' name = item.__class__.__name__ # self.db[name].insert(dict(item)) self.db['user'].update(&#123;'url_token':item['url_token']&#125;,&#123;'$set':item&#125;,True) return item def close_spider(self,spider): ''' 1、关闭数据库连接 :param spider: :return: ''' self.client.close() scrapy图片下载12345678910111213141516import scrapyfrom scrapy.pipelines.images import ImagesPipelinefrom scrapy.exceptions import DropItemclass MyImagesPipeline(ImagesPipeline): def get_media_requests(self, item, info): for image_url in item['image_urls']: yield scrapy.Request(image_url) def item_completed(self, results, item, info): image_paths = [x['path'] for ok, x in results if ok] if not image_paths: raise DropItem(\"Item contains no images\") item['image_paths'] = image_paths return item scrapy 暂停爬虫scrapy crawl somespider -s JOBDIR=crawls/somespider-1 scrapy_redis 分布式使用队列与去重即可完成分布式需求，需要注意的是 Redis 格式，默认采用的是 list， 可以在 settings.py 文件中设置 REDIS_START_URLS_AS_SET = True，使用 Redis的 set类型（去重种子链接） 安装超时问题自定义超时时间 sudo pip3 --default-timeout=100 install -U scrapy 或者 使用其他源 sudo pip3 install scrapy -i https://pypi.tuna.tsinghua.edu.cn/simple 权限问题安装某模块时，报错：PermissionError: [WinError 5] 拒绝访问。: &#39;c:\\\\program files\\\\python35\\\\Lib\\\\sit e-packages\\\\lxml&#39; 最简单方法：pip install --user lxml Pycharm 相关.gitignore 文件安装插件： Preferences &gt; Plugins &gt; Browse repositories... &gt; Search for &quot;.ignore&quot; &gt; Install Plugin 然后就可以很方便的添加到 .gitignore 显示函数 点击 Show Members，查看目录，会显示相应的类和函数 激活码 http://idea.liyang.io http://xidea.online 数据Mongo导出命令λ mongoexport -d test -c set --type=csv -f name,age -o set.csv λ mongoexport -h 10.10.10.11 -d test -c test --type=csv -f url,id,title -o data.csv 其他requirements.txt 文件小提示：使用 pigar 可以一键生成 requirements.txt 文件 Installation：pip install pigar Usage：pigar 好了，今天先写这点，以后再补上。","tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://zhangslob.github.io/tags/爬虫/"}]},{"title":"学习Git（二）基本操作","date":"2018-03-19T13:11:39.000Z","path":"2018/03/19/学习Git（二）基本操作/","text":"这是崔斯特的第三十七篇原创文章 继续补基础 (๑• . •๑) Git 基础操作1. 创建版本库什么是版本库呢？版本库又名仓库，英文名 repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被 Git 管理起来，每个文件的修改、删除，Git 都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录： 1234$ mkdir learngit$ cd learngit$ pwd/Users/learngit pwd命令用于显示当前目录。 如果你使用 Windows 系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。 第二步，通过git init命令把这个目录变成 Git 可以管理的仓库： 12$ git initInitialized empty Git repository in /Users/learngit/.git/ 瞬间 Git 就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository） 用ls -ah命令就可以看见当前目录下多了一个.git的目录，这个目录是 Git 来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把 Git 仓库给破坏了。 一定要放到 learngit 目录下或子目录下 1$ git status # 随时用git status 查看文件状态 一个文件放到 Git 仓库只需要两步。 用命令git add告诉 Git，把文件添加到仓库： 1$ git add . # 把所有文件都添加到仓库 执行上面的命令，没有任何显示，这就对了，Unix 的哲学是“没有消息就是好消息”，说明添加成功。（因为没有添加任何文件，如果添加结果不同，可以使用 git status 随时查看 Git 状态） 用命令git commit告诉 Git，把文件提交到仓库： 1234$ git commit abc/aaa.py -m\"chore:wrote a readme file\"[master (root-commit) cb926e7] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 aaa.py commit 必须遵循commit规范123456789**git commit规范**- feat：新功能（feature）- fix：修补bug- docs：文档（documentation）- style： 格式（不影响代码运行的变动）- refactor：重构（即不是新增功能，也不是修改bug的代码变动）- test：增加测试- chore：构建过程或辅助工具的变动 2. 新机器配置 Git 创建 SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到第2步。如果没有，打开 Shell（Windows 下打开 Git Bash），创建 SSH Key： 1$ ssh-keygen -t rsa -C \"你的github邮箱\" 把邮件地址换成你自己的邮件地址，一路回车，使用默认值即可，无需设置密码。 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有 id_rsa 和 id_rsa.pub 两个文件，这两个就是 SSH Key 的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 登陆 GitHub，打开“Account settings”，“SSH Keys”页面： 然后，点“Add SSH Key”，填上任意 Title，在 Key 文本框里粘贴id_rsa.pub文件的内容： 点“Add Key”，你就应该看到已经添加的 Key 当然，GitHub 允许你添加多个 Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的 Key 都添加到 GitHub，就可以在每台电脑上往 GitHub 推送了。 3. 关联远程库 如果公司已创建该项目的远程库，本地还没有，clone 该项目地址: clone with ssh 1$ git clone git@github.com:xxxx/xxx.git SSH 警告 当你第一次使用 Git 的 clone 或者 push 命令连接 GitHub 时，会得到一个警告： 123The authenticity of host 'github.com (xx.xx.xx.xx)' can't be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes/no)? 这是因为 Git 使用 SSH 连接，而 SSH 连接在第一次验证 GitHub 服务器的 Key 时，需要你确认 GitHub 的 Key 的指纹信息是否真的来自 GitHub 的服务器，输入 yes 回车即可。 Git 会输出一个警告，告诉你已经把 GitHub 的 Key 添加到本机的一个信任列表里了： 1Warning: Permanently added 'github.com' (RSA) to the list of known hosts. 这个警告只会出现一次，后面的操作就不会有任何警告了。 ​ 如果已经在本地创建了一个 Git 仓库后，公司也已在 GitHub 创建一个 Git 仓库， 实现让这两个仓库进行远程同步 1$ git remote add origin git@github.com:xxxx/xxxx.git 下一步，就可以把本地库的所有内容推送到远程库上 1$ git push -u origin master 把本地库的内容推送到远程，用git push命令，实际上是把当前分支 master 推送到远程。 由于远程库是空的，我们第一次推送 master 分支时，加上了-u参数，Git 不但会把本地的 master 分支内容推送的远程新的 master 分支，还会把本地的 master 分支和远程的 master 分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在 GitHub 页面中看到远程库的内容已经和本地一模一样 从现在起，只要本地作了提交，就可以通过命令： $ git push origin master 把本地master分支的最新修改推送至GitHub 一般我们在develop分支开发 如果github上没有develop分支 首先，我们在本地创建 develop 分支，然后切换到 develop 分支： 12$ git checkout -b developSwitched to a new branch 'develop' git checkout命令加上-b参数表示创建并切换，相当于以下两条命令： 123$ git branch develop$ git checkout developSwitched to branch 'develop' 然后，用git branch命令查看当前分支： 123$ git branch* develop master git branch命令会列出所有分支，当前分支前面会标一个*号 发布develop分支 发布dev分支指的是同步develop分支的代码到远程服务器 12git push origin develop:develop # 这样远程仓库也有一个develop分支了 或者git push origin develop # 这两种应该都可以 如果github已经有master分支和develop分支 在本地 git checkout -b develop 新建并切换到本地develop分支 git pull origin develop 本地develop分支与远程develop分支相关联 Git 总结1234567891011121314151617git add . # 添加所有改动的文件到仓库git commit 文件路径 -m'fix:修复xx bug'# github上已经有master分支 和dev分支在本地git checkout -b dev # 创建+切换分支devgit pull origin dev # 本地分支与远程分支相关联dev# github无dev分支，在本地新建分支并推送到远程git checkout -b devgit push origin dev:dev # 这样远程仓库中也就创建了一个dev分支git branch # 查看本地有多少分支git branch 分支名字 # 创建分支git checkout dev # 切换到dev分支进行开发git push # 提交到远程git branch -d dev # 删除本地dev分支git merge dev # 合并dev到当前分支(master) git remote 深入研究 git-remote - Manage set of tracked repositories 12345678910111213git remote [-v | --verbose]git remote add [-t &lt;branch&gt;] [-m &lt;master&gt;] [-f] [--[no-]tags] [--mirror=&lt;fetch|push&gt;] &lt;name&gt; &lt;url&gt;git remote rename &lt;old&gt; &lt;new&gt;git remote remove &lt;name&gt;git remote set-head &lt;name&gt; (-a | --auto | -d | --delete | &lt;branch&gt;)git remote set-branches [--add] &lt;name&gt; &lt;branch&gt;…​git remote get-url [--push] [--all] &lt;name&gt;git remote set-url [--push] &lt;name&gt; &lt;newurl&gt; [&lt;oldurl&gt;]git remote set-url --add [--push] &lt;name&gt; &lt;newurl&gt;git remote set-url --delete [--push] &lt;name&gt; &lt;url&gt;git remote [-v | --verbose] show [-n] &lt;name&gt;…​git remote prune [-n | --dry-run] &lt;name&gt;…​git remote [-v | --verbose] update [-p | --prune] [(&lt;group&gt; | &lt;remote&gt;)…​] 查看远程仓库如果想查看你已经配置的远程仓库服务器，可以运行 git remote 命令。 它会列出你指定的每一个远程服务器的简写。 如果你已经克隆了自己的仓库，那么至少应该能看到 origin - 这是 Git 给你克隆的仓库服务器的默认名字： 12345678910$ git clone https://github.com/schacon/ticgitCloning into 'ticgit'...remote: Reusing existing pack: 1857, done.remote: Total 1857 (delta 0), reused 0 (delta 0)Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.Resolving deltas: 100% (772/772), done.Checking connectivity... done.$ cd ticgit$ git remoteorigin 你也可以指定选项 -v，会显示需要读写远程仓库使用的 Git 保存的简写与其对应的 URL。123$ git remote -vorigin https://github.com/schacon/ticgit (fetch)origin https://github.com/schacon/ticgit (push) 如果你的远程仓库不止一个，该命令会将它们全部列出。 例如，与几个协作者合作的，拥有多个远程仓库的仓库看起来像下面这样： 123456789101112$ cd grit$ git remote -vbakkdoor https://github.com/bakkdoor/grit (fetch)bakkdoor https://github.com/bakkdoor/grit (push)cho45 https://github.com/cho45/grit (fetch)cho45 https://github.com/cho45/grit (push)defunkt https://github.com/defunkt/grit (fetch)defunkt https://github.com/defunkt/grit (push)koke git://github.com/koke/grit.git (fetch)koke git://github.com/koke/grit.git (push)origin git@github.com:mojombo/grit.git (fetch)origin git@github.com:mojombo/grit.git (push) 这样我们可以轻松拉取其中任何一个用户的贡献。 此外，我们大概还会有某些远程仓库的推送权限，虽然我们目前还不会在此介绍。 注意这些远程仓库使用了不同的协议；我们将会在 在服务器上搭建 Git 中了解关于它们的更多信息。 添加远程仓库运行 git remote add &lt;shortname&gt; &lt;url&gt; 添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写：12345678$ git remoteorigin$ git remote add pb https://github.com/paulboone/ticgit$ git remote -vorigin https://github.com/schacon/ticgit (fetch)origin https://github.com/schacon/ticgit (push)pb https://github.com/paulboone/ticgit (fetch)pb https://github.com/paulboone/ticgit (push) 现在你可以在命令行中使用字符串 pb 来代替整个 URL。 例如，如果你想拉取 Paul 的仓库中有但你没有的信息，可以运行 git fetch pb：12345678$ git fetch pbremote: Counting objects: 43, done.remote: Compressing objects: 100% (36/36), done.remote: Total 43 (delta 10), reused 31 (delta 5)Unpacking objects: 100% (43/43), done.From https://github.com/paulboone/ticgit * [new branch] master -&gt; pb/master * [new branch] ticgit -&gt; pb/ticgit 现在 Paul 的 master 分支可以在本地通过 pb/master 访问到 - 你可以将它合并到自己的某个分支中，或者如果你想要查看它的话，可以检出一个指向该点的本地分支。 ##从远程仓库中抓取与拉取就如刚才所见，从远程仓库中获得数据，可以执行： $ git fetch [remote-name]这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。 如果你使用 clone 命令克隆了一个仓库，命令会自动将其添加为远程仓库并默认以 “origin” 为简写。 所以，git fetch origin 会抓取克隆（或上一次抓取）后新推送的所有工作。 必须注意 git fetch 命令会将数据拉取到你的本地仓库 - 它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。 如果你有一个分支设置为跟踪一个远程分支，可以使用 git pull 命令来自动的抓取然后合并远程分支到当前分支。 这对你来说可能是一个更简单或更舒服的工作流程；默认情况下，git clone 命令会自动设置本地 master 分支跟踪克隆的远程仓库的 master 分支（或不管是什么名字的默认分支）。 运行 git pull 通常会从最初克隆的服务器上抓取数据并自动尝试合并到当前所在的分支。 推送到远程仓库当你想分享你的项目时，必须将其推送到上游。 这个命令很简单：git push [remote-name] [branch-name]。 当你想要将 master 分支推送到 origin 服务器时（再次说明，克隆时通常会自动帮你设置好那两个名字），那么运行这个命令就可以将你所做的备份到服务器： $ git push origin master只有当你有所克隆服务器的写入权限，并且之前没有人推送过时，这条命令才能生效。 当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先将他们的工作拉取下来并将其合并进你的工作后才能推送。 查看远程仓库如果想要查看某一个远程仓库的更多信息，可以使用 git remote show [remote-name] 命令。 如果想以一个特定的缩写名运行这个命令，例如 origin，会得到像下面类似的信息：123456789101112$ git remote show origin* remote origin Fetch URL: https://github.com/schacon/ticgit Push URL: https://github.com/schacon/ticgit HEAD branch: master Remote branches: master tracked dev-branch tracked Local branch configured for 'git pull': master merges with remote master Local ref configured for 'git push': master pushes to master (up to date) 它同样会列出远程仓库的 URL 与跟踪分支的信息。 这些信息非常有用，它告诉你正处于 master 分支，并且如果运行 git pull，就会抓取所有的远程引用，然后将远程 master 分支合并到本地 master 分支。 它也会列出拉取到的所有远程引用。 这是一个经常遇到的简单例子。 如果你是 Git 的重度使用者，那么还可以通过 git remote show 看到更多的信息。1234567891011121314151617181920$ git remote show origin* remote origin URL: https://github.com/my-org/complex-project Fetch URL: https://github.com/my-org/complex-project Push URL: https://github.com/my-org/complex-project HEAD branch: master Remote branches: master tracked dev-branch tracked markdown-strip tracked issue-43 new (next fetch will store in remotes/origin) issue-45 new (next fetch will store in remotes/origin) refs/remotes/origin/issue-11 stale (use 'git remote prune' to remove) Local branches configured for 'git pull': dev-branch merges with remote dev-branch master merges with remote master Local refs configured for 'git push': dev-branch pushes to dev-branch (up to date) markdown-strip pushes to markdown-strip (up to date) master pushes to master (up to date) 这个命令列出了当你在特定的分支上执行 git push 会自动地推送到哪一个远程分支。 它也同样地列出了哪些远程分支不在你的本地，哪些远程分支已经从服务器上移除了，还有当你执行 git pull 时哪些分支会自动合并。 远程仓库的移除与重命名如果想要重命名引用的名字可以运行 git remote rename 去修改一个远程仓库的简写名。 例如，想要将 pb 重命名为 paul，可以用 git remote rename 这样做：1234$ git remote rename pb paul$ git remoteoriginpaul 值得注意的是这同样也会修改你的远程分支名字。 那些过去引用 pb/master 的现在会引用 paul/master。 如果因为一些原因想要移除一个远程仓库 - 你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了 - 可以使用 git remote rm ：123$ git remote rm paul$ git remoteorigin 回顾：学习Git（一）起步","tags":[{"name":"Git","slug":"Git","permalink":"https://zhangslob.github.io/tags/Git/"}]},{"title":"学习Git（一）起步","date":"2018-03-14T14:52:36.000Z","path":"2018/03/14/学习Git（一）起步/","text":"这是崔斯特的第三十六篇原创文章 开始补基础 (๑• . •๑) 什么是Git在Git官网上找到这样一段描述 Git is a free and open source distributed version control system designed to handle everything from small to very large projects with speed and efficiency. 重点是 version control system (VCS)，翻译过来也就是 版本控制系统。（Pycharm中有一个） 关于版本控制版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 （我的理解就是一个东西会有不同的版本，就像吃鸡，常常更新，每更新一次就是一个新的版本，如果刚发行的版本出现毒圈不掉血，这个时候就需要版本回退。。版本控制系统就体现作用了） 版本控制系统又分为：本地版本控制系统、集中化的版本控制系统、分布式版本控制系统。 本地版本控制系统 集中化的版本控制系统 分布式版本控制系统 更多介绍可以来看 1.1 起步 - 关于版本控制 谁开发了 Git2002 年，Linux 内核开源项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。 但是到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 这就迫使 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。 他们对新的系统制订了若干目标： 速度 简单的设计 对非线性开发模式的强力支持（允许成千上万个并行开发的分支） 完全分布式 有能力高效管理类似 Linux 内核一样的超大规模项目（速度和数据量） Git 特点Git 工作流基本的 Git 工作流程如下： 克隆 Git 资源作为工作目录。 在克隆的资源上添加或修改文件。 如果其他人修改了，你可以更新资源。 在提交前查看修改。 提交修改。 在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。 近乎所有操作都是本地执行在 Git 中的绝大多数操作都只需要访问本地文件和资源，一般不需要来自网络上其它计算机的信息。 举个例子，要浏览项目的历史，Git 不需外连到服务器去获取历史，然后再显示出来——它只需直接从本地数据库中读取。 你能立即看到项目历史。 如果你想查看当前版本与一个月前的版本之间引入的修改，Git 会查找到一个月前的文件做一次本地的差异计算，而不是由远程服务器处理或从远程服务器拉回旧版本文件再来本地处理。 Git 保证完整性Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。 Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来。 SHA-1 哈希看起来是这样： 24b9da6552252987aa493b52f8696cd6d3b00373 Git 中使用这种哈希值的情况很多，你将经常看到这种哈希值。 实际上，Git 数据库中保存的信息都是以文件内容的哈希值来索引，而不是文件名。 Git 一般只添加数据你执行的 Git 操作，几乎只往 Git 数据库中增加数据。 很难让 Git 执行任何不可逆操作，或者让它以任何方式清除数据。 同别的 VCS 一样，未提交更新时有可能丢失或弄乱修改的内容；但是一旦你提交快照到 Git 中，就难以再丢失数据，特别是如果你定期的推送数据库到其它仓库的话。 Git 的三种状态 已提交（committed）：数据已经安全的保存在本地数据库中。 已修改（modified） ：修改了文件，但还没保存到数据库中。 已暂存（staged） ：对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 由此引入 Git 项目的三个工作区域的概念：Git 仓库、工作目录以及暂存区域。 安装 Git说了那么多，现在开始动手，安装Git。 Linux$ sudo yum install git 或者 $ sudo apt-get install git Mac下载安装包 Downloading Git 或者 $ brew install git Windows直接下载文件 Downloading Git 或者 安装 GitHub for Windows 初次运行 Git 前的配置用户信息12$ git config --global user.name &quot;name&quot;$ git config --global user.email example@example.com 如果使用了 --global 选项，那么该命令只需要运行一次，因为之后无论你在该系统上做任何事情， Git 都会使用那些信息。 检查配置信息12345678$ git config --listuser.name=nameuser.email=example@example.comcolor.status=autocolor.branch=autocolor.interactive=autocolor.diff=auto... 获取帮助若你使用 Git 时需要获取帮助，有三种方法可以找到 Git 命令的使用手册：123$ git help &lt;verb&gt;$ git &lt;verb&gt; --help$ man git-&lt;verb&gt; 例如，要想获得 config 命令的手册，执行 $ git help config 总结以前只是了解 Git常见的push、commit等命令，从没有对 Git进性过系统学习，抓紧时间学习。 目标：两周后，也就是3月28日，能熟练使用 Git进性开发。 这一篇主要讲了些背景知识吧，下一篇就是实际的操作了。 主要从Git文档上截取自己认为重要的部分，有条件可以去仔细阅读。","tags":[{"name":"Git","slug":"Git","permalink":"https://zhangslob.github.io/tags/Git/"}]},{"title":"大佬，我代码哪错了？","date":"2018-03-13T13:30:03.000Z","path":"2018/03/13/大佬，我代码哪错了？/","text":"这是崔斯特的第三十五篇原创文章 到底哪错了 (๑• . •๑) 问题无处不在我： “大佬，帮我看看这个问题错在哪了？” 大佬： “你的代码呢、你的错误提示呢？” 我： “好的，我发给你” 大佬： “。。。 再见” 留下一脸懵逼的我 如何解决问题最简单的方法是根据错误提示，查看对应位置的代码，Pycharm会提示具体是哪一行代码有问题，并抛出错误。 找到错误首先应自己想办法解决，自己解决又分为几种：有经验的大佬看到Error就知道是哪里有问题了，没经验怎么办，那就自己去搜索了。 下个结论，你遇到的问题，前人一定遇到过。 所以你只需要把你的错误提示搜索就好了。 注意下面，你懂的。（给自己一个好点的环境） Google &gt; 百度 stackoverflow &gt; 知乎 github &gt; CSDN Github上有一个很有用的 trending ，可以显示今天或本周或本月最火的项目，例如： techGay/91porn Github 作为全球最大的同性交友网站，上面有很多值得我们好好学习的东西。 如何向别人提问如果你真的像上面哪样，发一张照片，估计大佬都要吐血了。 在这里推荐大家使用Github上的 gist ，很适合分享代码片段。 Instantly share code, notes, and snippets. 例如这样 Issue in FromRequest #3144 这样看起来是不是舒服多了 如何才能 永无bug1、佛祖保佑 永无bug12345678910111213141516171819202122232425262728293031// _ooOoo_// o8888888o// 88\" . \"88// (| -_- |)// O\\ = /O// ____/`---'\\____// . ' \\\\| |// `.// / \\\\||| : |||// \\// / _||||| -:- |||||- \\// | | \\\\\\ - /// | |// | \\_| ''\\---/'' | |// \\ .-\\__ `-` ___/-. /// ___`. .' /--.--\\ `. . __// .\"\" '&lt; `.___\\_&lt;|&gt;_/___.' &gt;'\"\".// | | : `- \\`.;`\\ _ /`;.`/ - ` : | |// \\ \\ `-. \\_ __\\ /__ _/ .-` / /// ======`-.____`-.___\\_____/___.-`____.-'======// `=---='//// .............................................// 佛祖镇楼 BUG辟易// 佛曰:// 写字楼里写字间，写字间里程序员；// 程序人员写程序，又拿程序换酒钱。// 酒醒只在网上坐，酒醉还来网下眠；// 酒醉酒醒日复日，网上网下年复年。// 但愿老死电脑间，不愿鞠躬老板前；// 奔驰宝马贵者趣，公交自行程序员。// 别人笑我忒疯癫，我笑自己命太贱；// 不见满街漂亮妹，哪个归得程序员？ 2、佛系编程 永无bugNo CodeNo code is the best way to write secure and reliable applications. Write nothing; deploy nowhere. Getting StartedStart by not writing any code. 12 This is just an example application, but imagine it doing anything you want. Adding new features is easy too: 12 The possibilities are endless. Building the ApplicationNow that you have not done anything it’s time to build your application: 12 Yep. That’s it. You should see the following output: 12 DeployingWhile you still have not done anything it’s time to deploy your application. By running the following command you can deploy your application absolutely nowhere. 12 It’s that simple. And when it comes time to scale the application, all you have to do is: 12 I know right? ContributingYou don’t.","tags":[{"name":"编程","slug":"编程","permalink":"https://zhangslob.github.io/tags/编程/"}]},{"title":"学点算法之队列的学习及应用","date":"2018-03-06T12:54:00.000Z","path":"2018/03/06/学点算法之队列的学习及应用/","text":"这是崔斯特的第三十四篇原创文章 从约瑟夫问题开始说起 (๑• . •๑) 约瑟夫问题约瑟夫问题 有 n 个囚犯站成一个圆圈，准备处决。首先从一个人开始，越过k-2个人（因为第一个人已经被越过），并杀掉第k个人。接着，再越过 k-1个人，并杀掉第k个人。这个过程沿着圆圈一直进行，直到最终只剩下一个人留下，这个人就可以继续活着。 问题是，给定了n和k，一开始要站在什么地方才能避免被处决？ 这个问题是以弗拉维奥·约瑟夫命名的，它是1世纪的一名犹太历史学家。他在自己的日记中写道，他和他的40个战友被罗马军队包围在洞中。他们讨论是自杀还是被俘，最终决定自杀，并以抽签的方式决定谁杀掉谁。约瑟夫斯和另外一个人是最后两个留下的人。约瑟夫斯说服了那个人，他们将向罗马军队投降，不再自杀。约瑟夫斯把他的存活归因于运气或天意，他不知道是哪一个。 队列是什么这道题有多种解法，这里先不说别的，要引出今天的主角——队列。队列的定义很好理解： 队列是项的有序结合，其中添加新项的一端称为队尾，移除项的一端称为队首。当一个元素从队尾进入队列时，一直向队首移动，直到它成为下一个需要移除的元素为止。 队列抽象数据类型由以下结构和操作定义。如上所述，队列被构造为在队尾添加项的有序集合，并且从队首移除。队列保持 FIFO 排序属性。 队列操作如下。 Queue() 创建一个空的新队列。 它不需要参数，并返回一个空队列。 enqueue(item) 将新项添加到队尾。 它需要 item 作为参数，并不返回任何内容。 dequeue() 从队首移除项。它不需要参数并返回 item。 队列被修改。 isEmpty() 查看队列是否为空。它不需要参数，并返回布尔值。 size() 返回队列中的项数。它不需要参数，并返回一个整数。 队列的Python算法实现为了实现队列抽象数据类型创建一个新类 pythonds/basic/queue.py 123456789101112131415class Queue: def __init__(self): self.items = [] def isEmpty(self): return self.items == [] def enqueue(self, item): self.items.insert(0,item) def dequeue(self): return self.items.pop() def size(self): return len(self.items) 想明白了其实就是对 list 的简单操作 如何活到最后那我们回到上面的问题，如果是你，你要如何选择并活到最后呢？ 我们的程序将输入名称列表和一个称为 num 常量用于报数。它将返回以 num 为单位重复报数后剩余的最后一个人的姓名。 假设第一个人是a。从他开始计数，a将先出列再入队列，把他放在队列的最后。经过 num 次的出队入队后，前面的人将被永久移除队列。并且另一个周期开始，继续此过程，直到只剩下一个名字（队列的大小为 1）。 12345678910111213141516171819from pythonds.basic.queue import Queuedef hotPotato(namelist, num): simqueue = Queue() for name in namelist: simqueue.enqueue(name) while simqueue.size() &gt; 1: for i in range(num): simqueue.enqueue(simqueue.dequeue()) simqueue.dequeue() return simqueue.dequeue()print(hotPotato(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'], 7))# output: f 其他解法比较简单的做法是用循环单链表模拟整个过程，时间复杂度是O(n*m)。如果只是想求得最后剩下的人，则可以用数学推导的方式得出公式。先看看模拟过程的解法。 12345678910111213141516171819202122232425262728293031323334# -*- coding: utf-8 -*- class Node(object): def __init__(self, value): self.value = value self.next = Nonedef create_linkList(n): head = Node(1) pre = head for i in range(2, n+1): newNode = Node(i) pre.next= newNode pre = newNode pre.next = head return headn = 5 #总的个数m = 2 #数的数目if m == 1: #如果是1的话，特殊处理，直接输出 print(n) else: head = create_linkList(n) pre = None cur = head while cur.next != cur: #终止条件是节点的下一个节点指向本身 for i in range(m-1): pre = cur cur = cur.next print(cur.value) pre.next = cur.next cur.next = None cur = pre.next print(cur.value) 作业假设实验室里有一台打印机供学生共性。当学生向共享打印机发送打印任务时，任务被放置在队列中以便以先来先服务的方式被处理。如何才能通过python程序模拟的方式得到每次提交任务的平均等待时间呢？（平均等待时间不包括打印本身的时间，仅指在队列中排队的时间。）我们假定： 学生们每次打印的页数在1到20页之间。 打印机平均每小时会收到20个打印请求，即平均每180秒1个请求。 每秒新增任务的可能性相等，即任务的产生为独立同分布 打印机的打印速度恒定。 挖坑，要一起来填吗？","tags":[{"name":"算法","slug":"算法","permalink":"https://zhangslob.github.io/tags/算法/"},{"name":"队列","slug":"队列","permalink":"https://zhangslob.github.io/tags/队列/"}]},{"title":"Scrapy源码（2）——爬虫开始的地方","date":"2018-02-26T14:48:13.000Z","path":"2018/02/26/Scrapy源码（2）——爬虫开始的地方/","text":"这是崔斯特的第三十三篇原创文章 开始学习Scrapy源码 (๑• . •๑) Scrapy运行命令一般来说，运行Scrapy项目的写法有，（这里不考虑从脚本运行Scrapy） 1234567Usage examples:$ scrapy crawl myspider[ ... myspider starts crawling ... ]$ scrapy runspider myspider.py[ ... spider starts crawling ... ] 但是更好的写法是，新建一个Python文件，如下，（便于调试）123from scrapy import cmdlinecmdline.execute(\"scrapy crawl myspider\".split()) 很容易就发现，Scrapy运行文件是cmdline.py文件里面的execute()函数，下面学习下这个函数在做什么。 分析源码12345678910def execute(argv=None, settings=None): if argv is None: argv = sys.argv # --- backwards compatibility for scrapy.conf.settings singleton --- if settings is None and 'scrapy.conf' in sys.modules: from scrapy import conf if hasattr(conf, 'settings'): settings = conf.settings # ------------------------------------------------------------------ 寻找 scrapy.conf配置文件，argv直接取sys.argv 123456789101112131415161718if settings is None: settings = get_project_settings() # set EDITOR from environment if available try: editor = os.environ['EDITOR'] except KeyError: pass else: settings['EDITOR'] = editorcheck_deprecated_settings(settings)# --- backwards compatibility for scrapy.conf.settings singleton ---import warningsfrom scrapy.exceptions import ScrapyDeprecationWarningwith warnings.catch_warnings(): warnings.simplefilter(\"ignore\", ScrapyDeprecationWarning) from scrapy import conf conf.settings = settings# ------------------------------------------------------------------ set EDITOR from environment if available 读取settings设置文件，导入项目，调用get_project_settings()函数，此处为utils文件夹下的project.py文件： 1234def get_project_settings(): if ENVVAR not in os.environ: project = os.environ.get('SCRAPY_PROJECT', 'default') init_env(project) project.py init_env() 函数如下： 12345678910111213def init_env(project='default', set_syspath=True): \"\"\"Initialize environment to use command-line tool from inside a project dir. This sets the Scrapy settings module and modifies the Python path to be able to locate the project module. \"\"\" cfg = get_config() if cfg.has_option('settings', project): os.environ['SCRAPY_SETTINGS_MODULE'] = cfg.get('settings', project) closest = closest_scrapy_cfg() if closest: projdir = os.path.dirname(closest) if set_syspath and projdir not in sys.path: sys.path.append(projdir) conf.py 如注释所说，初始化环境,循环递归找到用户项目中的配置文件settings.py,并且将其设置到环境变量Scrapy settings module中。然后修改Python路径，确保能找到项目模块。 123456789101112131415161718settings = Settings()settings_module_path = os.environ.get(ENVVAR)if settings_module_path: settings.setmodule(settings_module_path, priority='project')# XXX: remove this hackpickled_settings = os.environ.get(\"SCRAPY_PICKLED_SETTINGS_TO_OVERRIDE\")if pickled_settings: settings.setdict(pickle.loads(pickled_settings), priority='project')# XXX: deprecate and remove this functionalityenv_overrides = &#123;k[7:]: v for k, v in os.environ.items() if k.startswith('SCRAPY_')&#125;if env_overrides: settings.setdict(env_overrides, priority='project')return settings project.py 至此，get_project_settings()该函数结束，如函数名字一样，最后返回项目配置，到此为止，接着往下看 1234567891011inproject = inside_project()cmds = _get_commands_dict(settings, inproject)cmdname = _pop_command_name(argv)parser = optparse.OptionParser(formatter=optparse.TitledHelpFormatter(), \\ conflict_handler='resolve')if not cmdname: _print_commands(settings, inproject) sys.exit(0)elif cmdname not in cmds: _print_unknown_command(settings, cmdname, inproject) sys.exit(2) 导入相应的module爬虫模块（inside_project） 执行环境是否在项目中，主要检查scrapy.cfg配置文件是否存在，读取commands文件夹，把所有的命令类转换为{cmd_name: cmd_instance}的字典 12345678cmd = cmds[cmdname]parser.usage = \"scrapy %s %s\" % (cmdname, cmd.syntax())parser.description = cmd.long_desc()settings.setdict(cmd.default_settings, priority='command')cmd.settings = settingscmd.add_options(parser)opts, args = parser.parse_args(args=argv[1:])_run_print_help(parser, cmd.process_options, args, opts) 根据命令名称找到对应的命令实例，设置项目配置和级别为command，添加解析规则，解析命令参数，并交由Scrapy命令实例处理。 最后，看看下面这段代码。 123cmd.crawler_process = CrawlerProcess(settings)_run_print_help(parser, _run_command, cmd, args, opts)sys.exit(cmd.exitcode) 初始化CrawlerProcess实例，将对应的命令执行，这里是crawl 12345def _run_command(cmd, args, opts): if opts.profile: _run_command_profiled(cmd, args, opts) else: cmd.run(args, opts) 看到这，想起了文档中的介绍 Run Scrapy from a script 123456789101112131415# Here’s an example showing how to run a single spider with it.import scrapyfrom scrapy.crawler import CrawlerProcessclass MySpider(scrapy.Spider): # Your spider definition ...process = CrawlerProcess(&#123; 'USER_AGENT': 'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)'&#125;)process.crawl(MySpider)process.start() # the script will block here until the crawling is finished 所以Scrapy爬虫运行都有用使用到CrawlerProcess，想要深入了解可以去看看源码 scrapy/scrapy/crawler.py 123456789101112131415161718192021\"\"\"A class to run multiple scrapy crawlers in a process simultaneously.This class extends :class:`~scrapy.crawler.CrawlerRunner` by adding supportfor starting a Twisted `reactor`_ and handling shutdown signals, like thekeyboard interrupt command Ctrl-C. It also configures top-level logging.This utility should be a better fit than:class:`~scrapy.crawler.CrawlerRunner` if you aren't running anotherTwisted `reactor`_ within your application.The CrawlerProcess object must be instantiated with a:class:`~scrapy.settings.Settings` object.:param install_root_handler: whether to install root logging handler (default: True)This class shouldn't be needed (since Scrapy is responsible of using itaccordingly) unless writing scripts that manually handle the crawlingprocess. See :ref:`run-from-script` for an example.\"\"\" 最后，附上Scrapy的路径图 总结简单来说，有这么几步： 读取配置文件，应用到爬虫中 把所有的命令类转换名称与实例字典 初始化CrawlerProcess实例，运行爬虫 (看的头疼，好多函数名记不住) 回顾： Scrapy源码（1）——爬虫流程概览 Scrapy源码（2）——爬虫开始的地方","tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://zhangslob.github.io/tags/爬虫/"},{"name":"Scrapy","slug":"Scrapy","permalink":"https://zhangslob.github.io/tags/Scrapy/"}]},{"title":"Scrapy源码（1）——爬虫流程概览","date":"2018-02-24T13:16:23.000Z","path":"2018/02/24/Scrapy源码（1）——爬虫流程概览/","text":"这是崔斯特的第三十二篇原创文章 开始学习Scrapy源码 (๑• . •๑) 前言使用 Scrapy 已经有一段时间了，觉得自己有必要对源码好好的学习下了，所以写下记录，希望能加深自己的理解。 Scrapy | A Fast and Powerful Scraping and Web Crawling Framework 接下来说到的是最新版本： Scrapy 1.5，暂且把 Spider 称为 蜘蛛，而不是爬虫。 介绍Scrapy是一个开源爬虫框架，用于抓取网站并提取有用的结构化数据，如数据挖掘，信息处理或历史档案。 尽管Scrapy最初是为网页抓取设计的，但它也可以用于使用API（如Amazon Associates Web Services）或作为通用网络抓取工具提取数据。 一个最简单的例子，相信大家都写过 12345678910111213141516171819import scrapyclass QuotesSpider(scrapy.Spider): name = \"quotes\" start_urls = [ 'http://quotes.toscrape.com/tag/humor/', ] def parse(self, response): for quote in response.css('div.quote'): yield &#123; 'text': quote.css('span.text::text').extract_first(), 'author': quote.xpath('span/small/text()').extract_first(), &#125; next_page = response.css('li.next a::attr(\"href\")').extract_first() if next_page is not None: yield response.follow(next_page, self.parse) 一般来说，创建一个Scrapy项目需要如下流程： 使用scrapy startproject spider创建爬虫模板 爬虫类继承scrapy.Spider，重写parse方法和逻辑 parse方法中yield或return字典、Request、Item 自定义Item、Middlewares、Pipelines等 使用scrapy crawl &lt;spider_name&gt;或新建文件cmdline.execute(&quot;scrapy crawl spider_name&quot;.split())运行（便于调试） 其它 架构概述 这是一张非常经典的图，基本上说到Scrapy都会用到它，来源于Architecture overview 核心组件（Components） Scrapy Engine：引擎，负责控制系统所有组件之间的数据流，并在发生某些操作时触发事件； Scheduler：调度器，接收来自引擎的请求，并将它们排入队列，以便在引擎请求它们时将它们提供给它们（也提供给引擎）； Downloader：下载器，负责从网络上获取网页并将它们返回到引擎，然后引擎将它们返回给蜘蛛/spiders； Spiders：蜘蛛，是用户编写的自定义类，用于解析响应并从中提取项目（也称为抓取的项目）或追加其他请求； Item Pipeline：管道，负责输出结构化数据，可自定义输出位置，典型的任务包括清理，验证和持久性； Downloader middlewares：下载中间件，位于引擎和下载器之间的特定钩子/hooks，当它们从引擎传递到下载器时处理请求，以及从下载器传递到引擎的响应，常用于如下情况： 在将请求发送到下载器之前处理请求（即在Scrapy将请求发送到网站之前）; 在将其传递给蜘蛛之前改变接收到的响应; 发送新的请求，而不是将接收到的响应传递给蜘蛛; 向蜘蛛传递响应而不需要获取网页; 默默地放下一些请求。 Spider middlewares：Spider中间件，特定的钩子，位于引擎和蜘蛛之间，能够处理蜘蛛输入（响应）和输出（项目和请求），常用于如下情况： spider回调的后处理输出 更改/添加/删除请求或items; 后处理start_requests; 处理蜘蛛异常; 根据响应内容为一些请求调用errback而不是callback。 Event-driven networking：事件驱动的网络，Scrapy是用Twisted编写的，这是一个流行的事件驱动的Python网络框架。 因此，它使用非阻塞（又称异步）代码来实现并发。 Twisted is an event-driven networking engine written in Python and licensed under the open source ​MIT license. 数据流（Data flow）Scrapy中的数据流由执行引擎控制，如下所示： 引擎获取最初的请求从蜘蛛抓取（start_urls）。 引擎在调度程序中调度请求，并要求下一个请求进行采集。 调度器将下一个请求返回给引擎。 引擎将请求发送到下载器，通过下载器中间件。 一旦页面完成下载，Downloader会生成一个响应（包含该页面）并将其发送到引擎，并通过Downloader Middlewares。 引擎从Downloader收到响应并将其发送给Spider进行处理，并通过Spider Middleware传递。 Spider处理响应，并通过Spider中间件将抓取的项目和新的请求（后续）返回给引擎。 引擎将处理后的项目发送到项目管道，然后将处理后的请求发送到调度程序，并要求可能的下一个请求进行采集。 该过程重复（从第1步开始），直到调度器没有更多请求。 找到一张图，便于理解： 第一期差不多就到这了，没有说很多代码，主要是宏观上来观察 Scrapy 的架构，是如何运行。之后会更多的查看Scrapy的源代码，就近是如何采集数据的。 （内心有点小恐慌，不知道会写成什么样子。） 补充关于如何阅读项目源代码，找到一篇不错的文章，共享：如何阅读开源项目 主要是这几部分： 看：静态对代码进行分析，看相关资料，代码逻辑。 跑：将项目在IDE里面跑起来，通过IDE调试参数，加Log等。 查：阅读过程中肯定会遇到不懂的，这时候需要通过搜索引擎来解决你的疑惑。 回顾： Scrapy源码（1）——爬虫流程概览 Scrapy源码（2）——爬虫开始的地方","tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://zhangslob.github.io/tags/爬虫/"},{"name":"Scrapy","slug":"Scrapy","permalink":"https://zhangslob.github.io/tags/Scrapy/"}]},{"title":"PEP8规则及Pycharm应用","date":"2018-02-08T13:06:23.000Z","path":"2018/02/08/PEP8规则及Pycharm应用/","text":"这是崔斯特的第三十一篇原创文章 学习下 Python增强建议书 (๑• . •๑) PEP8 PEP是 Python Enhancement Proposal 的缩写，翻译过来就是 Python增强建议书 PEP8 是什么呢，简单说就是一种编码规范，是为了让代码“更好看”，更容易被阅读。 具体有这些规范，参考 PEP 8 – Style Guide for Python Code For example 1234567891011121314151617181920Yes: import os import sysNo: import sys, osYes:i = i + 1submitted += 1x = x*2 - 1hypot2 = x*x + y*yc = (a+b) * (a-b)No:i=i+1submitted +=1x = x * 2 - 1hypot2 = x * x + y * yc = (a + b) * (a - b) 对于初学者（例如我）来说，这些标准太多，在实际coding中可能很难记住所有的。之前招聘爬虫工程师，会PEP8也会加分，所以学习下PEP8还是有帮助的。 Pycharm 设置PyCharm 配置 PEP 8 代码提示 直接在右下角调整 Highlighting Level 为 Inspections 就能自动 PEP 8提示 (一般默认就是这个) For example 鼠标移到上方会提示： PEP 8: expected 2 blank lines, found 1，我们再增加一个空格就好了，你的代码中有任何不符合 PEP8 规范的地方都会有“~”提示 这是一个困扰了我很久的问题，我一直不知道是哪里出了错，看英文也不懂，最后去Google才知道，创建字典的写法不规范，应该这样写： item = dict() 其他工具除了Pycharm，还有其他工具可以提示 Google 开源的 Python 文件格式化工具：github.com/google/yapf pyflakes, pylint 等工具及各种编辑器的插件 正文好吧，这里才是正文，正确的规范如下： 缩进 不要使用 tab 缩进 使用任何编辑器写 Python，请把一个 tab 展开为 4 个空格 绝对不要混用 tab 和空格，否则容易出现 IndentationError 空格 在 list, dict, tuple, set, 参数列表的 , 后面加一个空格 在 dict 的 : 后面加一个空格 在注释符号 # 后面加一个空格，但是 #!/usr/bin/python 的 # 后不能有空格 操作符两端加一个空格，如 +, -, *, /, |, &amp;, = 接上一条，在参数列表里的 = 两端不需要空格 括号（(), {}, []）内的两端不需要空格 空行 function 和 class 顶上两个空行 class 的 method 之间一个空行 函数内逻辑无关的段落之间空一行，不要过度使用空行 不要把多个语句写在一行，然后用 ; 隔开 if/for/while 语句中，即使执行语句只有一句，也要另起一行 换行 每一行代码控制在 80 字符以内 使用 \\ 或 () 控制换行，举例：12345678def foo(first, second, third, fourth, fifth, sixth, and_some_other_very_long_param): user = User.objects.filter_by(first=first, second=second, third=third) \\ .skip(100).limit(100) \\ .all()text = ('Long strings can be made up ' 'of several shorter strings.') 命名 使用有意义的，英文单词或词组，绝对不要使用汉语拼音 package/module 名中不要出现 - 各种类型的命名规范： import 所有 import 尽量放在文件开头，在 docstring 下面，其他变量定义的上面 不要使用 from foo imort * import 需要分组，每组之间一个空行，每个分组内的顺序尽量采用字典序，分组顺序是： 标准库 第三方库 本项目的 package 和 module 不要使用隐式的相对导入（implicit relative imports），可是使用显示的相对导入（explicit relative imports），如 from ..utils import parse，最好使用全路径导入（absolute imports） 对于不同的 package，一个 import 单独一行，同一个 package/module 下的内容可以写一起： 12345678910# badimport sys, os, time# goodimport osimport sysimport time# okfrom flask import Flask, render_template, jsonify 为了避免可能出现的命名冲突，可以使用 as 或导入上一级命名空间 不要出现循环导入(cyclic import) 注释 文档字符串 docstring, 是 package, module, class, method, function 级别的注释，可以通过 doc 成员访问到，注释内容在一对 “”” 符号之间 function, method 的文档字符串应当描述其功能、输入参数、返回值，如果有复杂的算法和实现，也需要写清楚 不要写错误的注释，不要无谓的注释 12345# bad 无谓的注释x = x + 1 # increase x by 1# bad 错误的注释x = x - 1 # increase x by 1 优先使用英文写注释，英文不好全部写中文，否则更加看不懂 异常 不要轻易使用 try/except except 后面需要指定捕捉的异常，裸露的 except 会捕捉所有异常，意味着会隐藏潜在的问题 可以有多个 except 语句，捕捉多种异常，分别做异常处理 使用 finally 子句来处理一些收尾操作 try/except 里的内容不要太多，只在可能抛出异常的地方使用，如： 123456789101112131415161718192021222324252627282930# badtry: user = User() user.name = \"leon\" user.age = int(age) # 可能抛出异常 user.created_at = datetime.datetime.utcnow() db.session.add(user) db.session.commit() # 可能抛出异常except: db.session.rollback()# bettertry: age = int(age)except (TypeError, ValueError): return # 或别的操作user = User()user.name = \"leon\"user.age = ageuser.created_at = datetime.datetime.utcnow()db.session.add(user)try: db.session.commit()except sqlalchemy.exc.SQLAlchemyError: # 或者更具体的异常 db.session.rollback()finally: db.session.close() 从 Exception 而不是 BaseException 继承自定义的异常类 Class（类） 显示的写明父类，如果不是继承自别的类，就继承自 object 类 使用 super 调用父类的方法 支持多继承，即同时有多个父类，建议使用 Mixin 编码建议 字符串 使用字符串的 join 方法拼接字符串 使用字符串类型的方法，而不是 string 模块的方法 使用 startswith 和 endswith 方法比较前缀和后缀 使用 format 方法格式化字符串 比较 空的 list, str, tuple, set, dict 和 0, 0.0, None 都是 False 使用 if some_list 而不是 if len(some_list) 判断某个 list 是否为空，其他类型同理 使用 is 和 is not 与单例（如 None）进行比较，而不是用 == 和 != 使用 if a is not None 而不是 if not a is None 用 isinstance 而不是 type 判断类型 不要用 == 和 != 与 True 和 False 比较（除非有特殊情况，如在 sqlalchemy 中可能用到） 使用 in 操作： 用 key in dict 而不是 dict.has_key() 1234567# badif d.has_key(k): do_something()# goodif k in d: do_something() 2.用 set 加速 “存在性” 检查，list 的查找是线性的，复杂度 O(n)，set 底层是 hash table, 复杂度 O(1)，但用 set 需要比 list 更多内存空间 其他 使用列表表达式（list comprehension），字典表达式(dict comprehension, Python 2.7+) 和生成器(generator) dict 的 get 方法可以指定默认值，但有些时候应该用 [] 操作，使得可以抛出 KeyError 使用 for item in list 迭代 list, for index, item in enumerate(list) 迭代 list 并获取下标 使用内建函数 sorted 和 list.sort 进行排序 适量使用 map, reduce, filter 和 lambda，使用内建的 all, any 处理多个条件的判断 使用 defaultdict (Python 2.5+), Counter(Python 2.7+) 等 “冷门” 但好用的标准库算法和数据结构 使用装饰器(decorator) 使用 with 语句处理上下文 有些时候不要对类型做太过严格的限制，利用 Python 的鸭子类型（Duck Type）特性 使用 logging 记录日志，配置好格式和级别 了解 Python 的 Magic Method：A Guide to Python’s Magic Methods, Python 魔术方法指南 阅读优秀的开源代码，如 Flask 框架, Requests for Humans 不要重复造轮子，查看标准库、PyPi、Github、Google 等使用现有的优秀的解决方案 反思写程序的好习惯在于理解、坚持，然后就是运用自如！","tags":[{"name":"PEP8","slug":"PEP8","permalink":"https://zhangslob.github.io/tags/PEP8/"},{"name":"Pycharm","slug":"Pycharm","permalink":"https://zhangslob.github.io/tags/Pycharm/"}]},{"title":"学点算法之栈的学习与应用","date":"2018-02-05T14:08:13.000Z","path":"2018/02/05/学点算法之栈的学习与应用/","text":"这是崔斯特的第三十篇原创文章 在学习栈前，脑海中对这个词只有一个印象：客栈 (๑• . •๑) 栈是什么栈（有时称为“后进先出栈”）是一个项的有序集合，其中添加移除新项总发生在同一端。 这段话初学者是懵逼的，别急，往下看。 对栈的一般操作： Stack() 创建一个空的新栈。 它不需要参数，并返回一个空栈。 push(item)将一个新项添加到栈的顶部。它需要 item 做参数并不返回任何内容。 pop() 从栈中删除顶部项。它不需要参数并返回 item 。栈被修改。 peek() 从栈返回顶部项，但不会删除它。不需要参数。 不修改栈。 isEmpty() 测试栈是否为空。不需要参数，并返回布尔值。 size() 返回栈中的 item 数量。不需要参数，并返回一个整数。 例如，s 是已经创建的空栈，下图展示了栈操作序列的结果。栈中，顶部项列在最右边。 自己在心里过一遍就很好理解了 Python实现栈其实看到上面那张图，就想起了Python中 list 的一些用法，append、pop等，下面是使用 Python 来实现栈，也非常简单： 123456789101112131415161718class Stack: def __init__(self): self.items = [] def isEmpty(self): return self.items == [] def push(self, item): self.items.append(item) def pop(self): return self.items.pop() def peek(self): return self.items[len(self.items)-1] def size(self): return len(self.items) pythonds/basic/stack.py 栈的应用：简单括号匹配（一）有一些正确匹配的括号字符串： 12345(()()()())(((())))(()((())())) 对比那些不匹配的括号：12345((((((())()))(()()(() 具有挑战的是如何编写一个算法，能够从左到右读取一串符号，并决定符号是否平衡。 为了解决这个问题，我们需要做一个重要的观察。从左到右处理符号时，最近开始符号必须与下一个关闭符号相匹配。此外，处理的第一个开始符号必须等待直到其匹配最后一个符号。结束符号以相反的顺序匹配开始符号。他们从内到外匹配。这是一个可以用栈解决问题的线索。 12345678910111213141516171819202122232425from pythonds.basic.stack import Stackdef parChecker(symbolString): s = Stack() balanced = True index = 0 while index &lt; len(symbolString) and balanced: symbol = symbolString[index] if symbol == \"(\": s.push(symbol) else: if s.isEmpty(): balanced = False else: s.pop() index = index + 1 if balanced and s.isEmpty(): return True else: return Falseprint(parChecker('((()))'))print(parChecker('(()')) output12TrueFalse 一旦你认为栈是保存括号的恰当的数据结构，算法是很直接的。 从空栈开始，从左到右处理括号字符串。如果一个符号是一个开始符号，将其作为一个信号，对应的结束符号稍后会出现。另一方面，如果符号是结束符号，弹出栈，只要弹出栈的开始符号可以匹配每个结束符号，则括号保持匹配状态。如果任何时候栈上没有出现符合开始符号的结束符号，则字符串不匹配。最后，当所有符号都被处理后，栈应该是空的。 如果有和我一样不能很好理解的，使用pycharm的debug模式，可以一步步来，看看程序就近在做什么。 括号配对问题（二）来看看第二种匹配问题。Python程序里存在很多括号：如圆括号、方括号和花括号，每种括号都有开括号和闭括号。 123456789101112131415161718192021222324252627282930from pythonds.basic.stack import Stackpares = \"()[]&#123;&#125;\"def pare_theses(text): i, text_len = 0, len(text) while True: while i &lt; text_len and text[i] not in pares: i += 1 if i &gt;= text_len: return yield text[i], i i += 1def check_pares(text): open_pares = \"([&#123;\" opposite = &#123;')': '(', ']': '[', '&#125;': '&#123;'&#125; # 表示配对关系的字典 s = Stack() for pr, i in pare_theses(text): if pr in open_pares: # 开括号，压进栈并继续 s.push(pr) elif s.pop() != opposite[pr]: # 不匹配就是失败，退出 print('Unmatching is found at', i, 'for', pr) return False # else 是一次括号配对成功，什么也不做，继续 print(\"All paretheses are correctly matched.\") return Truecheck_pares('([]&#123;&#125;]')check_pares('([]&#123;&#125;)') output 12Unmatching is found at 5 for ]All paretheses are correctly matched. 生成器（回忆一下）： 用 yield 语句产生结果 可以用在需要迭代器的地方 函数结束导致迭代结束 参考 http://interactivepython.org/runestone/static/pythonds/BasicDS/TheStackAbstractDataType.html http://www.math.pku.edu.cn/teachers/qiuzy/ds_python/courseware/index.htm","tags":[{"name":"算法","slug":"算法","permalink":"https://zhangslob.github.io/tags/算法/"},{"name":"栈","slug":"栈","permalink":"https://zhangslob.github.io/tags/栈/"}]},{"title":"为什么不推荐Selenium写爬虫","date":"2018-02-02T12:35:02.000Z","path":"2018/02/02/为什么不推荐Selenium写爬虫/","text":"这是崔斯特的第二十九篇原创文章 如果可以使用 Requests 完成的，别用 Selenium (๑• . •๑) 最近在群里经常会看到有些朋友说，使用Selenium去采集网站，我看到其实内心是很难受的，哎！为什么要用Selenium呢？ 我想说下自己的看法，欢迎各位大佬批评。 观点如果可以使用 Requests 完成的，别用 Selenium 数据采集的顺序接到一个项目或者有一个采集需求时，第一步就是明确自己的需求。经常会遇到半路改需求的事情，真的很难受。 第二步就是去分析这个网站，这个在之前有提到过 采集方案策略之App抓包 : 首先大的地方，我们想抓取某个数据源，我们要知道大概有哪些路径可以获取到数据源，基本上无外乎三种：PC端网站针对移动设备响应式设计的网站（也就是很多人说的H5, 虽然不一定是H5）；移动App原则是能抓移动App的，最好抓移动App，如果有针对移动设备优化的网站，就抓针对移动设备优化的网站，最后考虑PC网站。因为移动App基本都是API很简单，而移动设备访问优化的网站一般来讲都是结构简单清晰的HTML，而PC网站自然是最复杂的了；针对PC端网站和移动网站的做法一样，分析思路可以一起讲，移动App单独分析。 这个时候可以借用 postman 来分析请求，参考 或许你应该学学 postman 然后下一步可能就是工程开始，各种配置，以及选择哪种采集方式，一般来说 Scrapy 是最好用、也是最常见的框架。当然你也可以使用 requests + xpath 或者 Selenium 。下面就我自己的看法来说说这三种采集方式。 三种采集差异Scrapy在 Scrapy 官网 上是这样写的： Scrapy | A Fast and Powerful Scraping and Web Crawling Framework 关键词是 Fast 和 Powerful，使用过确实感觉如此。我感觉 Scrapy 就是一个全家桶，它把爬虫所需要的大部分东西（为什么不是全部，下面会说到）都集成到这个框架中，如：下载器、中间件、调度器、Spider、调试、数据流等等所有功能全部都在这一个框架中，你所需要做的只是在命令行中输入：scrapy startproject yourproject Scrapy 的缺点也是显而易见的：不支持分布式。scrapy中scheduler是运行在队列中的，而队列是在单机内存中的，服务器上爬虫是无法利用内存的队列做任何处理。但是也有解决办法，参见rmax/scrapy-redis Requests来看看 Requests的文档 Requests 唯一的一个非转基因的 Python HTTP 库，人类可以安全享用。 警告：非专业使用其他 HTTP 库会导致危险的副作用，包括：安全缺陷症、冗余代码症、重新发明轮子症、啃文档症、抑郁、头疼、甚至死亡。 作者真幽默 urllib2 VS requests 12345678910111213141516171819202122232425#!/usr/bin/env python# -*- coding: utf-8 -*-import urllib2gh_url = 'https://api.github.com'req = urllib2.Request(gh_url)password_manager = urllib2.HTTPPasswordMgrWithDefaultRealm()password_manager.add_password(None, gh_url, 'user', 'pass')auth_manager = urllib2.HTTPBasicAuthHandler(password_manager)opener = urllib2.build_opener(auth_manager)urllib2.install_opener(opener)handler = urllib2.urlopen(req)print handler.getcode()print handler.headers.getheader('content-type')# ------# 200# 'application/json' 12345678910111213#!/usr/bin/env python# -*- coding: utf-8 -*-import requestsr = requests.get('https://api.github.com', auth=('user', 'pass'))print r.status_codeprint r.headers['content-type']# ------# 200# 'application/json' 简单对比发现 requests 的好用之处了，刚开始学习爬虫的时候也是从 urllib 开始，当看到 requests 果断抛弃，就像看到 xpath 抛弃 bs4 一样 所以如果你是初学者，那么请毫不犹豫的选择 requests Selenium最后来到今天的主角 Selenium， 首先看看官方怎么说 What is Selenium?Selenium automates browsers. That’s it! What you do with that power is entirely up to you. Primarily, it is for automating web applications for testing purposes, but is certainly not limited to just that. Boring web-based administration tasks can (and should!) be automated as well. Selenium has the support of some of the largest browser vendors who have taken (or are taking) steps to make Selenium a native part of their browser. It is also the core technology in countless other browser automation tools, APIs and frameworks. 重点是：it is for automating web applications for testing purposes, but is certainly not limited to just that，翻译过来就是：它是用于自动化Web应用程序的测试目的，但肯定不仅限于此，简单来说，Selenium 是web自动化测试工具集，如果你去Google上搜索 Selenium ，大多结果都是 利用Selenium 自动化web 测试相关内容，比较出名的有博客园的虫师，写的两本书也都是关于自动化测试方面的 至于为啥爬虫要用selenium，我在某些博客上找到有人这样说，我也不知道怎么说 对于一般网站来说scrapy、requests、beautifulsoup等都可以爬取，但是有些信息需要执行js才能显现，而且你肉眼所能看到的基本都能爬取下来，在学习中遇到了，就记录下来方便以后查看。 webdrive是selenium中一个函数： from selenium import webdriverdriver = webdriver.Chrome()driver.get(‘网址’) 其中PhantomJS同时可以换成Chrome、Firefox、Ie等等，但是PhantomJS是一个无头的浏览器，运行是不会跳出相应的浏览器，运行相对效率较高。在调试中可以先换成Chrome，方便调试，最后再换成PhantomJS即可。 下面是吐槽时间，说一说 Selenium 的缺点： 速度慢。每次运行爬虫都打开一个浏览器，如果没有设置，还会加载图片、JS等等一大堆东西； 占用资源太多。有人说，把Chrome换成无头浏览器PhantomJS，原理都是一样的，都是打开浏览器，而且很多网站会验证参数，如果对方看到你是以PhantomJS去访问，会BAN掉你的请求，然后你又要考虑更换请求头的事情，事情复杂程度不知道多了多少，为啥学Python？因为Python简单啊，如果有更快、更简单的库可以实现同样的功能，为什么不去使用呢？ 对网络的要求会更高。 Selenium 加载了很多可能对您没有价值的补充文件（如css，js和图像文件）。 与仅仅请求您真正需要的资源（使用单独的HTTP请求）相比，这可能会产生更多的流量。 爬取规模不能太大。你有看到哪家公司用Selenium作为生产环境吗？ 难。学习Selenium的成本太高，只有我一个人觉得Selenium比Requests难一百倍吗？ 我能想到的就这么多了，欢迎各位大佬补充。所以，如果可以使用 Requests 完成的，别用 Selenium，OK，洗脑完成。 之前面试爬虫工程师有一题就是：如何处理网站的登录系统？ A.浏览器模拟 B.HTTP请求 如果你想做测试工程师，那肯定需要学会 Selenium，公司一个妹子就是测试，现在学了 Selenium，工作轻松了好多。 最后，无耻的来个广告，本公司招聘爬虫工程师，希望和你成为队友!","tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://zhangslob.github.io/tags/爬虫/"},{"name":"Selenium","slug":"Selenium","permalink":"https://zhangslob.github.io/tags/Selenium/"}]},{"title":"或许你应该学学 postman","date":"2018-01-31T14:59:36.000Z","path":"2018/01/31/或许你应该学学-postman/","text":"这是崔斯特的第二十八篇原创文章 简单模拟请求的工具 (๑• . •๑) 使用最简单的方法就是直接在浏览器中复制 Copy as cURL ，然后把数据导入 postman，然后 send ，收工。 我们这里拿 知乎首页 举例 在对应的请求下复制 cURL 打开 postman ， 点击左上角的 Import ， 选择Paste Raw Text ，最后 Import，点击 send发送请求 发送请求之后就可以查看了，如下图，标箭头的地方可以打开看更多。比如可以预览web界面，查看 Headers 信息，查看状态，复制代码。 同时可以打开 Headers ，用来调试，哪些是需要的，哪些不需要 最方便的一点是，可以直接生成对应的编程语言，并复制，例如Python的requests方法： 好了，到这里 postman 的简单功能就说完了，他的全部功能当然不止这一点，更多的就去看 文档啦 问题在我的使用过程中，发现了 postman 的一些问题，如：导入错误，参数错误，请求失误。 导入错误例如知乎这个例子，如果我们复制的是 Copy as cURL (cmd) ，可能你会遇到下面的错误 这个时候选用 Copy as cURL (bush) 就好了，具体原因是啥，我也不清楚。我在这里找到了别人的描述 There is no difference between the two cURL command because there is a difference between ” and ‘. Refer : Use cURL to get the same results as a web browser 参数错误举个例子，今天在帮朋友查看 这个网站 的翻页，复制用postman打开， copy cURL 内容是 1234567891011121314151617curl \"https://www.crunchbase.com/v4/data/entities/organizations/56e40f50-97c7-2a77-255d-1d97d5f30646/overrides?field_ids=^%^5B^%^22identifier^%^22,^%^22layout_id^%^22,^%^22facet_ids^%^22,^%^22title^%^22,^%^22short_description^%^22,^%^22is_locked^%^22^%^5D^&amp;card_ids=^%^5B^%^22investments_list^%^22^%^5D\" -H \"cookie: _ga=GA1.2.35962729.1517412509; _gid=GA1.2.2072770006.1517412509; _vdl=1; _hp2_ses_props.973801186=^%^7B^%^22ts^%^22^%^3A1517412512548^%^2C^%^22d^%^22^%^3A^%^22www.crunchbase.com^%^22^%^2C^%^22h^%^22^%^3A^%^22^%^2Fsearch^%^2Fprincipal.investors^%^22^%^7D; __qca=P0-1969245879-1517412512628; D_IID=1B7344D2-1C8F-3327-8607-D786306444AE; D_UID=208F925B-3D1C-3491-A532-C82375EE187D; D_ZID=497DB63C-5101-3F49-BE35-1752A80F8DDA; D_ZUID=D89FCBAA-BF79-340C-BF55-B860768D0993; D_HID=57B19D5F-5069-3A82-94CB-D42821D1CD10; D_SID=123.120.141.63:bXaeU41PWi5vyYIflFmiShQiK1qwq/nC4G9IljWo+6A; AMCVS_6B25357E519160E40A490D44^%^40AdobeOrg=1; wcsid=KZbgLoopx4WnyMOW3F6pZ0H92JEzMrBd; hblid=cfw6lOKzm4FpCUou3F6pZ0H92JE6rBWB; s_cc=true; AMCV_6B25357E519160E40A490D44^%^40AdobeOrg=1099438348^%^7CMCMID^%^7C05859477990281579603868663655860142263^%^7CMCAAMLH-1518017313^%^7C11^%^7CMCAAMB-1518017313^%^7CRKhpRz8krg2tLO6pguXWp5olkAcUniQYPHaMWWgdJ3xzPWQmdj0y^%^7CMCOPTOUT-1517419713s^%^7CNONE^%^7CMCAID^%^7CNONE^%^7CMCSYNCSOP^%^7C411-17570^%^7CvVersion^%^7C2.1.0; _okdetect=^%^7B^%^22token^%^22^%^3A^%^2215174125149410^%^22^%^2C^%^22proto^%^22^%^3A^%^22https^%^3A^%^22^%^2C^%^22host^%^22^%^3A^%^22www.crunchbase.com^%^22^%^7D; olfsk=olfsk8562990481377502; _okbk=cd4^%^3Dtrue^%^2Cvi5^%^3D0^%^2Cvi4^%^3D1517412515909^%^2Cvi3^%^3Dactive^%^2Cvi2^%^3Dfalse^%^2Cvi1^%^3Dfalse^%^2Ccd8^%^3Dchat^%^2Ccd6^%^3D0^%^2Ccd5^%^3Daway^%^2Ccd3^%^3Dfalse^%^2Ccd2^%^3D0^%^2Ccd1^%^3D0^%^2C; _ok=1554-355-10-6773; _hp2_props.973801186=^%^7B^%^22Logged^%^20In^%^22^%^3Afalse^%^2C^%^22Pro^%^22^%^3Afalse^%^7D; _hp2_id.973801186=^%^7B^%^22userId^%^22^%^3A^%^228805156096536097^%^22^%^2C^%^22pageviewId^%^22^%^3A^%^221700148784936413^%^22^%^2C^%^22sessionId^%^22^%^3A^%^225929107734453151^%^22^%^2C^%^22identity^%^22^%^3Anull^%^2C^%^22trackerVersion^%^22^%^3A^%^223.0^%^22^%^7D; _oklv=1517412548852^%^2CKZbgLoopx4WnyMOW3F6pZ0H92JEzMrBd; s_pers=^%^20s_nrgvo^%^3DNew^%^7C1580484574965^%^3B\" -H \"origin: https://www.crunchbase.com\" -H \"accept-encoding: gzip, deflate, br\" -H \"x-distil-ajax: dfdvfavtsysazfberrtudvwabwe\" -H \"user-agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36\" -H \"content-type: application/json\" -H \"accept-language: zh-CN,zh;q=0.9,en;q=0.8\" -H \"accept: application/json, text/plain, */*\" -H \"referer: https://www.crunchbase.com/organization/500-startups/investments/investments_list\" -H \"authority: www.crunchbase.com\" -H \"x-requested-with: XMLHttpRequest\" --data-binary ^\"^&#123;^ ^\\^\"card_lookups^\\^\": ^[^ ^&#123;^ ^\\^\"card_id^\\^\": ^\\^\"investments_list^\\^\",^ ^\\^\"limit^\\^\": 100,^ ^\\^\"after_id^\\^\": ^\\^\"07a9c686-4590-fa0f-3ac4-fc7b898c0b7a^\\^\"^ ^&#125;^ ^]^^&#125;^\" --compressed 导入之后，send，返回 400 错误。 postman 转义的code是： 1234567891011121314151617181920212223242526import requestsurl = \"https://www.crunchbase.com/v4/data/entities/organizations/56e40f50-97c7-2a77-255d-1d97d5f30646/overrides\"querystring = &#123;\"field_ids\":\"^%^5B^%^22identifier^%^22,^%^22layout_id^%^22,^%^22facet_ids^%^22,^%^22title^%^22,^%^22short_description^%^22,^%^22is_locked^%^22^%^5D^\",\"card_ids\":\"^%^5B^%^22investments_list^%^22^%^5D\"&#125;payload = \"^^&#123;^\\n\\n ^\\\\^card_lookups^^: ^[^\\n\\n ^&#123;^\\n\\n ^\\\\^card_id^^: ^\\\\^investments_list^^,^\\n\\n ^\\\\^limit^^: 100,^\\n\\n ^\\\\^after_id^^: ^\\\\^07a9c686-4590-fa0f-3ac4-fc7b898c0b7a^^^\\n\\n ^&#125;^\\n\\n ^]^\\n\\n^&#125;^\"headers = &#123; 'cookie': \"_ga=GA1.2.35962729.1517412509; _gid=GA1.2.2072770006.1517412509; _vdl=1; _hp2_ses_props.973801186=^%^7B^%^22ts^%^22^%^3A1517412512548^%^2C^%^22d^%^22^%^3A^%^22www.crunchbase.com^%^22^%^2C^%^22h^%^22^%^3A^%^22^%^2Fsearch^%^2Fprincipal.investors^%^22^%^7D; __qca=P0-1969245879-1517412512628; D_IID=1B7344D2-1C8F-3327-8607-D786306444AE; D_UID=208F925B-3D1C-3491-A532-C82375EE187D; D_ZID=497DB63C-5101-3F49-BE35-1752A80F8DDA; D_ZUID=D89FCBAA-BF79-340C-BF55-B860768D0993; D_HID=57B19D5F-5069-3A82-94CB-D42821D1CD10; D_SID=123.120.141.63:bXaeU41PWi5vyYIflFmiShQiK1qwq/nC4G9IljWo+6A; AMCVS_6B25357E519160E40A490D44^%^40AdobeOrg=1; wcsid=KZbgLoopx4WnyMOW3F6pZ0H92JEzMrBd; hblid=cfw6lOKzm4FpCUou3F6pZ0H92JE6rBWB; s_cc=true; AMCV_6B25357E519160E40A490D44^%^40AdobeOrg=1099438348^%^7CMCMID^%^7C05859477990281579603868663655860142263^%^7CMCAAMLH-1518017313^%^7C11^%^7CMCAAMB-1518017313^%^7CRKhpRz8krg2tLO6pguXWp5olkAcUniQYPHaMWWgdJ3xzPWQmdj0y^%^7CMCOPTOUT-1517419713s^%^7CNONE^%^7CMCAID^%^7CNONE^%^7CMCSYNCSOP^%^7C411-17570^%^7CvVersion^%^7C2.1.0; _okdetect=^%^7B^%^22token^%^22^%^3A^%^2215174125149410^%^22^%^2C^%^22proto^%^22^%^3A^%^22https^%^3A^%^22^%^2C^%^22host^%^22^%^3A^%^22www.crunchbase.com^%^22^%^7D; olfsk=olfsk8562990481377502; _okbk=cd4^%^3Dtrue^%^2Cvi5^%^3D0^%^2Cvi4^%^3D1517412515909^%^2Cvi3^%^3Dactive^%^2Cvi2^%^3Dfalse^%^2Cvi1^%^3Dfalse^%^2Ccd8^%^3Dchat^%^2Ccd6^%^3D0^%^2Ccd5^%^3Daway^%^2Ccd3^%^3Dfalse^%^2Ccd2^%^3D0^%^2Ccd1^%^3D0^%^2C; _ok=1554-355-10-6773; _hp2_props.973801186=^%^7B^%^22Logged^%^20In^%^22^%^3Afalse^%^2C^%^22Pro^%^22^%^3Afalse^%^7D; _hp2_id.973801186=^%^7B^%^22userId^%^22^%^3A^%^228805156096536097^%^22^%^2C^%^22pageviewId^%^22^%^3A^%^221700148784936413^%^22^%^2C^%^22sessionId^%^22^%^3A^%^225929107734453151^%^22^%^2C^%^22identity^%^22^%^3Anull^%^2C^%^22trackerVersion^%^22^%^3A^%^223.0^%^22^%^7D; _oklv=1517412548852^%^2CKZbgLoopx4WnyMOW3F6pZ0H92JEzMrBd; s_pers=^%^20s_nrgvo^%^3DNew^%^7C1580484574965^%^3B\", 'origin': \"https://www.crunchbase.com\", 'accept-encoding': \"gzip, deflate, br\", 'x-distil-ajax': \"dfdvfavtsysazfberrtudvwabwe\", 'user-agent': \"Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/63.0.3239.84 Safari/537.36\", 'content-type': \"application/json\", 'accept-language': \"zh-CN,zh;q=0.9,en;q=0.8\", 'accept': \"application/json, text/plain, */*\", 'referer': \"https://www.crunchbase.com/organization/500-startups/investments/investments_list\", 'authority': \"www.crunchbase.com\", 'x-requested-with': \"XMLHttpRequest\", 'cache-control': \"no-cache\", 'postman-token': \"1df3b2b6-b682-edf7-4804-572ac5a03420\" &#125;response = requests.request(\"POST\", url, data=payload, headers=headers, params=querystring)print(response.text) 可以看到 加入了大量的 ^ 符号，这个在Python中是运算符1^ 按位异或运算符：当两对应的二进位相异时，结果为1 (a ^ b) 输出结果 49 ，二进制解释： 0011 0001 这也是 postman 的一个问题 请求失误这个问题，我也不是很懂，有的请求 postman 返回错误，但是复制代码到 Python 环境中运行是可以获得数据的，所以最好是多次验证。","tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://zhangslob.github.io/tags/爬虫/"},{"name":"postman","slug":"postman","permalink":"https://zhangslob.github.io/tags/postman/"}]},{"title":"有了她，谁敢阻止我学习","date":"2018-01-30T13:31:40.000Z","path":"2018/01/30/有了她，谁敢阻止我学习/","text":"这是崔斯特的第二十七篇原创文章 我爱学习 (๑• . •๑) 公众号Python爱好者社区，微信号：python_shequ 人生苦短，我用Python。分享Python相关的技术文章、工具资源、精选课程、视频教程、热点资讯、学习资料等。每天自动更新和推送。 Python爬虫分享，微信号：python_shequ 知乎专栏“爬虫从入门到放弃”作者。目前在知乎连载爬虫从入门到放弃到精通系列文章 张俊红，微信号：zhangjunhong0428 中国统计网专栏作者，数据分析路上的学习者与实践者，与你分享我的所见、所学、所想。 数据小魔方，微信号：datamofang 专注于数据可视化及商务智能的原创技能分享平台！ Python爬虫与算法进阶，微信号：zhangslob 分享Python知识，关注爬虫与算法,让我们一起从萌新变成大牛吧! 在线书籍 关于Python的面试题 草根学Python python数据结构和算法 Python最佳实践指南！ Python Cookbook 3rd Edition Documentation Stackoverflow about Python Python进阶 免费视频 零基础入门学习Python 话说我当时就看的小甲鱼视频入门的 Python语言程序设计 嵩天老师的一系列课程 Google机器学习 简单入门 算法基础 北大博士的课程。。 吴恩达机器学习 这个就不评价了，都知道 爬虫教程 爬虫教程 某位大佬所写，由浅入深 Scrapy分类 质量非常高 Python3网络爬虫实战 崔大的书，马上会出版 大数据之网络爬虫 主要是垂直型网络爬虫 使用Scrapy-redis实现分布式爬取 分布式资料 使用Docker部署scrapy-redis分布式爬虫 同样是分布式资料 最重要的一点是：不要光收藏，不去看","tags":[{"name":"Git","slug":"Git","permalink":"https://zhangslob.github.io/tags/Git/"}]},{"title":"烦人的Git ( ´•︵•` )","date":"2018-01-29T13:30:41.000Z","path":"2018/01/29/烦人的Git 终于学会了 -´•︵•/","text":"这是崔斯特的第二十六篇原创文章 终于会用Git了 (๑• . •๑) Git对于新手来说，真的很烦人哎，好在找到了好工具 —— PyCharm 使用PyCharm进行代码管理在VCS里有Git，里面有常用的操作，clone、pull、push等等。 更方便的是，在左下角，有Version Control，可以清晰的看到日志改变，图中另一个标记的位置可以直接进行commit，如下图所示 更多参考官方文档 Enabling Version Control 我修改了主题，可以在这里改 Material Theme UI emmm，简单的方法就是这样，还是需要了解下Git的基本操作的 创建新仓库创建新文件夹，打开，然后执行 git init 以创建新的 git 仓库。 或者按照官方推荐的例子 123456789git clone git@github.com:zhangslob/test_test.gitecho \"# test_test\" &gt;&gt; README.mdgit initgit add README.mdgit commit -m \"first commit\"git remote add origin git@github.com:zhangslob/test_test.gitgit push -u origin master# 其中的命令下面会讲到 克隆仓库执行如下命令以创建一个本地仓库的克隆版本： git clone /path/to/repository 如果是远端服务器上的仓库，你的命令会是这个样子： git clone username@host:/path/to/repository 添加和提交你可以提出更改（把它们添加到暂存区），使用如下命令： git add . 这是 git 基本工作流程的第一步；使用如下命令以实际提交改动： git commit -m &quot;代码提交信息&quot; 现在，你的改动已经提交到了 HEAD，但是还没到你的远端仓库。 推送改动你的改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库： git push origin master 可以把 master 换成你想要推送的任何分支。 分支分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。 创建一个叫做“develop”的分支，并切换过去： git checkout -b develop 切换回主分支： git checkout master 再把新建的分支删掉： git branch -d develop 除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的： git push origin &lt;branch&gt; 更新与合并要更新你的本地仓库至最新改动，执行： git pull 以在你的工作目录中 获取（fetch） 并 合并（merge） 远端的改动。 要合并其他分支到你的当前分支（例如 master），执行： git merge &lt;branch&gt; 在这两种情况下，git 都会尝试去自动合并改动。遗憾的是，这可能并非每次都成功，并可能出现冲突（conflicts）。 这时候就需要你修改这些文件来手动合并这些冲突（conflicts）。改完之后，你需要执行如下命令以将它们标记为合并成功： git add &lt;filename&gt; 在合并改动之前，你可以使用如下命令预览差异： git diff &lt;source_branch&gt; &lt;target_branch&gt; 替换本地改动假如你操作失误，你可以使用如下命令替换掉本地改动： git checkout -- &lt;filename&gt; 此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到暂存区的改动以及新文件都不会受到影响。 假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：12git fetch origingit reset --hard origin/master 小技巧 使用 git status 可以迅速查看当前状态，若添加文件，会显示绿色的文字 使用Github的客户端，可以事半功倍 https://desktop.github.com/ 更多可以参考 Git 文档 Git Commit Message 模版模版命名约定模版名称由以下部分组成 gitmessage-${语言}[-full] 以 -full 结尾的模版包含了 message 组成区域的解释以及书写的指导，推荐新手选择该模版上手，在熟悉书写规范后换成简单版本。 1234567# feat (新功能)# fix (问题修复)# refactor (代码重构)# style (代码风格改动、格式变化等，无实现改动)# docs (文档更新)# test (增加、重构测试，无实现改动)# chore (修改一些配置文件如 .gitignore 等，无实现改动)","tags":[{"name":"Git","slug":"Git","permalink":"https://zhangslob.github.io/tags/Git/"}]},{"title":"学点算法之字符串的乱序检查","date":"2018-01-27T10:52:56.000Z","path":"2018/01/27/学点算法之字符串的乱序检查/","text":"这是崔斯特的第二十五篇原创文章 老板，我要做算法工程师！ 问题字符串的乱序检查。 一个字符串是另一个字符串的乱序。如果第二个字符串只是第一个的重新排列，例如，’heart’ 和 ‘earth’ 就是乱序字符串。’python’ 和 ‘typhon’ 也是。为了简单起见，我们假设所讨论的两个字符串具有相等的长度，并且他们由 26 个小写字母集合组成。我们的目标是写一个布尔函数，它将两个字符串做参数并返回它们是不是回文。 解法1:检查我们对乱序问题的第一个解法是检查第一个字符串是不是出现在第二个字符串中。如果可以检验到每一个字符，那两个字符串一定是回文。可以通过用 None 替换字符来完成检查。但是，由于 Python 字符串是不可变的，所以第一步是将第二个字符串转换为列表。第一个字符串中的每个字符可以通过检查在第二个列表中检查元素是否存在，如果存在，替换成 None。 12345678910111213141516171819202122232425def anagramSolution1(s1,s2): alist = list(s2) pos1 = 0 stillOK = True while pos1 &lt; len(s1) and stillOK: pos2 = 0 found = False while pos2 &lt; len(alist) and not found: if s1[pos1] == alist[pos2]: found = True else: pos2 = pos2 + 1 if found: alist[pos2] = None else: stillOK = False pos1 = pos1 + 1 return stillOKprint(anagramSolution1('abcd','dcba')) s1 的每个字符都会在 s2 中进行最多 n 个字符的迭代 s2 列表中的 n 个位置将被访问一次来匹配来自 s1 的字符。访问次数可以写成 1 到 n 整数的和，可以写成 当 n 变大，n^2 这项占据主导，1/2 可以忽略。所以这个算法复杂度为 O(n^2 )。 解法2:排序和比较另一个解决方案是利用这么一个事实，即使 s1,s2 不同，它们只有由完全相同的字符组成，它们才是回文。所以，如果我们按照字母顺序排列每个字符串，从 a 到 z，如果两个字符串相同，则这两个字符串为回文。 12345678910111213def anagramSolution2(s1,s2): alist1 = list(s1) alist2 = list(s2) alist1.sort() alist2.sort() if alist1 == alist2: return True else: return Falseprint(anagramSolution2('abcde','edcba')) 这个算法比较简单，只用到了排序算法，那么排序算法的复杂度还是多少呢？ 在这里找到了答案 python中的sorted算法，网上有人撰文，说比较低级。其实不然，通过阅读官方文档，发现python中的sorted排序，真的是高大上，用的Timsort算法。什么是Timsort，请看 wiki的解释：http://en.wikipedia.org/wiki/Timsort 另外，国内有一个文档，适当翻译：http://blog.csdn.net/yangzhongblog/article/details/8184707，这里截取一个不同排序算法比较的图示，就明白sorted的威力了。 从时间复杂度来看，Timsort是威武的。 从空间复杂度来讲，需要的开销在数量大的时候会增大。 解法3: 穷举法解决这类问题的强力方法是穷举所有可能性。 对于回文检测，我们可以生成 s1 的所有乱序字符串列表，然后查看是不是有 s2。这种方法有一点困难。当 s1 生成所有可能的字符串时，第一个位置有 n 种可能，第二个位置有 n-1 种，第三个位置有 n-3 种，等等。总数为 n∗(n−1)∗(n−2)∗...∗3∗2∗1n∗(n−1)∗(n−2)∗...∗3∗2∗1， 即 n! 。 虽然一些字符串可能是重复的，程序也不可能提前知道这样，所以他仍然会生成 n! 个字符串。事实证明，n! 比 n^2 增长还快，事实上，如果 s1 有 20个字符长，则将有 20! = 2,432,902,008,176,640,000 个字符串产生。如果我们每秒处理一种可能字符串，那么需要 77,146,816,596 年才能过完整个列表。 所以当然不会采取这种方案了。 解法4: 计数和比较我们最终解决回文的方法是利用两个乱序字符串具有相同的 a, b, c 等等的事实。 我们首先计算的是每个字母出现的次数。由于有 26 个可能的字符，我们就用 一个长度为 26 的列表，每个可能的字符占一个位置。每次看到一个特定的字符，就增加该位置的计数器。最后如果两个列表的计数器一样，则字符串为乱序字符串。 1234567891011121314151617181920212223def anagramSolution4(s1,s2): c1 = [0]*26 c2 = [0]*26 for i in range(len(s1)): pos = ord(s1[i])-ord('a') c1[pos] = c1[pos] + 1 for i in range(len(s2)): pos = ord(s2[i])-ord('a') c2[pos] = c2[pos] + 1 j = 0 stillOK = True while j&lt;26 and stillOK: if c1[j]==c2[j]: j = j + 1 else: stillOK = False return stillOKprint(anagramSolution4('apple','pleap')) 同样，这个方案有多个迭代，但是和第一个解法不一样，它不是嵌套的。两个迭代都是 n, 第三个迭代，比较两个计数列表，需要 26 步，因为有 26 个字母。一共 T(n)=2n+26T(n)=2n+26，即 O(n)，我们找到了一个线性量级的算法解决这个问题。 如果让我自己来选择，我可能会选第二种，第二种最简单，也最好理解。但是最后的结论表明 解法4 才是最优解法，排序固然简单，但是但数量很大的时候，可能远不止我们想的那么简单。 在结束这个例子之前，我们来讨论下空间花费，虽然最后一个方案在线性时间执行，但它需要额外的存储来保存两个字符计数列表。换句话说，该算法牺牲了空间以获得时间。 很多情况下，你需要在空间和时间之间做出权衡。这种情况下，额外空间不重要，但是如果有数百万个字符，就需要关注下。作为一个计算机科学家，当给定一个特定的算法，将由你决定如何使用计算资源。 如有错误，请指出 图片来源 各位下期见，不聊了，又该搬砖了。。。","tags":[{"name":"算法","slug":"算法","permalink":"https://zhangslob.github.io/tags/算法/"},{"name":"Python","slug":"Python","permalink":"https://zhangslob.github.io/tags/Python/"},{"name":"排序","slug":"排序","permalink":"https://zhangslob.github.io/tags/排序/"}]},{"title":"使用logging管理爬虫","date":"2018-01-15T13:39:35.000Z","path":"2018/01/15/使用logging管理爬虫/","text":"这是崔斯特的第二十四篇原创文章 使用日志记录程序运行状态 文档 日志 模块自2.3版本开始便是Python标准库的一部分。它被简洁的描述在 PEP 282。 众所周知，除了 基础日志指南 部分，该文档并不容易阅读。 日志的两个目的： 诊断日志 记录与应用程序操作相关的日志。例如，用户遇到的报错信息， 可通过搜索诊断日志获得上下文信息。 审计日志 为商业分析而记录的日志。从审计日志中，可提取用户的交易信息， 并结合其他用户资料构成用户报告或者用来优化商业目标。 … 或者打印?当需要在命令行应用中显示帮助文档时， 打印 是一个相对于日志更好的选择。 而在其他时候，日志总能优于 打印 ，理由如下： 日志事件产生的 日志记录 ，包含清晰可用的诊断信息，如文件名称、路径、函数名和行号等。 包含日志模块的应用，默认可通过根记录器对应用的日志流进行访问，除非您将日志过滤了。 可通过 logging.Logger.setLevel() 方法有选择地记录日志， 或可通过设置 logging.Logger.disabled 属性为 True 来禁用。 库中的日志日志指南 中含 库日志配置 的说明。由于是 用户 ，而非库来指明如何响应日志事件， 因此这里有一个值得反复说明的忠告： 注解强烈建议不要向您的库日志中加入除NullHandler外的其它处理程序。 在库中，声明日志的最佳方式是通过 __name__ 全局变量： logging 模块通过点(dot)运算符创建层级排列的日志，因此，用 __name__ 可以避免名字冲突。 以下是一个来自 requests 资源 的最佳实践的例子 —— 把它放置在您的 __init__.py 文件中12import logginglogging.getLogger(__name__).addHandler(logging.NullHandler()) 应用程序中的日志应用程序开发的权威指南， 应用的12要素 ，也在其中一节描述了 日志的作用 。它特别强调将日志视为事件流， 并将其发送至由应用环境所处理的标准输出中。 配置日志至少有以下三种方式： 使用INI格式文件： 优点: 使用 logging.config.listen() 函数监听socket，可在运行过程中更新配置 缺点: 通过源码控制日志配置较少（ 例如 子类化定制的过滤器或记录器）。 使用字典或JSON格式文件： 优点: 除了可在运行时动态更新，在Python 2.6之后，还可通过 json 模块从其它文件中导入配置。 缺点: 很难通过源码控制日志配置。 使用源码： 优点: 对配置绝对的控制。 缺点: 对配置的更改需要对源码进行修改。 通过INI文件进行配置的例子我们假设文件名为 logging_config.ini 。关于文件格式的更多细节，请参见 日志指南 中的 日志配置 部分。 123456789101112131415161718192021[loggers]keys=root[handlers]keys=stream_handler[formatters]keys=formatter[logger_root]level=DEBUGhandlers=stream_handler[handler_stream_handler]class=StreamHandlerlevel=DEBUGformatter=formatterargs=(sys.stderr,)[formatter_formatter]format=%(asctime)s %(name)-12s %(levelname)-8s %(message)s 然后在源码中调用 logging.config.fileConfig() 方法：123456import loggingfrom logging.config import fileConfigfileConfig('logging_config.ini')logger = logging.getLogger()logger.debug('often makes a very good meal of %s', 'visiting tourists') 通过字典进行配置的例子Python 2.7中，您可以使用字典实现详细配置。PEP 391 包含了一系列字典配置的强制和 非强制的元素。123456789101112131415161718192021222324import loggingfrom logging.config import dictConfiglogging_config = dict( version = 1, formatters = &#123; 'f': &#123;'format': '%(asctime)s %(name)-12s %(levelname)-8s %(message)s'&#125; &#125;, handlers = &#123; 'h': &#123;'class': 'logging.StreamHandler', 'formatter': 'f', 'level': logging.DEBUG&#125; &#125;, root = &#123; 'handlers': ['h'], 'level': logging.DEBUG, &#125;,)dictConfig(logging_config)logger = logging.getLogger()logger.debug('often makes a very good meal of %s', 'visiting tourists') 通过源码直接配置的例子 1234567891011import logginglogger = logging.getLogger()handler = logging.StreamHandler()formatter = logging.Formatter( '%(asctime)s %(name)-12s %(levelname)-8s %(message)s')handler.setFormatter(formatter)logger.addHandler(handler)logger.setLevel(logging.DEBUG)logger.debug('often makes a very good meal of %s', 'visiting tourists') 官方文档说完了，来看看具体的应用。 默认的日志级别设置为 WARNING （日志级别等级 CRITICAL &gt; ERROR &gt; WARNING &gt; INFO &gt; DEBUG &gt; NOTSET）, 小于 WARNING 级别的日志都不输出, 大于等于 WARNING 级别的日志都会输出。 简单的将日志打印到屏幕12345678910111213141516171819#!/usr/bin/env python# -*- coding: utf8 -*-import loggingif __name__ == '__main__': logging.basicConfig(level=logging.DEBUG, format='%(asctime)s %(filename)s [line:%(lineno)d] %(levelname)s %(message)s', datefmt='%a, %d %b %Y %H:%M:%S', filename='test.log', filemode='w') console = logging.StreamHandler() console.setLevel(logging.WARNING) formatter=logging.Formatter('%(name)-12s: %(levelname)-8s %(message)s') console.setFormatter(formatter) logging.getLogger('').addHandler(console) logging.debug('This is DEBUG') logging.info('This is INFO') logging.warning('This is WARNING') 输出:1root : WARNING This is WARNING test.log文件中包含：123Mon, 15 Jan 2018 20:19:45 sfda.py [line:90] DEBUG This is DEBUGMon, 15 Jan 2018 20:19:45 sfda.py [line:91] INFO This is INFOMon, 15 Jan 2018 20:19:45 sfda.py [line:92] WARNING This is WARNING 注意：由于日志写入模式设置为 w ，因此重复运行时会将之前的日志清空。 logging.basicConfig 函数各参数: 123456789101112131415161718filename: 指定日志文件名filemode: 和file函数意义相同，指定日志文件的打开模式，’w’或’a’format: 指定输出的格式和内容，format可以输出很多有用信息，如上例所示:%(levelno)s: 打印日志级别的数值%(levelname)s: 打印日志级别名称%(pathname)s: 打印当前执行程序的路径，其实就是sys.argv[0]%(filename)s: 打印当前执行程序名%(funcName)s: 打印日志的当前函数%(lineno)d: 打印日志的当前行号%(asctime)s: 打印日志的时间%(thread)d: 打印线程ID%(threadName)s: 打印线程名称%(process)d: 打印进程ID%(message)s: 打印日志信息datefmt: 指定时间格式，同time.strftime()level: 设置日志级别，默认为logging.WARNINGstream: 指定将日志的输出流，可以指定输出到sys.stderr,sys.stdout或者文件，默认输出到sys.stderr，当stream和filename同时指定时，stream被忽略 logging 三大模块： Logger , Handler ， Formatlogger logger 通过 getLogger 函数得到， 可以在不同的模块中使用不同的 logger123import logginglogger = logging.getLogger(__name__)logger.debug('some infomation') Handler handler 有多种， 可以记录到 console， 或者到文件， 文件也可以自动 rotate， 常用的几个 handler StreamHandler 打印到终端 FileHandler 保存到文件 RotatingFileHandler 保存到文件， 达到一定大小之后备份文件。 TimedRotatingFileHandler 定时备份 Format Formatter 对象设置日志信息最后的规则、结构和内容，默认的时间格式为 %Y-%m-%d %H:%M:%S Scrapy 与 Logging 文档 Scrapy uses Python’s builtin logging system for event logging. We’ll provide some simple examples to get you started, but for more advanced use-cases it’s strongly suggested to read thoroughly its documentation. Scrapy使用Python的内置日志记录系统进行事件日志记录。 我们将提供一些简单的示例来帮助您开始，但对于更高级的用例，强烈建议您仔细阅读其文档。 Log levels logging.CRITICAL - for critical errors (highest severity) logging.ERROR - for regular errors logging.WARNING - for warning messages logging.INFO - for informational messages logging.DEBUG - for debugging messages (lowest severity) How to log messages quick example 123import logginglogger = logging.getLogger()logger.warning(\"This is a warning\") Logging from Spiders该记录器是使用Spider的名称创建的，但是您可以使用任何您想要的自定义Python记录器。 例如： 123456789101112import loggingimport scrapylogger = logging.getLogger('mycustomlogger')class MySpider(scrapy.Spider): name = 'myspider' start_urls = ['https://scrapinghub.com'] def parse(self, response): logger.info('Parse function called on %s', response.url) 在middlewares中应用12345678import logginglogger = logging.getLogger(__name__)class ProxyMiddleware(object): def process_request(self, request, spider): request.meta['proxy'] = random.choice(proxy_list) spider.logger.info('get ip: &#123;&#125;'.format(request.meta['proxy'])) 使用Scrapy记录爬取日志在 settings.py 中修改:12LOG_STDOUT = TrueLOG_FILE = 'scrapy_log.txt' 然后开始运行爬虫，日志不会打印，会保存到 scrapy_log.txt 文件中。 使用errbacks在请求处理中捕获异常请求的errback是在处理异常时被调用的函数。 它接收Twisted Failure实例作为第一个参数，可用于跟踪连接建立超时，DNS错误等。 这里有一个爬虫日志记录所有的错误和捕捉一些特定的错误，例子： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import scrapyfrom scrapy.spidermiddlewares.httperror import HttpErrorfrom twisted.internet.error import DNSLookupErrorfrom twisted.internet.error import TimeoutError, TCPTimedOutErrorclass ErrbackSpider(scrapy.Spider): name = \"errback_example\" start_urls = [ \"http://www.httpbin.org/\", # HTTP 200 expected \"http://www.httpbin.org/status/404\", # Not found error \"http://www.httpbin.org/status/500\", # server issue \"http://www.httpbin.org:12345/\", # non-responding host, timeout expected \"http://www.httphttpbinbin.org/\", # DNS error expected ] def start_requests(self): for u in self.start_urls: yield scrapy.Request(u, callback=self.parse_httpbin, errback=self.errback_httpbin, dont_filter=True) def parse_httpbin(self, response): self.logger.info('Got successful response from &#123;&#125;'.format(response.url)) # do something useful here... def errback_httpbin(self, failure): # log all failures self.logger.error(repr(failure)) # in case you want to do something special for some errors, # you may need the failure's type: if failure.check(HttpError): # these exceptions come from HttpError spider middleware # you can get the non-200 response response = failure.value.response self.logger.error('HttpError on %s', response.url) elif failure.check(DNSLookupError): # this is the original request request = failure.request self.logger.error('DNSLookupError on %s', request.url) elif failure.check(TimeoutError, TCPTimedOutError): request = failure.request self.logger.error('TimeoutError on %s', request.url)","tags":[{"name":"2017","slug":"2017","permalink":"https://zhangslob.github.io/tags/2017/"},{"name":"logging","slug":"logging","permalink":"https://zhangslob.github.io/tags/logging/"}]},{"title":"2017 梦醒时分","date":"2017-12-31T08:09:41.000Z","path":"2017/12/31/2017-梦醒时分/","text":"这是崔斯特的第二十三篇原创文章 首先说说自己吧，小歪、来自湖北、在武汉中南民族大学本科社会学专业，目前在北漂，职位是客户支持&amp;爬虫工程师。 先说说自己的大学吧，大学时基本是不知道自己想要什么，也没有思考过自己以后去做什么这个问题，可以说是玩了三年，到了大四，面临着毕业找工作的压力，出去找实习，可是自己啥也不会啊。就是在这个情况下，我接触到了Python。 翻看自己一年前写的博客 Python练习第一题，在图片上加入数字，我在里面曾经说过这样一句话： 最后，我想给自己定个目标，2017年利用Python找到一份工作，养活自己。 在今天，也就是2017年12月31日，我可以自豪地说，我完成了我的目标。 这其中发生了很多有趣的事，我现在都说一说吧。 第一个offer临近毕业的时候当然也有跑宣讲会什么的，各种机缘巧合下，拿到了第一个offer，是食品行业的，好像是什么质检员，我感觉自己还是想去互联网行业的，所以拒绝了。 第二个offer第二个是某派新闻，号称党媒旗下的媒体。刚去的时候，做的是审核类的工作，最后才发现里面的各种坑。好险自己发现的早，时间已经来到17年的3月份。 第三个offer 到3月份，我还没找到工作，但是自己心灰意冷，很害怕刚毕业就失业，但是在武汉根本很难找到合适的工作。恰好在这个时候，认识了天善的勇哥，大家可以去看看天善的课程，都是一线大牛人物，天善智能。然后我就去上海了，去上海的一个月时间，我自己改变是非常大的。认识了很多大佬，见识了很多新的想法。 在天善做的是新媒体这一块，但是就有写这样一篇文章，叫做为了找一份Python实习，我用爬虫收集数据，很巧的事情是，现在我的BOSS真好看到了这篇文章，然后就联系我了，然后我就来了。 第四个offer 我是6月份来到北京的，到现在已经有半年了，一直呆在造数。 做过运营、做过客户支持，最近开始接触项目，可以使用Python开发项目，虽然有很多做得不好的地方，但是对我来说这是一个开始。 我每天会花很多时间去学习（周末除外，因为我要吃鸡，haha），也会经常写博客，记录自己的学习经历，接触项目之后才发现自己以前的各种毛病，这些都不是问题，坚持学习就好。 这期间，我还配合造数的首席爬虫工程师小X制作了一期Python爬虫课程，课程还是挺精彩的，我学习进阶部分后，感觉对Scrapy框架入门了。 有兴趣的可以看看，但是我并不推荐，因为学Python或者爬虫最好的还是去看文档，文档是最好的选择。这种培训课程只有一个好处，就是及时的帮你解答疑惑。 好了，不扯远了，继续回到今天的主题。 总结2017年对我来说就是“梦醒时分”，总算是在这一年完成了自己的梦想，接下来就需要自己更加努力，去弥补自己所缺乏的。 对于我这个文科生来说，确实是挺不容易的，但是就像歌词里的： 新的风暴已经出现怎么能够停滞不前穿越时空竭尽全力我会来到你身边微笑面对危险梦想成真不会遥远鼓起勇气坚定向前奇迹一定会出现 非常欢迎大家与我交流，有什么疑问可以直接在评论中说出来，我定会知无不言。 也可以加我微信交流： zhang7350 最后，如果你也想要学Python找工作，你应该先问自己一个问题： 我喜欢Python吗？","tags":[{"name":"年度总结","slug":"年度总结","permalink":"https://zhangslob.github.io/tags/年度总结/"},{"name":"2017","slug":"2017","permalink":"https://zhangslob.github.io/tags/2017/"}]},{"title":"采集方案策略之App抓包","date":"2017-12-23T13:40:26.000Z","path":"2017/12/23/采集方案策略之App抓包/","text":"这是崔斯特的第二十二篇原创文章 采集方案策略设计在群里看到有人询问饿了么的参数，正好感兴趣，就来时间一番。 这里引用下大佬的一段话： 首先大的地方，我们想抓取某个数据源，我们要知道大概有哪些路径可以获取到数据源，基本上无外乎三种： PC端网站 针对移动设备响应式设计的网站（也就是很多人说的H5, 虽然不一定是H5）； 移动App 原则是能抓移动App的，最好抓移动App，如果有针对移动设备优化的网站，就抓针对移动设备优化的网站，最后考虑PC网站。因为移动App基本都是API很简单，而移动设备访问优化的网站一般来讲都是结构简单清晰的HTML，而PC网站自然是最复杂的了；针对PC端网站和移动网站的做法一样，分析思路可以一起讲，移动App单独分析。 其实很多网页都有移动端，像微博，我知道这三个： weibo.com weibo.cn m.weibo.cn 最简单的当然是第二种了，对于今天的受害者——饿了么来说，当然，首选也是移动端。 饿了么抓包分析这里抓包工具选择Fiddler，这里不讲如何配置，具体参考 用Fiddler对Android应用进行抓包 下面打开手机的饿了么，原本以为会有数据，结果，竟然是这样 去询问了专业人士，了解了有些应用不允许用户抓包，会有相应的限制。好吧，这就能难倒我了吗？？ 当我切换到发现类目下，发现有奇怪的提示 在疯狂点击继续访问后，我终于可以正常访问了。 那么就可以在Fiddler中查看对应的数据了。这里直接把接口展示出来：饿了么接口 浏览器直接打开，貌似没有啥验证 具体分析里面的参数 1234offset:20limit:40latitude:39.93245longitude:116.50097 有4个参数， offset 和 limit 就很常见了，翻页和每页的数据，至于 latitude 和 longitude 仔细观察就知道，经纬度嘛，把它该修改为你想采集的位置的经纬度就好。 抓包分析之后，接下来采集数据就很简单了，数据字段标识： food_id 是商品ID，接口是：https://www.ele.me/restapi/shopping/v1/foods?food_ids%5B%5D=712859937 打开此链接就是商品详情内容 可爱的小笼包 restaurant_id 是店铺ID，接口 https://www.ele.me/shop/157458556 打开就是店铺详情页，当然，也有移动端：https://h5.ele.me/shop/#id=157458556 这样进行商品采集就比较轻松了。 好饿，容我先点个外卖。 微信公众号抓包分析既然都看了饿了么，那也来看看微信吧。 使用Fiddler抓出来的curl命令 1curl -k -i --raw -o 0.dat &quot;https://mp.weixin.qq.com/mp/profile_ext?action=getmsg&amp;__biz=MzA4NzA1OTc5Nw==&amp;f=json&amp;offset=20&amp;count=10&amp;appmsg_token=936_iWFH%%252F9haOTPb6GApBj6wXjPGKg9eeU7slzmH2Q~~&quot; -H &quot;User-Agent: Mozilla/5.0 (Linux; Android 7.1.1; MI 6 Build/NMF26X; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/53.0.2785.49 Mobile MQQBrowser/6.2 TBS/043632 Safari/537.36 MicroMessenger/6.5.23.1180 NetType/WIFI Language/zh_CN&quot; -H &quot;Accept-Encoding: gzip, deflate&quot; -H &quot;Accept: */*&quot; -H &quot;Connection: keep-alive&quot; -H &quot;Host: mp.weixin.qq.com&quot; -H &quot;X-Requested-With: XMLHttpRequest&quot; -H &quot;Referer: https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzA4NzA1OTc5Nw==&amp;scene=124&amp;devicetype=android-25&amp;version=26051732&amp;lang=zh_CN&amp;nettype=WIFI&amp;a8scene=3&amp;pass_ticket=lLCqBwwrZ581bGDqrEkRsgjKkWYNPdUBs9grSaFjd79hSX0mdvR8%%2BLUbHoWGGBEp&amp;wx_header=1&quot; -H &quot;Accept-Language: zh-CN,en-US;q=0.8&quot; -H &quot;Cookie: pgv_pvi=4831552512; pgv_si=s989715456; sd_userid=18991505459750403; sd_cookie_crttime=1505459750403; tvfe_boss_uuid=a8e4e4f1ab6cd93d; pgv_info=ssid=s8735681072; pgv_pvid=4201362299; rewardsn=8d8b49dfb1811092eefe; wxtokenkey=19643e9f2ee569a10857d365bba88556d220fd33c1a0666b5d028a72b5bcd901; wxuin=838107840; devicetype=android-25; version=26051732; lang=zh_CN; pass_ticket=lLCqBwwrZ581bGDqrEkRsgjKkWYNPdUBs9grSaFjd79hSX0mdvR8+LUbHoWGGBEp; wap_sid2=CMCF0o8DElxUVDVJR3o1ZldpbDlHWWdjQ0xMU3lxM3BWTUozTFFuZFhrUEJaanhoSmZ1aEVncnU0VzFIaWR3QkVVVXFuTUlMTlkxNFZjTnRCMEt1VHJjV3UzQVNOYWdEQUFBfjD6rvjRBTgMQJRO&quot; -H &quot;Q-UA2: QV=3&amp;PL=ADR&amp;PR=WX&amp;PP=com.tencent.mm&amp;PPVN=6.5.23&amp;TBSVC=43602&amp;CO=BK&amp;COVC=043632&amp;PB=GE&amp;VE=GA&amp;DE=PHONE&amp;CHID=0&amp;LCID=9422&amp;MO= MI6 &amp;RL=1080*1920&amp;OS=7.1.1&amp;API=25&quot; -H &quot;Q-GUID: 569ade09b5931656e4f49098113e88cb&quot; -H &quot;Q-Auth: 31045b957cf33acf31e40be2f3e71c5217597676a9729f1b&quot; -H &quot;Content-Type: application/json; charset=UTF-8&quot; -H &quot;Cache-Control: no-cache, must-revalidate&quot; -H &quot;RetKey: 14&quot; -H &quot;LogicRet: 0&quot; 直接在浏览器中打开，会提示错误 12345&#123;ret: -3,errmsg: &quot;no session&quot;,cookie_count: 0&#125; 使用postman分析，最后Python的代码是 1234567891011121314151617181920212223242526272829import requestsurl = \"https://mp.weixin.qq.com/mp/profile_ext\"querystring = &#123;\"action\":\"getmsg\",\"__biz\":\"MzA4NzA1OTc5Nw==\",\"f\":\"json\",\"offset\":\"20\",\"count\":\"10\",\"appmsg_token\":\"936_iWFH%2F9haOTPb6GApBj6wXjPGKg9eeU7slzmH2Q~~\"&#125;headers = &#123; 'user-agent': \"Mozilla/5.0 (Linux; Android 7.1.1; MI 6 Build/NMF26X; wv) AppleWebKit/537.36 (KHTML, like Gecko) Version/4.0 Chrome/53.0.2785.49 Mobile MQQBrowser/6.2 TBS/043632 Safari/537.36 MicroMessenger/6.5.23.1180 NetType/WIFI Language/zh_CN\", 'accept-encoding': \"gzip, deflate\", 'accept': \"*/*\", 'connection': \"keep-alive\", 'host': \"mp.weixin.qq.com\", 'x-requested-with': \"XMLHttpRequest\", 'referer': \"https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzA4NzA1OTc5Nw==&amp;scene=124&amp;devicetype=android-25&amp;version=26051732&amp;lang=zh_CN&amp;nettype=WIFI&amp;a8scene=3&amp;pass_ticket=lLCqBwwrZ581bGDqrEkRsgjKkWYNPdUBs9grSaFjd79hSX0mdvR8%%2BLUbHoWGGBEp&amp;wx_header=1\", 'accept-language': \"zh-CN,en-US;q=0.8\", 'cookie': \"pgv_pvi=4831552512; pgv_si=s989715456; sd_userid=18991505459750403; sd_cookie_crttime=1505459750403; tvfe_boss_uuid=a8e4e4f1ab6cd93d; pgv_info=ssid=s8735681072; pgv_pvid=4201362299; rewardsn=8d8b49dfb1811092eefe; wxtokenkey=19643e9f2ee569a10857d365bba88556d220fd33c1a0666b5d028a72b5bcd901; wxuin=838107840; devicetype=android-25; version=26051732; lang=zh_CN; pass_ticket=lLCqBwwrZ581bGDqrEkRsgjKkWYNPdUBs9grSaFjd79hSX0mdvR8+LUbHoWGGBEp; wap_sid2=CMCF0o8DElxUVDVJR3o1ZldpbDlHWWdjQ0xMU3lxM3BWTUozTFFuZFhrUEJaanhoSmZ1aEVncnU0VzFIaWR3QkVVVXFuTUlMTlkxNFZjTnRCMEt1VHJjV3UzQVNOYWdEQUFBfjD6rvjRBTgMQJRO\", 'q-ua2': \"QV=3&amp;PL=ADR&amp;PR=WX&amp;PP=com.tencent.mm&amp;PPVN=6.5.23&amp;TBSVC=43602&amp;CO=BK&amp;COVC=043632&amp;PB=GE&amp;VE=GA&amp;DE=PHONE&amp;CHID=0&amp;LCID=9422&amp;MO= MI6 &amp;RL=1080*1920&amp;OS=7.1.1&amp;API=25\", 'q-guid': \"569ade09b5931656e4f49098113e88cb\", 'q-auth': \"31045b957cf33acf31e40be2f3e71c5217597676a9729f1b\", 'content-type': \"application/json; charset=UTF-8\", 'cache-control': \"no-cache\", 'retkey': \"14\", 'logicret': \"0\", &#125;response = requests.request(\"GET\", url, headers=headers, params=querystring, verify=False)print(response.json()) 这个时候的参数有 123456action:getmsg__biz:MzA4NzA1OTc5Nw==f:jsonoffset:20count:10appmsg_token:936_iWFH%%252F9haOTPb6GApBj6wXjPGKg9eeU7slzmH2Q~~ 目前还不清楚这些参数的作用，再抓一个试试 123456action:getmsg__biz:MjM5NzI3NDg4MA==f:jsonoffset:10count:10appmsg_token:936_kFNdYU3DJ%%252B%%252BVfHfEGImXqB5DMbIeqtSR75ZFZQ~~ 估计就是 __biz 和 appmsg_token 这两个参数对应不同的公众号 对了，上面的代码会出现一个问题 12InsecureRequestWarning: Unverified HTTPS request is being made. Adding certificate verification is strongly advised. See: https://urllib3.readthedocs.io/en/latest/advanced-usage.html#ssl-warnings InsecureRequestWarning) 解决方法 12from requests.packages import urllib3urllib3.disable_warnings() App的分析App类使用的工具是Fidder，手机和电脑在一个局域网内，先用Fidder配置好端口，然后手机设置代理，ip为电脑的ip，端口为设置的端口，然后如果手机上请求网络内容时，Fidder会显示相应地请求，那么就ok了，分析的大体逻辑基本一致，限制会相对少很多，但是也有几种情况需要注意： 加密，App有时候也有一些加密的字段，这个时候,一般来讲都会进行反编译进行分析，找到对应的代码片段，逆推出加密方法； gzip压缩或者base64编码，base64编码的辨别度较高，有时候数据被gzip压缩了，不过Charles都是有自动解密的； https证书，有的https请求会验证证书, Fidder提供了证书，可以在官网找到，手机访问，然后信任添加就可以。 最后，祝大家圣诞节快乐","tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://zhangslob.github.io/tags/爬虫/"},{"name":"抓包","slug":"抓包","permalink":"https://zhangslob.github.io/tags/抓包/"}]},{"title":"【RNG vs SKT】弹幕的自然语言的初步分析","date":"2017-12-20T14:17:35.000Z","path":"2017/12/20/【RNG-vs-SKT】弹幕的自然语言的初步分析/","text":"这是崔斯特的第二十一篇原创文章 前排 @皇族电子竞技俱乐部 ================================== S7中RNG对阵SKT，想必是全世界LOL玩家关注的重点。在比赛开始前，使用小葫芦把斗鱼S7直播间的弹幕都抓下来，想着做一小点分析，看看会得出什么结论。 因为数据量和分析深度等原因，以下内容仅供娱乐观赏 数据采集使用小葫芦采集2万多条弹幕数据，RNG对阵SKT斗鱼直播间的弹幕，最后得到约4万可用数据 中文分词使用jieba分词，算法如下 基于前缀词典实现高效的词图扫描，生成句子中汉字所有可能成词情况所构成的有向无环图 (DAG) 采用了动态规划查找最大概率路径, 找出基于词频的最大切分组合 对于未登录词，采用了基于汉字成词能力的 HMM 模型，使用了 Viterbi 算法 简单处理之后，看起来是这样 顺便做个统计，看看都在说什么。不加停用词是这样的，全是 “666” RNG和牛逼是出现最多的词语，同时也发现“卢本伟牛逼” 弱弱问一句“唐梦琼”是谁 下面是词云，Python的词云做不来不好看，所以我使用的工具 HTML5 Word Cloud 弹幕内容词云 用户昵称词云 情感分析这里使用的是 isnowfy/snownlp。SnowNLP是一个python写的类库，可以方便的处理中文文本内容，是受到了TextBlob的启发而写的。 1234from snownlp import SnowNLPs = SnowNLP(u'这个东西真心很赞')s.sentiments # 0.9769663402895832 positive的概率 有点难看，直接看数据吧，得到的结果是在 [0，1] 之间的positive的概率 51659中有44705个大于0.5，占比86.54%，有 6954条弹幕低于0.5，占比13.46%。 弹幕中积极的概率还是相当高的，说明观众还是比较赞赏比赛的。 特征提取TF-IDF是信息检索领域非常重要的搜索词重要性度量；tf-idf是一种统计方法，用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。 词频TF(Term Frequency) 词w在文档d中出现次数count(w, d)和文档d中总词数size(d)的比值： 基于 TF-IDF 算法的关键词抽取： RNG rng 贺电 加油 发来 666 6666 66666 恭喜 66666666666666 666666 66666666666 6666666 skt 李哥 66666666666666666666 SKT 66666666 666666666 马甲 在没有加上停用词的前提下，可以看到效果并不理想 TextRank是在Google的PageRank算法启发下，针对文本里的句子设计的权重算法，目标是自动摘要。它利用投票的原理，让每一个单词给它的邻居（术语称窗口）投赞成票，票的权重取决于自己的票数。 基于 TextRank 算法的关键词抽取： 发来 贺电 加油 学院 机器人 大学 职业 船长 技术 小炮 没有 解说 中国 经济 开始 无敌 香锅 垃圾 老鼠 科技 特征选择Word2vec是一个将单词表征成向量的形式，它可以把文本内容的处理简化为向量空间中的向量运算，计算出向量空间上的相似度，来表示文本语义上的相似度。 计算相似度：首先是RNG： rng 0.9893965721130371 加油 0.9829007983207703 必胜 0.9790929555892944 Rng 0.9743078947067261 恭喜 0.9733642339706421 中国队 0.9397183656692505 关 0.9283092021942139 &lt; 0.9278833866119385 燕尾港 0.9222617149353027 B 0.9143030643463135 RNG加油 看看SKT： skt 0.9911665320396423 皇族 0.972029983997345 ＾ 0.970970094203949 稳住 0.9653508067131042 干死 0.9643667340278625 牛比 0.9629441499710083 一起 0.9625348448753357 @ 0.9619969725608826 鸟巢 0.9608791470527649 冠军 0.9608250856399536 稳住，干死SKT？ 贺电： 学院 0.9811943769454956 大学 0.980491042137146 技术 0.9766334295272827 职业 0.9691535234451294 电子科技 0.9668481349945068 发来 0.9619022607803345 科技 0.9594647884368896 山东 0.9568137526512146 重庆 0.9440888166427612 哈尔滨 0.939836859703064 山东XX学院发来贺电 加油： 必胜 0.9876022934913635 RNG 0.9829007983207703 rng 0.960281252861023 Rng 0.9591789841651917 恭喜 0.9551880359649658 中国队 0.9436988830566406 关 0.94183349609375 ！ 0.921385645866394 ~ 0.9148629903793335 @ 0.9062787294387817 RNG加油，RNG必胜 小狗： 吹 0.9970275163650513 无敌 0.996719241142273 神超 0.996111273765564 后期 0.9959050416946411 厉害 0.9957337975502014 凶 0.9957261681556702 强 0.9955072402954102 一个 0.9954395890235901 干 0.99541175365448 起来 0.9952359199523926 狗吹？ 李哥： 还是 0.9825356602668762 电话 0.9700809717178345 承 0.9697628617286682 心脏 0.9686012864112854 陈文泽在 0.9681863188743591 麻痹 0.9680625200271606 响 0.9674116373062134 以为 0.9664229154586792 狗哥 0.9592204689979553 不 0.9589840769767761 你李哥还是你李哥 MLXG： 宣告 0.9958090782165527 mlxg 0.9953181147575378 死亡 0.995277464389801 b 0.9949076771736145 6666 0.9947425723075867 丑 0.9943945407867432 10 0.9943088293075562 辣鸡 0.9940722584724426 干死 0.9940391778945923 锤 0.9939616918563843 香锅和死亡宣告有啥关系 小虎： 笑笑 0.9971799850463867 看到 0.9967395663261414 解说 0.9961692690849304 不是 0.9959656000137329 中单 0.9951503872871399 假 0.9950063824653625 为什么 0.9944812655448914 又 0.9942663908004761 么 0.9938984513282776 里奥 0.9937981367111206 小虎与加里奥（： letme： 难受 0.9964221715927124 笑话 0.9959778785705566 哦 0.9958946108818054 世界 0.9958213567733765 毒奶 0.9957934021949768 KPL 0.9957884550094604 上单 0.9956253170967102 瓜皮 0.9955945014953613 快 0.9953423738479614 打团 0.9953156113624573 真难受啊 To Do 可以使用朴素贝叶斯做分类模型 使用机器学习性能评估指标预测精确率和准确率 欢迎补充 可参考资料 中文分词基本算法介绍 ICTCLAS 汉语词性标注集 文本分类技术 文本分类与SVM 基于贝叶斯算法的文本分类算法 基于libsvm的中文文本分类原型 LDA-math-文本建模 情感分析资源 面向情感分析的特征抽取技术研究 斯坦福大学自然语言处理第七课-情感分析 深度学习、自然语言处理和表征方法 Deep Learning in NLP （一）词向量和语言模型","tags":[{"name":"NLP","slug":"NLP","permalink":"https://zhangslob.github.io/tags/NLP/"},{"name":"自然语言处理","slug":"自然语言处理","permalink":"https://zhangslob.github.io/tags/自然语言处理/"}]},{"title":"scrapy学习实例（四）采集淘宝数据并展示","date":"2017-12-19T13:09:07.000Z","path":"2017/12/19/scrapy学习实例（四）采集淘宝数据并展示/","text":"这是崔斯特的第二十篇原创文章 本节代码 ： zhangslob/Taobao_duoshou 万水千山总是情，给个star行不行 铛铛铛，懒惰了一段时间，咱接着学Scrapy。这一期玩点新花样，使用Flask展示我们的数据。效果如下图： 有些重复的 ╮(╯Д╰)╭ 过程简单来说有两步： 使用Scrapy采集淘宝数据 使用Flask展示数据 采集数据抓包分析其实采集淘宝数据的方法真的很多很多，这里不讨论Selenium，只说如何抓包分析，先提供几个接口，供观众老爷观赏： https://s.taobao.com/list?seller_type=taobao&amp;json=on https://s.m.taobao.com/search?event_submit_do_new_search_auction=1&amp;_input_charset=utf-8&amp;topSearch=1&amp;atype=b&amp;searchfrom=1&amp;action=home%3Aredirect_app_action&amp;from=1&amp;q=%E6%B0%B4%E6%9E%9C&amp;sst=1&amp;n=44&amp;buying=buyitnow&amp;m=api4h5&amp;abtest=25&amp;wlsort=25&amp;page=1 http://h5.m.taobao.com/app/selectassistant/www/choiceness/index.html?m=select&amp;vm=nw&amp;ttid=null&amp;utd_id=null&amp;page=2&amp;n=44&amp;q=%E6%B0%B4%E6%9E%9C 这三种接口都可以采集数据，别问我怎么知道的，经历过千百次失败。这里选择的是第二种，大家可以试试这几种的区别。 使用第二种去采集数据时，返回的是json数据，数据量已经很多。 其中有几点坑，分享下。 URL不同。淘宝和天猫的链接是不同的，移动端和网页端是不同的。 这里显示的 commentCount （评论数量）并不是真实的，你可以打开详情页对比 评论数量的接口。淘宝和天猫的都可以使用 https://rate.taobao.com/detailCount.do?itemId=商品ID，每件商品都有自己的唯一ID 代码实战这里直接把主代码贴出来，使用 Mongo 保存数据。 taobao.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# -*- coding: utf-8 -*-import copyimport scrapyimport jsonfrom ..items import TaobaoInfoItemimport refrom traceback import format_exckw = ['网络服务', '装潢', '护理', '速食', '运动鞋', '运动服', '男装', '配件', '蔬果', '干货', '攻略', '地毯', '文具', '书籍', '人偶', '饰品', '报纸', '时尚饰品', '美发', '运动包', '粮油', '吃喝玩乐折扣券', '工具', '彩妆', '演出', '童装', '个性定制', '数码相机', '日化', '游戏', '尿片', '安防', '摄像机', '厨房电器', '办公设备', '网店', 'ZIPPO', '杂志', '礼品', '摄影器材', '喂哺等用品', '软件', '笔记本电脑', '明星', '登山', '居家日用', '户外', '电脑硬件', '流行首饰', '娃娃', '收纳', '影视', '音乐', '电玩', '音像', '香水', '水产', '热销女包', '大家电', '其他保健营养品', '箱包皮具', '瑞士军刀', '3C数码配件市场', '电脑周边', '男包', '玩具', 'U盘', '模型', '孕妇装', '窗帘', '眼镜', '促销店铺', '五金', '旅行', '洗护', '清洁', '移动存储', '卫浴', '野营', '颈环配件', '童鞋', '家装饰品', '显示器', '闪存卡', '传统滋补品', '耗材', '灯具']class TaobaoSpider(scrapy.Spider): name = 'taobao' allowed_domains = ['taobao.com'] start_urls = ['https://s.m.taobao.com/search?event_submit_do_new_search_auction=1&amp;_input_charset=utf-8&amp;topSearch=1&amp;atype=b&amp;searchfrom=1&amp;action=home%3Aredirect_app_action&amp;from=1&amp;q=&#123;&#125;&amp;sst=1&amp;n=44&amp;buying=buyitnow&amp;m=api4h5&amp;abtest=25&amp;wlsort=25&amp;page=&#123;&#125;'.format(i, y) for i in range(1, 101) for y in kw] # 其他接口 http://h5.m.taobao.com/app/selectassistant/www/choiceness/index.html?m=select&amp;vm=nw&amp;ttid=null&amp;utd_id=null&amp;page=2&amp;n=44&amp;q=%E6%B0%B4%E6%9E%9C def parse(self, response): item = TaobaoInfoItem() ListItem = json.loads(response.text)['listItem'] for i in ListItem: item['name'] = i['name'] item['title'] = i['title'] item['area'] = i['area'] # 处理不同的URL url = [] if 'https:' not in i['url']: if 'detail.m.tmall.com' in i['url']: url.append('https:' + i['url'].replace('.m','')) else: url.append('https:' + i['url']) if 'https:' in i['url']: url.append(i['url']) item['url'] = url print(item['url']) # 评论网址 comment_url = [] ur = item['url'] comment_url.append(ur[0] + '#J_Reviews') item['comment_url'] = comment_url item['fastPostFee'] = i['fastPostFee'] item['sales'] = i['act'] item['price'] = i['price'] item['originalPrice'] = i['originalPrice'] item['nick'] = i['nick'] item['id'] = i['item_id'] item['loc'] = i['sellerLoc'] # 图片链接 img_url = [] img_url.append('http:' + i['img2']) item['img_url'] = img_url count_url = [] count_url.append('https://rate.taobao.com/detailCount.do?itemId=' + i['item_id']) for url in count_url: yield scrapy.Request( url, callback=self.detail_parse, meta=&#123;'item': copy.deepcopy(item)&#125;, # 使用copy.deepcopy深复制，否则数据不对啊 dont_filter=True, errback=self.error_back ) def detail_parse(self, response): item = response.meta['item'] pat_count = '&#123;\"count\":(.*?)&#125;' item['count'] = re.findall(pat_count, str(response.body)) yield item def error_back(self, e): _ = e self.logger.error(format_exc())'''['羽绒服', '毛呢大衣', '毛衣', '冬季外套', '新品', '裤子', '连衣裙', '腔调', '秋冬新品', '淘特莱斯', '淘先生', '拾货', '秋冬外套', '时尚套装', '潮牌', '爸爸装', '春新品', '性感诱惑', '甜美清新', '简约优雅', '奢华高贵', '运动风', '塑身', '基础内衣', '轻薄款', '长款', '短款', '毛领', '加厚', '被子', '鹅绒', '新品', '秋款', '夹克', '卫衣', '西装', '风衣', '皮衣', '毛呢外套', '薄羽绒', '无钢圈', '无痕文胸', '蕾丝内衣', '运动文胸', '聚拢文胸', '大码文胸', '抹胸式', '隐形', '廓形', '双面呢', '羊绒', '中长款', '短款', '毛领', '设计师款', '系带', 'T恤', '长袖T', '打底衫', '纯色', '衬衫', '长袖款', '商务款', '时尚款', '睡衣套装', '睡裙', '睡袍浴袍', '外穿家居', '女士睡衣', '男士睡衣', '情侣睡衣', '亲子睡衣', '马海毛', '貂绒', '羊绒', '羊毛', '开衫', '中长款', '短款', '卡通', '休闲裤', '工装裤', '运动裤', '长裤', '牛仔裤', '小脚裤', '哈伦裤', '直筒裤', '女士内裤', '男士内裤', '三角裤', '平角裤', '丁字裤', '阿罗裤', '星期裤', '低腰', '外套', '套装', '风衣', '卫衣', '真皮皮衣', '马甲', '小西装', '唐装', '中老年', '薄毛衣', '针织开衫', '圆领毛衣', 'V领毛衣', '纯色毛衣', '民族风', '羊毛衫', '羊绒衫', '船袜', '男人袜', '连裤袜', '隐形袜', '收腹裤', '塑身衣', '美体裤', '收腹带', '帆布鞋', '高帮', '低帮', '内增高', '懒人鞋', '厚底', '韩版', '系带', '情侣款', '运动风鞋', '厚底', '内增高', '星星鞋', '系带', '上新', '人气款', '单肩包', '斜挎包', '手提包', '迷你包', '手拿包', '小方包', '棒球帽', '鸭舌帽', '遮阳帽', '渔夫帽', '草帽', '平顶帽', '嘻哈帽', '贝雷帽', '牛仔帽', '爵士帽', '高跟', '平底', '厚底', '中跟', '粗跟', '坡跟', '浅口', '尖头', '圆头', '运动款', '头层牛皮', '内增高', '松糕鞋', '豆豆鞋', '商务', '休闲', '潮范', '胸包', '腰包', '单肩', '斜跨', '手提', '手拿', '帆布', '牛皮', '女士腰带', '男士皮带', '帆布腰带', '腰封', '腰链', '针扣头', '平滑扣', '自动扣', '真皮', '正品', '厚底', '内增高', '星星鞋', '系带', '一脚蹬', '魔术贴', '气垫', '网状', '印花', '铆钉', '水洗皮', '卡通', '原宿', '糖果色', '商务', '运动', '帆布', '牛皮', '女士围巾', '男士围巾', '披肩', '丝巾', '假领', '小方巾', '三角巾', '大方巾', '真丝', '雪纺', '棉质', '亚麻', '蕾丝', '青春潮流', '商务皮鞋', '休闲皮鞋', '正装皮鞋', '商务休闲', '布洛克', '内增高', '反绒皮', '真皮', '潮流低帮', '韩版', '英伦', '复古', '铆钉', '编织', '豹纹', '大头', '拉杆箱', '密码箱', '学生箱', '子母箱', '拉杆包', '万向轮', '飞机轮', '航空箱', '铝框', '女士手套', '男士手套', '真皮手套', '蕾丝手套', '防晒手套', '半指手套', '分指手套', '连指手套', '短款手套', '长款手套', '皮鞋', '低帮', '反绒皮', '大头鞋', '豆豆鞋', '帆船鞋', '懒人鞋', '帆布/板鞋', '高帮', '凉鞋/拖鞋', '沙滩鞋', '人字拖', '皮凉鞋', '洞洞鞋', '钱包', '潮包馆', '真皮包', '手机包', '大牌', 'coach', 'MK', 'MCM', '毛线', '鞋垫', '鞋带', '领带', '领结', '袖扣', '手帕', '布面料', '耳套', '领带夹', '婚纱配件', '皮带扣', '英国牛栏', '英国爱他美', '美赞臣', '雅培', '澳洲爱他美', '可瑞康', '惠氏', '贝因美', '推车', '驱蚊器', '婴儿床', '理发器', '奶瓶', '餐椅', '背带腰凳', '安全座椅', '内衣', '内裤', '喂奶枕', '收腹带', '妈咪包', '待产包', '防辐射服', '储奶袋', '米粉', '肉松', '磨牙棒', '果泥', '益生菌', '清火开胃', '钙铁锌', '维生素', '花王', 'moony', '大王', '帮宝适', '雀氏', '好奇', '妈咪宝贝', '安儿乐', '海淘奶粉', '海淘辅食', '海淘营养品', '直邮花王', '海淘洗护', '海淘奶瓶', '海淘餐具', '海淘孕产', 'T恤', '连衣裙', '泳装', '套装', '衬衫', '防晒服', '半身裙', '短裤', '凉鞋', '沙滩鞋', '洞洞鞋', '网鞋', '学步鞋', '拖鞋', '帆布鞋', '宝宝鞋', '母女裙', '父子装', '亲子T恤', '亲子衬衫', '亲子套装', '母女鞋', '父子鞋', '家庭鞋', '沙滩戏水', '早教启蒙', '拼插益智', '遥控模型', '运动户外', '学习爱好', '卡通公仔', '亲子互动', '电动车', '自行车', '学步车', '手推车', '三轮车', '滑板车', '扭扭车', '儿童轮滑', '早教机', '点读机', '健身架', '布书', '串/绕珠', '床/摇铃', '爬行垫', '木质拼图', '卸妆', '面膜', '洁面', '防晒', '面霜', '爽肤水', '眼霜', '乳液', '补水', '美白', '收缩毛孔', '控油', '祛痘', '祛斑', '去黑眼圈', '去黑头', 'BB霜', '粉底液', '唇膏', '隔离', '遮瑕', '指甲油', '粉饼', '彩妆套装', '女士香水', '男士香水', '中性香水', '淡香水', '古龙水', '香精', '复方精油', '香体乳', '洗发水', '护发素', '染发', '烫发', '造型', '假发', '洗护套装', '假发配件', '美胸', '纤体', '胸部护理', '身体护理', '塑身', '脱毛', '手部保养', '足部护理', '眼线', '睫毛膏', '眼影', '眉笔', '假睫毛', '眼霜', '双眼皮贴', '眼部护理', '劲能醒肤', '清洁面膜', '男性主义', '剃须膏', '男士套装', '男士防晒', '火山岩', '爽身走珠', '抗皱', '抗敏感', '保湿', '去眼袋', '滋润', '抗氧化', '深层清洁', '雅诗兰黛', '兰蔻', '资生堂', '自然乐园', 'SK-II', '悦诗风吟', '水宝宝', '契尔氏', '芦荟胶', '彩妆盘', '腮红', '香氛', '高光棒', '修容', 'V脸', '去角质', '洁面', '爽肤水', '精华', '乳液', '鼻贴', '马油', '牛肉干', '鲜花饼', '红枣', '糖果', '巧克力', '山核桃', '松子', '卤味', '饼干', '话梅', '蔓越莓', '薯片', '奇异果', '芒果', '樱桃', '橙子', '秋葵', '苹果', '番茄', '柠檬', '椰子', '榴莲', '大米', '橄榄油', '小米', '黄豆', '赤豆', '火腿', '香肠', '木耳', '香菇', '豆瓣酱', '海参', '龙虾', '瑶柱', '土鸡', '牛排', '三文鱼', '咸鸭蛋', '皮蛋', '五花肉', '北极贝', '鸡尾酒', '红酒', '啤酒', '白酒', '梅酒', '洋酒', '清酒', '滋补酒', '茅台', '五粮液', '麦片', '咖啡', '牛奶', '柚子茶', '酸梅汤', '矿泉水', '酵素', '藕粉', '姜茶', '酸奶粉', '铁观音', '红茶', '花草茶', '龙井', '普洱', '黑茶', '碧螺春', '毛峰', '袋泡茶', '白茶', '枸杞', '人参', '石斛', '燕窝', '雪蛤', '蜂蜜', '天麻', '花粉', '党参', '红花', '芒果干', '鱼子酱', '咖啡', '橄榄油', '薯片', '巧克力', '咖喱', '方便面', '红酒', '麦片', '项链', '手链', '戒指', '发饰', '银饰', '水晶', '耳饰', '手镯', '翡翠', '彩宝', '蜜蜡', '裸钻', '珍珠', '黄金', '钻石', '金条', '和田玉', '翡翠', '水晶/佛珠', '黄金', '手表', '眼镜', '瑞士表', '机械表', '时装表', '儿童表', '电子表', '情侣表', '石英表', '手表配件', '太阳镜', '偏光镜', '近视镜', '司机镜', '护目镜', '眼镜配件', '运动镜', '老花镜', 'zippo', '电子烟', '烟斗', '瑞士军刀', '绝美酒具', '风格男表', '佛珠', '水晶', '碧玺', '925银', '施华洛', '翡翠', '珍珠', '黄金', '银项链', '流行风格', '天然水晶', '锆石水晶', '佛珠项链', '人造水晶', '925银', '翡翠', '和田玉', '复古泰银', '粉晶手镯', '黄金手镯', '日韩', '甜美', '复古/宫廷', '欧美', '瑞丽', '波西米亚', '民族风', '发饰', '项链', '套装', '耳饰', '韩式', '头饰', '三件套', '合金配件', '银饰', '水晶配珠', '琉璃', '珍珠母贝', '有机玻璃', '人造水晶', '设计师', '半包装修', '全包装修', '全案装修', '装修监理', '清包施工', '局部装修', '验房量房', '装修空气质量检测', '装修污染治理', '整体橱柜', '定制衣柜', '定制吊顶', '定制淋浴房', '门', '窗', '定制柜', '楼梯', '榻榻米定制', '地暖', '吸顶灯', '吊灯', '吸吊两用灯', '筒灯', '射灯', '台灯', '落地灯', '室外灯', '壁灯', '小夜灯', '浴室柜', '普通马桶', '花洒套装', '一体智能马桶', '智能马桶盖板', '淋浴房', '面盆龙头', '地漏', '五金挂件', '浴霸', 'PVC墙纸', '无纺布墙纸', '纯纸墙纸', '墙布', '沙粒墙纸', '绒面墙纸', '定制壁画', '3D墙纸', '实木地板', '实木复合地板', '强化复合地板', '竹地板', '户外地板', 'PVC地板', '防静电地板', '防潮膜', '踢脚线', '地板龙骨', '仿古砖', '釉面砖', '玻化砖', '微晶石', '马赛克', '抛晶砖', '通体砖', '花片', '腰线', '瓷砖背景墙', '插座', '开关', '电线', '监控器材', '智能家居', '防盗报警器材', '消防报警设备', '接线板插头', '布线箱', '断路器', '涂料乳胶漆', '油漆', '水管', '板材', '木方', '阳光房', '线条', '天然大理石', '人造大理石', '防水涂料', '实木床', '布艺床', '皮艺床', '床垫', '衣柜', '斗柜', '梳妆台', '子母床', '床头柜', '儿童床', '皮艺沙发', '布艺沙发', '沙发床', '实木沙发', '懒人沙发', '电视柜', '茶几', '鞋柜', '玄关厅', '衣帽架', '餐桌', '折叠餐桌', '欧式餐桌', '实木餐桌', '大理石餐桌', '餐椅', '餐边柜', '换鞋凳', '角柜', '屏风', '餐桌', '折叠餐桌', '欧式餐桌', '实木餐桌', '大理石餐桌', '餐椅', '餐边柜', '换鞋凳', '角柜', '屏风', '蚊帐', '三开蚊帐', '凉席', '凉席套件', '冰丝席', '藤席', '牛皮席', '夏凉被', '空调被', '天丝套件', '床单', '床笠', '四件套', '全棉套件', '被套', '蚕丝被', '羽绒被', '枕头', '乳胶枕', '记忆枕', '床褥', '毛毯', '定制窗帘', '地毯', '沙发垫', '靠垫', '桌布桌旗', '飘窗垫', '地垫', '餐垫', '防尘罩', '椅垫', '成品窗帘', '沙发罩', '摆件', '花瓶', '仿真花', '台钟闹钟', '香薰炉', '储物罐', '装饰碗盘', '木雕', '烟灰缸', '纸巾盒', '蜡烛烛台', '仿真饰品', '现代装饰画', '无框画', '后现代画', '油画', '挂钟', '照片墙', '新中式', '北欧家饰', '美式乡村', '挂钩搁板', '装饰挂钩', '壁饰', '扇子', '毛巾', '浴巾', '口罩', '隔音耳塞', '竹炭包', '眼罩', '夏季凉拖', '居家鞋', '夏季清凉', '湿巾', '晴雨伞', '驱蚊灯', '驱蚊液', '冰格', '保鲜产品', '密封罐', '防潮制品', '电扇/冰垫', '5元小物', '被子防尘袋', '收纳盒', '收纳袋', '大衣/西服罩', '护洗袋', '收纳凳', '鞋柜', '置物架', '桌用收纳', '内衣收纳', '洗发护发', '沐浴露', '漱口水', '卫生巾', '洗手液', '牙膏', '纸巾', '香皂', '沐浴球/浴擦/浴刷', '指甲刀', '剃须刮毛刀', '沐浴球', '浴室角架', '浴帘杆', '拖把', '垃圾桶', '梳子镜子', '围裙', '百洁布', '海绵擦', '餐具', '锅具', '刀具', '炖锅', '蒸锅', '汤锅', '煎锅', '压力锅', '炒锅', '菜板砧板', '一次性餐桌用品', '酒杯酒具', '咖啡器具', '碗盘碟', '刀叉勺', '餐具瓷器套装', '餐桌小物', '饭盒', '厨房储物', '一次性餐桌用品', '茶具', '茶壶', '飘逸杯', '功夫茶杯', '玻璃杯', '杯垫', '保温杯', '马克杯', '保温壶', '情侣杯', '晒衣篮', '晾衣杆', '脏衣篮', '衣架', '家庭清洁剂', '蓝泡泡', '管道疏通器', '塑胶手套', '医药箱', '垃圾袋', '汽车首页', '新车先购', '车海淘', '二手车', '爱车估价', 'suv', '别克', '大众', '宝马', '座垫', '座套', '脚垫', '香水', '旅行床', '遮阳挡', '挂件摆件', '安全座椅', '专车专用座垫', '脚垫', '安全座椅', '香水', '钥匙包', '挂件', '座套', '后备箱垫', '置物箱', '智能车机', '后视镜', '安卓导航', '便携GPS', 'DVD导航', '电子狗', '流动测速', '导航软件', '记录仪', '预警仪', 'GPS', '车机', '倒车雷达', '智能后视镜', '蓝牙', '防盗器', 'MP3', '4S保养', '电瓶安装', '配件安装', '隔热膜', '洗车卡', '镀晶镀膜', '连锁保养', '上门服务', '行车记录仪', '逆变器', '跟踪器', '充电器', '充气泵', '胎压监测', '车载冰箱', '空气净化', '车衣', 'SUV踏板', '晴雨挡', '改色膜', '汽车车标', '车牌架', '轮胎', '雨刮器', '机油滤芯', '空气滤芯', '空调滤芯', '减震', '刹车片', '火花塞', '轮胎', '雨刮', '机油', '高亮大灯', '挡泥板', '保险杠', '车顶架', '轮眉', '轮毂', '排气', '保险杠', '汽车包围', '氙气灯', '车顶架', '脚踏板', '大灯总成', '尾翼', '轮毂', '汽车装饰灯', '排气筒', '尾喉', '车身饰条', '添加剂', '防冻液', '玻璃水', '车蜡', '补漆笔', '洗车机', '洗车水枪', '车掸蜡拖', '车蜡', '洗车机', '补漆笔', '抛光机', '打蜡海绵', '车用水桶', '擦车巾', '车刷', '装饰条', '车贴', '尾喉', '改色膜', '防爆膜', '晴雨挡', '日行灯', '车衣', '夏季座垫', '遮阳挡', '防眩蓝镜', '防晒手套', 'iPhone', '小米', '华为', '三星', '魅族', '纽扣', '酷派', 'VIVO', 'iPad', '小米', '三星', '10寸', '台电', 'win8', '蓝魔', '华为', 'DIY电脑', '一体机', '路由器', '显示器', '学生', 'CPU', '移动硬盘', '无线鼠标', '苹果', '联想', 'Thinkpad', '戴尔', '华硕', 'Acer', '神州', '三星', '单反', '自拍神器', '拍立得', '佳能', '微单', '镜头', '卡西欧', '尼康', '充电宝', '智能穿戴', '蓝牙耳机', 'iPhone6壳', '电脑包', '手机贴膜', '手机壳套', '三脚架', '保护壳套', '炫彩贴膜', '移动电源', '相机配件', '手机零件', '自拍神器', '移动POS支付', '电池', '儿童手表', 'Apple Watch', '智能手表', '智能手环', '智能配饰', '智能健康', '智能排插', '智能眼镜', '游戏掌机', '家用游戏机', '游戏手柄', 'PS主机', 'XBOX', '任天堂配件', 'PS主机配件', 'XBOX配件', '路由器', '网关', '交换机', '光纤设备', '网络存储设备', '无线上网卡', 'TP-LINK', '小米路由器', 'MP3', 'MP4', '录音笔', '索尼', '飞利浦', 'ipod', '爱国者', '耳机', 'U盘', '闪存卡', '记忆棒', '移动硬盘', '希捷', '三星', 'Sandisk', '金士顿', '电磁炉', '电水壶', '料理机', '电饭煲', '榨汁机', '净水器', '豆浆机', '烤箱', '电风扇', '空调扇', '挂烫机', '扫地机', '吸尘器', '加湿器', '除湿机', '对讲机', '空气净化', '理发器', '电子称', '美容仪', '按摩椅', '按摩披肩', '血压计', '足浴器', '电动牙刷', '剃须刀', '耳机', '音响', '网络机顶盒', '麦克风', '扩音器', 'HiFi套装', '蓝光DVD', '低音炮', '打印机', '投影仪', '硒鼓墨盒', 'A4纸', '一体机', '学生文具', '保险柜', '电纸书', '学习机', '冰箱', '空调', '平板电视', '油烟机', '燃气灶', '消毒柜', '厨电套装', '热水器', '洗衣机', '包装设备', '包装纸箱', '塑料袋', '包装胶带', '铭牌', '快递袋', '气泡膜', '真空机', '笔记本', '文件袋', '钢笔', '胶粘用品', '铅笔', '计算器', '白板', '台历', '设计定制', '企业用品定制', 'T恤印制', '杯子定制', 'ppt模板', '班服定制', '洗照片', '人偶定制', '电子电工', '气动元件', '水泵', '阀门', '电钻', '焊接设备', '万用表', '雕刻机', '办公家具', '商业设施', '办公桌', '陈列柜', '货架', '广告牌', '文件柜', '沙发', '网络设备', '电子元器件', '路由器', '交换机', '光纤设备', '视频会议', '无线安全保密', '机柜', '餐饮美食', '冰淇淋', '火锅', '购物卡券', '体检配镜', '美容美甲', '保险理财', '婚纱摄影', '旅行团购', '住在帝都', '住在魔都', '住在杭州', '住在南京', '住在广州', '住在青岛', '住在宁波', '住在成都', '少儿英语', '小学教育', '潜能开发', '家长训练', '孕产育儿', '少儿绘画', '婴幼早教', '音乐', 'Q币充值', '点卡充值', '充游戏币', '游戏代练', '超值账号', '手游充值', '电竞比赛', '游戏帮派', '潇洒一室', '靠谱二室', '舒适三房', '大四室', '私藏别墅', '景观居所', '轨道沿线', '学区房', '实用英语', '网站制作', 'IT技能', '会计职称', '一对一', '办公软件', '日语', '编程', '英雄联盟', '剑侠情缘3', '征途2', '魔域', '我叫MT', '刀塔传奇', 'DOTA2', 'DNF', '魔兽世界', '自助餐', '个性写真', '儿童写真', '电影票团购', '上门服务', '周边旅游', '境外旅游', '基金理财', '魅力健身', '时尚美妆', '手工DIY', '舞蹈', '减肥瑜伽', '个人形象', '美剧英语', '摄影', '美女陪练', '轻松甩肉', '基金理财', '淘宝美工', '办公技能', '婚纱摄影', '婚礼策划', '三亚婚拍', '厦门婚拍', '青岛婚拍', '北京婚拍', '杭州婚拍', '上海婚拍', '新娘跟妆', '婚礼跟拍', '婚礼司仪', '婚车租赁', '任意洗', '洗外套', '洗西装', '洗鞋', '洗四件套', '洗烫衬衫', '皮包护理', '洗窗帘', '洗地毯', '在线洗衣', '洗礼服', '洗玩具', '开荒保洁', '厨房保洁', '公司保洁', '家电清洗', '空调清洗', '洗油烟机', '冰箱清洗', '擦玻璃', '家政服务', '家庭保洁', '保洁服务', '钟点工', '洗衣机清洗', '卫生间保洁', '上门养车', '洗车', '封釉镀膜', '内饰清洗', '空调清洗', '汽车维修', '充加油卡', '年检代办', '玻璃贴膜', '汽车装饰', '底盘装甲', '四轮定位', '汽车改装', '违章代办', '汽车隔音', '上门按摩', '常规体检', '入职体检', '老人体检', '四维彩超', '孕前检查', '体检报告', '专业洗牙', '烤瓷牙', '胃部检测', '月嫂', '催乳师', '育儿嫂', '营养师', '普通保姆', '涉外保姆', '产后陪护', '临时看护', '管家', '烧饭阿姨', '宠物寄养', '宠物美容', '宠物配种', '宠物洗澡', '宠物摄影', '宠物托运', '宠物训练', '宠物医疗', '水族服务', '宠物绝育', '宠物洗牙', '宠物造型', '宠物体检', '居家搬家', '公司搬运', '空调拆装', '家电搬运', '家具搬运', '打孔', '电路维修', '甲醛测试', '开锁换锁', '杀虫消毒', '高空清洁', '除尘除螨', '网上办事', '代缴费', '代排队', '交罚单', '叫醒服务', '宝宝起名', '学车报名', '代邮代取', '话费充值', '代送鲜花', '水电煤缴费', '同城速递', '代办档案', '宽带费', '机场停车', '专利申请', '法律咨询', '专业翻译', '开发建站', '图片处理', '视频制作', '名片制作', '商标转让', '打印', '复印', '商标注册', '私人律师', '合同文书', '出国翻译', '手机维修', 'pad维修', '修台式机', '相机维修', '修笔记本', '修复印机', '修游戏机', '修导航仪', '软件服务', '延保服务', '硬件维修', '苹果维修', '小米维修', '三星维修', '安卓刷机', '数据恢复', '电脑维修', 'ipad维修', '华为维修', '重装系统', '家电维修', '相机维修', '硬盘维修', '苹果换屏', '换主板', '名企招聘', '高薪岗位', '文案编辑', '网店推广', '开发技术', '活动策划', '美工设计', '金牌客服', '大促客服', '网页设计', '人才认证', '图片设计', '摄影师', '店长', '运营主管', '客服主管', '美工主管', '跑步鞋', '篮球鞋', '休闲鞋', '足球鞋', '帆布鞋', '训练鞋', '徒步鞋', '登山鞋', '限量版', '板鞋', 'Rosherun', '运动套装', '运动卫衣', '长裤', '皮肤风衣', '健身服', '球服', '耐克', '阿迪达斯', '三叶草', '美津浓', '彪马', '狼爪', '山地车', '公路车', '骑行服', '头盔', '装备', '零件', '工具', '护具', '折叠车', '死飞', '水壶架', '行李架', '羽毛球拍', '羽毛球服', '羽毛球', '网球拍', '篮球', '篮球服', '足球', '足球服', '乒乓球拍', '橄榄球', '台球', '高尔夫', '吊床', '头灯', '遮阳棚', '望远镜', '照明', '野营帐篷', '野外照明', '烧烤炉', '望远镜', '潜水镜', '防潮垫', '皮划艇', '皮肤衣', '防晒衣', '冲锋衣', '探路者', '速干裤', '迷彩服', '战术靴', '登山鞋', 'crocs', '溯溪鞋', '户外鞋', '麻将机', '轮滑', '麻将', '象棋', '雀友', '飞镖', '桌上足球', '风筝', '陀螺', '空竹', '沙袋', '太极服', '甩脂机', '轮滑装备', '跑步机', '舞蹈', '瑜伽', '哑铃', '仰卧板', '踏步机', '划船机', '卧推器', '健身车', '呼啦圈', '舞蹈', '瑜伽', '广场舞', '舞蹈鞋', '拉丁鞋', '广场舞套装', '肚皮舞服装', '瑜伽垫', '瑜伽球', '瑜伽服', '鱼饵', '套装', '路亚', '附件', '鱼钩', '钓鱼工具', '船/艇', '台钓竿', '海钓竿', '溪流竿', '路亚竿', '矶钓杆', '单肩背包', '旅行包', '双肩背包', '挎包', '户外摄影包', '头巾', '运动水壶', '防水包', '电池', '电自行车', '平衡车', '滑板车', '头盔', '摩托车', '老年代步', '独轮车', '遮阳伞', '扭扭车', '折叠车', '仿真植物', '干花', 'DIY花', '手捧花', '鲜果蓝', '仿真蔬果', '开业花篮', '花瓶', '绿植同城', '园艺方案', '多肉植物', '桌面盆栽', '蔬菜种子', '水培花卉', '苔藓景观', '空气凤梨', '肥料', '花盆花器', '花卉药剂', '营养土', '园艺工具', '洒水壶', '花架', '铺面石', '热带鱼', '孔雀鱼', '底栖鱼', '虾螺', '龙鱼', '罗汉鱼', '锦鲤', '金鱼', '水母', '灯科鱼', '乌龟', '水草', '底砂', '水草泥', '沉木', '仿真水草', '假山', '氧气泵', '过滤器', '水草灯', '加热棒', '鱼粮', '水质维护', '硝化细菌', '除藻剂', '龟粮', '兔兔', '仓鼠', '龙猫', '雪貂', '粮食零食', '医疗保健', '笼子', '鹦鹉', '鸟笼', '观赏鸟', '蚂蚁工坊', '蜘蛛', '蚕', '大牌狗粮', '宠物服饰', '狗厕所', '宠物窝', '航空箱', '海藻粉', '羊奶粉', '宠物笼', '储粮桶', '剃毛器', '营养膏', '上门服务', '全新钢琴', '智能钢琴', '中古钢琴', '尤克里里', '民谣吉他', '萨克斯风', '口琴', '小提琴', '高达', '手办', '盒蛋', '兵人', '变形金刚', '圣衣神话', '钢铁侠', 'BJD', '拼装', '人偶', '猫砂', '猫粮', '猫爬架', '猫窝', '猫砂盆', '化毛膏', '猫罐头', '喂食器', '折耳猫', '猫抓板', '猫玩具', '猫笼', '古筝', '二胡', '葫芦丝', '战鼓', '古琴', '陶笛', '琵琶', '笛子', '动漫T恤', '动漫抱枕', 'COS', '背包', '项链', '颜文字', '哆啦A梦', '大白', '手表', '盗墓笔记', '海贼', '火影', 'LOL', '杀菌剂', '杀虫剂', '除草剂', '调节剂', '杀螨剂', '杀鼠剂', '敌敌畏', '草甘膦', '园林种苗', '动物种苗', '蔬菜种苗', '水果种苗', '粮油种子', '药材种苗', '食用菌种', '辣木籽', '氮肥', '磷肥', '钾肥', '叶面肥', '新型肥料', '复合肥', '生物肥料', '有机肥', '耕种机械', '收割机械', '农机配件', '植保机械', '拖拉机', '施肥机械', '粮油设备', '微耕机', '塑料薄膜', '大棚膜', '防渗膜', '鱼塘专用', '薄膜', '遮阳网', '篷布', '防虫网', '镰刀', '锹', '高压水枪', '锨', '镐', '耙子', '锄头', '叉', '猪饲料', '羊饲料', '牛饲料', '预混料', '饲料原料', '全价料', '饲料添加剂', '浓缩料', '加工设备', '养殖器械', '渔业用具', '养殖服务', '配种服务', '养鸡设备', '挤奶机', '母猪产床', '化学药', '中兽药', '抗生素', '驱虫', '消毒剂', '疫苗', '阿莫西林', '氟苯尼考']''' 说明几点： 在使用 meta 传递数据的时候，要使用 copy.deepcopy 深复制，详情查阅 【scrapy】item传递出错 关于搜索词。因为淘宝对搜索结果只会返回100页，所以我们这里增加索引词，来获得更多数据。可以在代码末尾发现更多关键词，有1000多个，这个list是从这里获得 淘宝首页行业市场 反爬处理呃呃，有意思的是，自己跑了一会获得了几万条数据，并没有任何的异常，没有在 middlewares.py 加代理，连 UA 都是固定的，好奇怪。 可能长得帅的人品都比较好吧。 展示数据mongo 中的数据 数据并不直观，所以我们选择展示出来，做一个小小的聚合搜索 同样看看主文件 server.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# -*- coding: UTF-8 -*-from flask import Flask, request, session, g, redirect, url_for, \\ abort, render_template, flashfrom bson import json_utilfrom bson.objectid import ObjectIdimport jsonimport pymongoconn = pymongo.MongoClient('localhost', 27017)db = conn['taobao']goods_coll = db['search']cate_coll = db['categories']app = Flask(__name__)def toJson(data): return json.dumps( data, default=json_util.default, ensure_ascii=False )@app.errorhandler(404)def page_not_found(e): return render_template('404.html'), 404@app.route('/', methods=['GET'])def index(): if request.method == 'GET': total = goods_coll.count() return render_template('index.html', total=total) #if request.form['key']: # key = request.form['key'] # return redirect(url_for('get_goods', key=key, page=1))@app.route('/search', methods=['GET'])@app.route('/search/&lt;item&gt;', methods=['GET'])def get_goods(item=None): if request.method == 'GET': page = request.args.get('page', 1, type=int) limit = request.args.get('limit', 30, type=int) p = (page - 1) * limit offset = request.args.get('offset', p, type=int) catid = request.args.get('catid', None, type=str) jsons = request.args.get('json', 'off') keyword = request.args.get('key', '') if not keyword: keyword = item if catid: cursor = goods_coll.find(&#123;'categories.catid': catid&#125;) else: cursor = goods_coll.find(&#123;'title': &#123;'$regex': keyword&#125; &#125;) #total = cursor.count() #flash('已查询到 %d 个结果.'%total) results = cursor.skip(offset).limit(limit) resultList = [] for result in results: resultList.append(result) if jsons == 'off': return render_template('search.html', entries=resultList) else: return toJson(resultList)if __name__ == '__main__': #app.run(host='0.0.0.0') app.run(debug=True) 这里是借鉴了别人的项目，地址在这 1dot75cm/taobaobao 您可以自定义在 \\templates目录下修改对应的html文件 12λ ls404.html categories.html index.html layout.html search.html 直接运行 server.py 12345λ piython server.py * Restarting with stat * Debugger is active! * Debugger PIN: 503-651-032 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) 打开 http://127.0.0.1:5000/ 即可查看结果 To Do 数据去重 价格及销量可视化展示 速度太慢，应使用分布式 评论采集 加强爬虫的反爬措施 Github ： zhangslob/Taobao_duoshou 万水千山总是情，给个star行不行 参考 1dot75cm/taobaobao 【scrapy】item传递出错","tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://zhangslob.github.io/tags/爬虫/"},{"name":"Scrapy","slug":"Scrapy","permalink":"https://zhangslob.github.io/tags/Scrapy/"},{"name":"Flask","slug":"Flask","permalink":"https://zhangslob.github.io/tags/Flask/"},{"name":"淘宝","slug":"淘宝","permalink":"https://zhangslob.github.io/tags/淘宝/"}]},{"title":"Scrapy学习实例（三）采集批量网页","date":"2017-12-12T13:11:17.000Z","path":"2017/12/12/Scrapy学习实例（三）采集批量网页/","text":"这是崔斯特的第十九篇原创文章 先来首火影压压惊 (｡・`ω´･) 最开始接触 Rules是在Scrapy的文档上看到的，但是并看读懂这是什么意思。接下来看别人的案例，有使用到Rules，便花了很多时间去了解。 解释：Rule是在定义抽取链接的规则，上面的两条规则分别对应列表页的各个分页页面和详情页，关键点在于通过restrict_xpath来限定只从页面特定的部分来抽取接下来将要爬取的链接。 其实用我的话来说就是，一个是可以便捷的进行翻页操作，二是可以采集二级页面，相当于打开获得详情页内容。所以若使用了 Rules，可以便捷的帮助我们采集批量网页。 官方文档CrawlSpider示例 12345678910111213141516171819202122232425import scrapyfrom scrapy.spiders import CrawlSpider, Rulefrom scrapy.linkextractors import LinkExtractorclass MySpider(CrawlSpider): name = 'example.com' allowed_domains = ['example.com'] start_urls = ['http://www.example.com'] rules = ( # Extract links matching 'category.php' (but not matching 'subsection.php') # and follow links from them (since no callback means follow=True by default). Rule(LinkExtractor(allow=('category\\.php', ), deny=('subsection\\.php', ))), # Extract links matching 'item.php' and parse them with the spider's method parse_item Rule(LinkExtractor(allow=('item\\.php', )), callback='parse_item'), ) def parse_item(self, response): self.logger.info('Hi, this is an item page! %s', response.url) item = scrapy.Item() item['id'] = response.xpath('//td[@id=\"item_id\"]/text()').re(r'ID: (\\d+)') item['name'] = response.xpath('//td[@id=\"item_name\"]/text()').extract() item['description'] = response.xpath('//td[@id=\"item_description\"]/text()').extract() return item 该spider将从example.com的首页开始爬取，获取category以及item的链接并对后者使用 parse_item 方法。 对于每个item response，将使用XPath从HTML中提取一些数据，并使用它填充Item。 实际应用为了更好的理解，我们来看看实际案例中Rules如何使用 豆瓣应用12345rules = [Rule(LinkExtractor(allow=(r'https://movie.douban.com/top250\\?start=\\d+.*'))), Rule(LinkExtractor(allow=(r'https://movie.douban.com/subject/\\d+')), callback='parse_item', follow=False)] 如果接触过django，那么可以发现这个规则与django的路由系统十分相似（django都已经忘完了 -_-！），其实这里使用的正则匹配。 使用 r&#39;https://movie.douban.com/top250\\?start=\\d+.*&#39;来匹配翻页链接，如： https://movie.douban.com/top250?start=25&amp;filter= https://movie.douban.com/top250?start=50&amp;filter= 使用https://movie.douban.com/subject/\\d+来匹配具体电影的链接，如： https://movie.douban.com/subject/1292052/ https://movie.douban.com/subject/1291546/ 链家应用爬虫的通常需要在一个网页里面爬去其他的链接，然后一层一层往下爬，scrapy提供了LinkExtractor类用于对网页链接的提取，使用LinkExtractor需要使用CrawlSpider爬虫类中，CrawlSpider与Spider相比主要是多了rules，可以添加一些规则，先看下面这个例子，爬取链家网的链接 1234567891011121314151617181920212223from scrapy.spiders import CrawlSpider, Rulefrom scrapy.linkextractors import LinkExtractorclass LianjiaSpider(CrawlSpider): name = \"lianjia\" allowed_domains = [\"lianjia.com\"] start_urls = [ \"http://bj.lianjia.com/ershoufang/\" ] rules = [ # 匹配正则表达式,处理下一页 Rule(LinkExtractor(allow=(r'http://bj.lianjia.com/ershoufang/pg\\s+$',)), callback='parse_item'), # 匹配正则表达式,结果加到url列表中,设置请求预处理函数 # Rule(FangLinkExtractor(allow=('http://www.lianjia.com/client/', )), follow=True, process_request='add_cookie') ] def parse_item(self, response): # 这里与之前的parse方法一样，处理 pass 同样的，使用r&#39;http://bj.lianjia.com/ershoufang/pg\\s+$&#39;来匹配下一页链接，如： https://bj.lianjia.com/ershoufang/pg2/ https://bj.lianjia.com/ershoufang/pg3/ 还可以使用 r&#39;https://bj.lianjia.com/ershoufang/\\d+.html&#39;来匹配详情页链接，如： https://bj.lianjia.com/ershoufang/101102126888.html https://bj.lianjia.com/ershoufang/101100845676.html 学习参数Rule对象Role对象有下面参数 link_extractor：链接提取规则 callback：link_extractor提取的链接的请求结果的回调 cb_kwargs：附加参数，可以在回调函数中获取到 follow：表示提取的链接请求完成后是否还要应用当前规则（boolean），如果为False则不会对提取出来的网页进行进一步提取，默认为False process_links：处理所有的链接的回调，用于处理从response提取的links，通常用于过滤（参数为link列表） process_request：链接请求预处理（添加header或cookie等） LinkExtractorLinkExtractor常用的参数有： allow：提取满足正则表达式的链接 deny：排除正则表达式匹配的链接（优先级高于allow） allow_domains：允许的域名（可以是str或list） deny_domains：排除的域名（可以是str或list） restrict_xpaths：提取满足XPath选择条件的链接（可以是str或list） restrict_css：提取满足css选择条件的链接（可以是str或list） tags：提取指定标签下的链接，默认从a和area中提取（可以是str或list） attrs：提取满足拥有属性的链接，默认为href（类型为list） unique：链接是否去重（类型为boolean） process_value：值处理函数（优先级大于allow） 关于LinkExtractor的详细参数介绍见官网 注意：在编写抓取Spider规则时，避免使用parse作为回调，因为CrawlSpider使用parse方法自己实现其逻辑。因此，如果你覆盖parse方法，爬行Spider将不再工作。 最后说一个自己犯过的低级错误，我用Scrapy有个习惯，创建一个项目之后，直接cd目录，然后使用genspider命令，然后。。 12345678910111213141516D:\\Backup\\桌面λ scrapy startproject exampleNew Scrapy project 'example', using template directory 'c:\\\\users\\\\administrator\\\\appdata\\\\local\\\\programs\\\\python\\\\python36\\\\lib\\\\site-packages\\\\scrapy\\\\templates\\\\project', created in: D:\\Backup\\桌面\\exampleYou can start your first spider with: cd example scrapy genspider example example.comD:\\Backup\\桌面λ cd exampleD:\\Backup\\桌面\\exampleλ scrapy genspider em example.comCreated spider 'em' using template 'basic' in module: example.spiders.em 然后我的em.py就变成了这样： 1234567891011# -*- coding: utf-8 -*-import scrapyclass EmSpider(scrapy.Spider): name = 'em' allowed_domains = ['example.com'] start_urls = ['http://example.com/'] def parse(self, response): pass 注意，这个时候是不能使用Rules方法的，因为object不对，应该是 class EmSpider(CrawlSpider) 而不是class EmSpider(scrapy.Spider): 共勉！！！ 下一节应该会讲到Scrapy中各个组件的作用，以及这张神图 参考： CrawlSpider示例 scrapy学习笔记","tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://zhangslob.github.io/tags/爬虫/"},{"name":"Scrapy","slug":"Scrapy","permalink":"https://zhangslob.github.io/tags/Scrapy/"},{"name":"Rules","slug":"Rules","permalink":"https://zhangslob.github.io/tags/Rules/"}]},{"title":"统计学学习笔记（二）数据整理与展示","date":"2017-12-06T14:19:18.000Z","path":"2017/12/06/统计学学习笔记（二）数据整理与展示/","text":"这是崔斯特的第十八篇原创文章 这是统计学的第二篇笔记，主要记录了如何整理数据与展示数据，书本上是这样说，但是我觉得现在人们会更多的叫做数据清洗与数据可视化。命名无所谓，掌握方法就好。 下面是正文。 可以接着这里看哦 统计学学习笔记（一） 数据整理与展示3.1 数据的预处理3.1.1 数据审核 概念：检查数据是否有错误 对于通过调查取得的原始数据，主要从完整性和准确性两个方面去审核 对于通过其他渠道获得的二手数据，主要审核数据的适用性和时效性 3.1.2 数据筛选 删除某些不符合要求的数据和有明显错误的数据 将符合某种特定条件的数据筛选出来，而将不符合特定条件的数据予以剔除 Excel举例 3.1.3 数据排序 概念：按一定顺序将数据排列，以便于研究者通过数据发现一些明显的特征或趋势，找到解决问题的线索 通过数据类型选择排序方式：字母型数据、汉字型数据、数值型数据 这个好像也叫做数据清洗 3.2 品质数据的整理与展示3.2.1 频数与频数分布 落在某一特定类别中的数据个数，成为频数 把各个类别及落在其中的相应频数全部列出，并用表格形式表现出来，成为频数分布 好像不止表格吧 一个总体（或样本）中各个部分的数据与全部数据之比，成为比例 将比例乘以100得到的数值，成为百分比或百分数用%表示 总体（或样本）中各不同类别数值之间的比值，成为比率 3.2.2 品质数据的展示 条形图 饼图 环形图 3.3 数值型数据的整理与展示3.3.1 数据分组 根据统计分析的需要，将原始数据按照某种标准划分成不同的组别，成为数据分组 在组距分组中，一个组的最小值称为下限，一个组的最大值称为上限 每一组的上限和下限之间的中间值称为组中值 3.3.2 数值型数据的图示 分组数据看分布：直方图（histogram） 未分组数据看分布：茎叶图和箱型图 多变量数据的展示：雷达图 3.4 使用图表的注意事项优秀图表特征： 显示数据 让读者把注意力放在图表内容上 避免歪曲 强调数据之间的比较 服务于一个明确的目的 有对图形的描述统计和文字说明 优秀图形应当： 精心设计，有助于洞察问题的实质 使复杂的观点得到简明、确切、高效的阐述 能在最短的时间内、以最少的笔墨给读者提供大量的信息 是多维的 表述数据的真实情况 品质数据您应该会和我一样提问，什么是品质数据？ 品质数据:对产品或商品进行各种化学、物理、力学等试验后所得出的数据。 品质数据：对产品或商品进行各种化学、物理、力学等试验后所得出的数据。 品质型数据：按品质标志分组所得到数据，包括分类数据和顺序数据，他们在整理和图形展示上的方法大体相同。 本文中提到的品质数据应该是后者 数据可视化这里重点说下数据图表的选择。 就我自己的工作中，比较常用的就是直方图、折线图与饼图，词云图（如果算的话）。教材中也说了很多没用过的图，这个东西还是要根据自己的具体业务来操作。 这里推荐一个很好的网站，图表使用 这个网站有多好，你一看便知，不多解释。 数据清洗有人说：一个分析项目基本八成时间在洗数据。那么什么是清洗数据。 数据清洗是指发现并纠正数据文件中可识别的错误的最后一道程序，包括检查数据一致性，处理无效值和缺失值等。与问卷审核不同，录入后的数据清理一般是由计算机而不是人工完成。 数据清洗的方法 解决不完整数据（ 即值缺失）的方法 错误值的检测及解决方法 重复记录的检测及消除方法 不一致性（ 数据源内部及数据源之间）的检测及解决方法 转换构造 数据压缩 老规矩，还是放一点代码 123456789101112131415161718192021222324252627282930313233343536373839import numpy as npimport matplotlib.pyplot as pltimport matplotlib.patches as patchesimport matplotlib.path as pathfig, ax = plt.subplots()# Fixing random state for reproducibilitynp.random.seed(19680801)# histogram our data with numpydata = np.random.randn(1000)n, bins = np.histogram(data, 50)# get the corners of the rectangles for the histogramleft = np.array(bins[:-1])right = np.array(bins[1:])bottom = np.zeros(len(left))top = bottom + n# we need a (numrects x numsides x 2) numpy array for the path helper# function to build a compound pathXY = np.array([[left, left, right, right], [bottom, top, top, bottom]]).T# get the Path objectbarpath = path.Path.make_compound_path_from_polys(XY)# make a patch out of itpatch = patches.PathPatch(barpath)ax.add_patch(patch)# update the view limitsax.set_xlim(left[0], right[-1])ax.set_ylim(bottom.min(), top.max())plt.show() 参考 数据清洗 数据挖掘中常用的数据清洗方法有哪些？","tags":[{"name":"统计学","slug":"统计学","permalink":"https://zhangslob.github.io/tags/统计学/"},{"name":"数据","slug":"数据","permalink":"https://zhangslob.github.io/tags/数据/"}]},{"title":"Scrapy学习实例（二）采集无限滚动页面","date":"2017-12-03T11:48:53.000Z","path":"2017/12/03/Scrapy学习实例（二）采集无限滚动页面/","text":"这是崔斯特的第十七篇原创文章 上一篇写的是采集虎嗅网首页的新闻数据，有朋友对我说，采集多页试试看。后来研究下，虎嗅网首页是POST加载，Form Data中携带参数，所以只需要带上一个循环就好了。这是我最初的想法，先让我们看看Scrapy中如何采集无限滚动页面？ 先举个栗子，采集网站是quotes 分析网页 下拉时，会发现更多新的请求，观察这些请求，返回的都是json数据，也就是我们所需的，再看看他们的不同，也就是参数的改变，完整链接是： 123http://spidyquotes.herokuapp.com/api/quotes?page=2http://spidyquotes.herokuapp.com/api/quotes?page=3http://spidyquotes.herokuapp.com/api/quotes?page=4 这就很清晰了。 返回的是json，我们需要解析，然后提取数据，那我们如何知道最多有多少条json呢，文件已经告诉我们了： has_next:true 创建项目12345scrapy startproject quotecd quotescrapy genspider spiderquote http://spidyquotes.herokuapp.com/scroll 定义Item查看网站，采集text、author和tags这三个 123456789import scrapyclass QuoteItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() text = scrapy.Field() author = scrapy.Field() tag = scrapy.Field() 编写spider1234567891011121314151617181920212223# -*- coding: utf-8 -*-import scrapyimport jsonclass SpiderquoteSpider(scrapy.Spider): name = 'spiderquote' quotes_base_url = 'http://spidyquotes.herokuapp.com/api/quotes?page=%s' start_urls = [quotes_base_url % 1] download_delay = 1.5 def parse(self, response): data = json.loads(response.body) for item in data.get('quotes', []): yield &#123; 'text': item.get('text'), 'author': item.get('author', &#123;&#125;).get('name'), 'tags': item.get('tags'), &#125; if data['has_next']: next_page = data['page'] + 1 yield scrapy.Request(self.quotes_base_url % next_page) 运行爬虫，然后就可以看到结果了。 应用到虎嗅网那么如何应用到虎嗅网呢？首先还是要去分析网页。 虎嗅网的参数有3个： 123huxiu_hash_code:13a3a353c52d424e1e263dda4d594e59page:3last_dateline:1512026700 我们知道page就是翻页页码，huxiu_hash_code是一个不变的字符，last_dateline看起来像unix时间戳，验证确实如此。这个时间戳有必要带上吗，我想验证试试看。 在postman中测试，不带上last_dateline也是可以返回数据，并且这个json中已经告诉我们一共有多少页： &quot;total_page&quot;: 1654 在主函数中我们可以依葫芦画瓢 12345678910111213141516171819202122232425262728293031# -*- coding: utf-8 -*-import scrapyfrom huxiu.items import HuxiuItemimport jsonfrom lxml import etreeclass HuxiuSpider(scrapy.Spider): name = 'HuXiu' def start_requests(self): url = 'https://www.huxiu.com/v2_action/article_list' for i in range(1, 10): # FormRequest 是Scrapy发送POST请求的方法 yield scrapy.FormRequest( url = url, formdata = &#123;\"huxiu_hash_code\" : \"13a3a353c52d424e1e263dda4d594e59\", \"page\" : str(i)&#125;, callback = self.parse ) def parse(self, response): item = HuxiuItem() data = json.loads(response.text) s = etree.HTML(data['data']) item['title'] = s.xpath('//a[@class=\"transition msubstr-row2\"]/text()') item['link'] = s.xpath('//a[@class=\"transition msubstr-row2\"]/@href') item['author'] = s.xpath('//span[@class=\"author-name\"]/text()') item['introduction'] = s.xpath('//div[@class=\"mob-sub\"]/text()') yield item 输出的数据有点难看，是一段一段的。。 因为data[&#39;data&#39;]是一段html文件，所以这里选择的是xpath，不清楚这里是否直接使用Scrapy的xpath解析工具，如果可以，欢迎在评论中告诉我。 本篇收获 Scrapy采集动态网站：分析网页 使用Scrapy模拟post请求方法，文档在这 刘亦菲好漂亮 待做事宜 完善文件保存与解析 全站抓取大概用了3分钟，速度有点慢 若想评论，先翻长城","tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://zhangslob.github.io/tags/爬虫/"},{"name":"Scrapy","slug":"Scrapy","permalink":"https://zhangslob.github.io/tags/Scrapy/"},{"name":"虎嗅","slug":"虎嗅","permalink":"https://zhangslob.github.io/tags/虎嗅/"}]},{"title":"统计学学习笔记（一）","date":"2017-11-30T15:45:14.000Z","path":"2017/11/30/统计学学习笔记（一）/","text":"这是崔斯特的第十六篇原创文章 这是学习统计学的第一篇笔记，以后尽量都放在这里吧。 发现使用hexo发文章的快捷键： hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 下面是正文： 1、统计中的基本概念 总体和样本。总体：所研究的全部个体；样本：总体中的一部分 参数和统计量。参数：用来描述总体特征的概括性数字度量；统计量：用来描述样本特征的概括性数字度量。 变量。变量、分类变量（事物类别的一个名称）、顺序变量（事物有序类别的一个名称）、数值型变量、离散型变量（只能取可数值的变量）、连续性变量。 2、数据的收集1、数据的间接来源二手数据：公开出版的或公开报道的数据。 2、数据的直接来源（1）统计调查方式 抽样调查：经济性、时效性强、适应面广、准确性高。 普查：一次性或周期性、规定调查时间、数据比较准确、范围比较狭窄。 （2）数据的收集方法 询问调查：访问调查、邮寄调查、电话调查、计算机辅助调查、座谈会、个别深度访问。 观察与实验：观察法、实验法。 竟然没网络爬虫，嘤嘤嘤 3、调查设计（1）调查方案设计 调查目的 调查对象和调查单位 调查项目和调查表 （2）调查问卷设计a.调查问卷的基本结构： 开头部分（问候语、填表说明、问卷编号 ） 甄别部分：过滤——筛选掉不需要的部分——针对特定人群 主体部分：调查的全部问题 背景部分：被调查者的背景资料 b.提问项目的设计： 提问的内容尽可能短 用词要确切、通俗 一个项目只包含一项内容 避免诱导性提问 避免否定式提问 避免敏感性问题 c.回答项目的设计 开放性问题：灵活；整理资料困难 封闭性问题：两项选择法、多项选择法（单项选择型、多项选择型、限制选择型） 顺序选择法：按顺序排列 评定尺度法：和NPS有点像哦 双向列联法：表格表现 d.问题顺序的设计 问题的安排硬具有逻辑性 问题的顺序应先难后易 能引起被调查者兴趣的问题放在最前面 开放性问题放在后面 （3）统计数据的质量a.统计数据的误差b.统计数据的误差 精度 准确性 关联性 及时性 一致性 最低成本 这是统计学基础 第三版 (贾俊平)的记录，看了前两章，感觉受益匪浅，尤其是问卷的设计，比较系统、完整，可以应用在以后的工作中。 书名：统计学基础 第三版 作者：贾俊平 出版社：中国人民大学出版社 最后说一说为什么要学统计学最直接原因是工资高。可以去拉勾上看看“数据分析”、“数据挖掘”、“数据科学家”等职位，他们对学历的要求基本上都会有“统计学”。 对于我这种文科生来说，学习统计学是必经之路。敲门砖啊！ 最后记录下最近学习的数据科学的流程： 业务理解 分析方法 数据要求 收集数据 数据理解 数据准备 建模（use and test） 模型评估 部署与反馈 自己判断，缺少的是业务理解，对相关的业务知识了解太少；分析方法知道的太少了，接下来会着重学习一些常见的算法；数据准备也是一个大坑，不过好在自己有一些Python基础；建模才是最难的，慢慢来吧。 最近几天需要个自己定一个学习任务，内容主要包括：统计学基础、常见算法、pandas处理数据及可视化、业务理解、Scrapy框架学习、前端（没错，学点前端很有必要） 欢迎加我微信，一起来学习，嘤嘤嘤 下面是常见的分析方法","tags":[{"name":"统计学","slug":"统计学","permalink":"https://zhangslob.github.io/tags/统计学/"},{"name":"数据","slug":"数据","permalink":"https://zhangslob.github.io/tags/数据/"}]},{"title":"Scrapy学习实例（一）","date":"2017-11-29T13:52:32.000Z","path":"2017/11/29/Scrapy学习实例（一）/","text":"这是崔斯特的第十五篇原创文章 Hello，我又回来啦。以后就在这发文章吧，记录自己的学习历程。 举头卖竹鼠，低头嘤嘤嘤。 我会记录自己对Scrapy的学历经历，更重要的是理解。下面就开始吧，首先当然是创建一个项目啦！ 我选择爬取虎嗅网首页的新闻列表。 1、创建项目1234567891011121314151617F:\\Python\\huxiu&gt;scrapy startproject huxiuNew Scrapy project 'huxiu', using template directory 'c:\\\\users\\\\administrator\\\\appdata\\\\local\\\\programs\\\\python\\\\python36\\\\lib\\\\site-packages\\\\scrapy\\\\templates\\\\project', created in: F:\\Python\\huxiu\\huxiuYou can start your first spider with: cd huxiu scrapy genspider example example.comF:\\Python\\huxiu&gt;cd huxiuF:\\Python\\huxiu\\huxiu&gt;scrapy genspider huxiu huxiu.comCannot create a spider with the same name as your projectF:\\Python\\huxiu\\huxiu&gt;scrapy genspider HuXiu huxiu.comCreated spider 'HuXiu' using template 'basic' in module: huxiu.spiders.HuXiu 记住爬虫和项目命名不一样 2、定义Item在item.py中创建scrapy.Item类，并定义它的类型为scrapy.Field的属性。 123456789101112import scrapyclass HuxiuItem(scrapy.Item): # define the fields for your item here like: # name = scrapy.Field() title = scrapy.Field() #标题 link = scrapy.Field() #链接 author = scrapy.Field() #作者 introduction = scrapy.Field() #简介 time = scrapy.Field() #时间 3、编写Spider 一目了然 在huxiu/spider/HuXiu.py中编写代码 12345678910111213141516171819202122# -*- coding: utf-8 -*-import scrapyfrom huxiu.items import HuxiuItemclass HuxiuSpider(scrapy.Spider): name = 'HuXiu' allowed_domains = ['huxiu.com'] start_urls = ['http://huxiu.com/'] def parse(self, response): for s in response.xpath('//div[@class=\"mod-info-flow\"]/div/div[@class=\"mob-ctt\"]'): item = HuxiuItem() item['title'] = s.xpath('h2/a/text()')[0].extract() item['link'] = s.xpath('h2/a/@href')[0].extract() url = response.urljoin(item['link']) item['author'] = s.xpath('div/a/span/text()')[0].extract() item['introduction'] = s.xpath('div[2]/text()')[0].extract() item['time'] = s.xpath('div/span/text()')[0].extract() print(item) 在终端输入命令 scrapy crawl HuXiu 部分输出 4、深度爬取哈哈，这里借用造数的命名了。其实就是爬取新闻详情页。1234567891011121314151617181920212223242526272829303132333435# -*- coding: utf-8 -*-import scrapyfrom huxiu.items import HuxiuItemclass HuxiuSpider(scrapy.Spider): name = 'HuXiu' allowed_domains = ['huxiu.com'] start_urls = ['http://huxiu.com/'] def parse(self, response): for s in response.xpath('//div[@class=\"mod-info-flow\"]/div/div[@class=\"mob-ctt\"]'): item = HuxiuItem() item['title'] = s.xpath('h2/a/text()')[0].extract() item['link'] = s.xpath('h2/a/@href')[0].extract() url = response.urljoin(item['link']) item['author'] = s.xpath('div/a/span/text()')[0].extract() item['introduction'] = s.xpath('div[2]/text()')[0].extract() item['time'] = s.xpath('div/span/text()')[0].extract() #print(item) yield scrapy.Request(url, callback=self.parse_article) def parse_article(self, response): item = HuxiuItem() detail = response.xpath('//div[@class=\"article-wrap\"]') item['title'] = detail.xpath('h1/text()')[0].extract().strip() item['link'] = response.url item['author'] = detail.xpath('div[@class=\"article-author\"]/span/a/text()')[0].extract() item['time'] = detail.xpath('div[@class=\"article-author\"]/div[@class=\"column-link-box\"]/span/text()')[0].extract() print(item) word = detail.xpath('div[5]') print(word[0].xpath('string(.)').extract()[0]) yield item 输出结果 说明一点，如何使用xpath获得多个标签下的文本，这里参考了解决：xpath取出指定多标签内所有文字text，把文章详细内容打印出来，但是会遇到一些错误，可以使用goose来试试看。 Python-Goose - Article Extractor1234567891011&gt;&gt;&gt; from goose import Goose&gt;&gt;&gt; from goose.text import StopWordsChinese&gt;&gt;&gt; url = 'http://www.bbc.co.uk/zhongwen/simp/chinese_news/2012/12/121210_hongkong_politics.shtml'&gt;&gt;&gt; g = Goose(&#123;'stopwords_class': StopWordsChinese&#125;)&gt;&gt;&gt; article = g.extract(url=url)&gt;&gt;&gt; print article.cleaned_text[:150]香港行政长官梁振英在各方压力下就其大宅的违章建筑（僭建）问题到立法会接受质询，并向香港民众道歉。梁振英在星期二（12月10日）的答问大会开始之际在其演说中道歉，但强调他在违章建筑问题上没有隐瞒的意图和动机。一些亲北京阵营议员欢迎梁振英道歉，且认为应能获得香港民众接受，但这些议员也质问梁振英有 参考文章： Scrapy笔记02- 完整示例 解决：xpath取出指定多标签内所有文字text 若想评论，先翻长城","tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://zhangslob.github.io/tags/爬虫/"},{"name":"Scrapy","slug":"Scrapy","permalink":"https://zhangslob.github.io/tags/Scrapy/"},{"name":"虎嗅","slug":"虎嗅","permalink":"https://zhangslob.github.io/tags/虎嗅/"}]},{"title":"爬虫三步走（二）解析源码","date":"2017-05-26T12:15:20.000Z","path":"2017/05/26/爬虫三步走（二）解析源码/","text":"这是崔斯特的第十四篇原创文章 爬虫三步走：获取源码、解析源码、数据储存 上一期讲了如何获取网页源码的方法，这一期说一说怎么从其中获得我们需要的和数据。 解析网页的方法很多，最常见的就是BeautifulSoup和正则了，其他的像xpath、PyQuery等等，其中我觉得最好用的就是xpath了，xpath真的超级简单好用，学了之后再也不想取用美丽汤了。下面介绍xpath的使用方法。 首先需要安装lxml，windows下安装lxml是个大坑，知乎上有人给出了解决方法Python LXML模块死活安装不了怎么办？ 详细的用法可以参考爬虫入门到精通-网页的解析（xpath） 在这里我们尝试使用xpath来迅速获取数据。 例如想要获熊猫直播虎牙直播下主播的ID import requests from lxml import etree url = &apos;http://www.huya.com/g/lol&apos; headers = {&apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&apos;} res = requests.get(url,headers=headers).text s = etree.HTML(res) print(s.xpath(&apos;//i[@class=&quot;nick&quot;]/text()&apos;)) 输出： 下面一步步讲解为什么这样做。 import requests from lxml import etree 首先是导入模块，requests很常见，但是xpath需要 from lxml import etree，你肯点想问为什么这样写，回答是“我也不知道”，就像是约定俗成的东西一样。 url = &apos;http://www.huya.com/g/lol&apos; headers = {&apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&apos;} res = requests.get(url,headers=headers).text 这三步就是平常获取源码的过程，很简单。 s = etree.HTML(res) 给一个html，返回xml结构，为什么这样写？？答案和上面一样。最重要的就是下面的这一步： s.xpath(&apos;//i[@class=&quot;nick&quot;]/text()&apos;) 按下F12看到“爱拍-古手羽”在i标签下，接着我们右键打开“查看网页源代码”，搜索“爱拍-古手羽” 确实找到了“爱拍-古手羽”就在i标签下，那我们就把他提出来吧！ s.xpath(&#39;//i[@class=&quot;nick&quot;]/text()&#39;) 这个段代码意思是，找到class为“nick”的i标签，返回其中的文本信息，当然你也可以返回i标签中的title，写法如下： s.xpath(&#39;//i[@class=&quot;nick&quot;]/@title&#39;) text()返回的是文本信息，@title则是标签里面的具体属性的值，例如我想知道观众人数 import requests from lxml import etree url = &apos;http://www.huya.com/g/lol&apos; headers = {&apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&apos;} res = requests.get(url,headers=headers).text s = etree.HTML(res) print(s.xpath(&apos;//i[@class=&quot;js-num&quot;]/text()&apos;)) 只需在原来基础上修改一个属性，i标签class为“js-num”里面的值 print(s.xpath(&apos;//i[@class=&quot;js-num&quot;]/text()&apos;)) 返回结果是： 说明：在运行代码中，发现虎牙反爬虫做得挺好的，瞬间就识别爬虫身份并封了IP，所以我换了IP去访问，至于如何设置代理，在我的上一篇文章中有说到，去看看吧。 在实际操作中，你可能会遇到更加复杂的情况，所以一定记得去看看详细的教程。爬虫入门到精通-网页的解析（xpath） 小广告：喜欢爬虫、数据的可以关注一下我的微信公众号（zhangslob），多多交流。","tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://zhangslob.github.io/tags/爬虫/"},{"name":"Python入门","slug":"Python入门","permalink":"https://zhangslob.github.io/tags/Python入门/"}]},{"title":"爬虫三步走（一）获取源码","date":"2017-05-25T07:21:06.000Z","path":"2017/05/25/爬虫三步走（一）获取源码/","text":"这是崔斯特的第十三篇原创文章 爬虫三步走：获取源码、解析源码、数据储存 举个例子，爬一爬知乎日报的相关数据 知乎日报 - 每天 3 次，每次 7 分钟 1、获取源码12345import requests url = 'http://daily.zhihu.com/'res = requests.get(url).textprint(res) 个人喜欢requests，直接访问，发现返回500错误 C:\\Python35\\python.exe F:/PyCharm/爬虫/daily.py &lt;html&gt;&lt;body&gt;&lt;h1&gt;500 Server Error&lt;/h1&gt; An internal server error occured. &lt;/body&gt;&lt;/html&gt; Process finished with exit code 0 根据经验判断，是知乎禁止爬虫，需要加上一些伪装，让我们看看加上浏览器伪装效果 import requests headers = {&apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&apos;} url = &apos;http://daily.zhihu.com/&apos; res = requests.get(url,headers=headers).text print(res) 看看结果，已经返回我们需要的数据 C:\\Python35\\python.exe F:/PyCharm/爬虫/daily.py &lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt;&lt;title&gt;知乎日报 - 每天 3 次，每次 7 分钟&lt;/title&gt;&lt;meta charset=&quot;utf-8&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;&lt;meta name=&quot;description&quot; content=&quot;在中国，资讯类移动应用的人均阅读时长是 5 分钟，而在知乎日报，这个数字是 21。以独有的方式为你提供最高质、最深度、最有收获的阅读体验。&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/base.auto.css&quot;&gt;&lt;link rel=&quot;stylesheet&quot; href=&quot;/css/new_home_v3.auto.css&quot;&gt;&lt;script src=&quot;/js/jquery.1.9.1.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;/js/new_index_v3/home.js&quot;&gt;&lt;/script&gt;&lt;link rel=&quot;shortcut icon&quot; href=&quot;/favicon.ico&quot; type=&quot;image/x-icon&quot;&gt;&lt;base target=&quot;_blank&quot;&gt;&lt;style&gt;h1,h2,h3 {padding: 0;margin:0}&lt;/style&gt;&lt;base target=&quot;_blank&quot;&gt;&lt;/head&gt;&lt;body class=&quot;home&quot;&gt;&lt;a href=&quot;javascript:;&quot; title=&quot;回到顶部&quot; class=&quot;back-to-top&quot;&gt;&lt;/a&gt;&lt;div class=&quot;header navbar-fixed-top&quot;&gt;&lt;div class=&quot;container-fixed-width clearfix&quot;&gt;&lt;div class=&quot;top-nav-link&quot;&gt;&lt;a href=&quot;javascript:;&quot; data-offset=&quot;470&quot;&gt;&lt;span&gt;浏览内容&lt;/span&gt;&lt;/a&gt;&lt;a href=&quot;javascript:;&quot; data-offset=&quot;0&quot; class=&quot;active&quot;&gt;&lt;span&gt;App 下载&lt;/span&gt;&lt;/a&gt;&lt;/div&gt;&lt;h1 class=&quot;logo&quot;&gt;&lt;a href=&quot;http://daily.zhihu.com/&quot; title=&quot;知乎日报&quot; class=&quot;link-logo&quot;&gt;知乎日报&lt;/a&gt;&lt;/h1&gt;&lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;download&quot;&gt; ... 但是这种写法是否可以应用到所有的网站，答案是“不” 2、代理设置有时候同一个IP去爬取同一网站上的内容，久了之后就会被该网站服务器屏蔽。解决方法就是更换IP。这个时候，在对方网站上，显示的不是我们真实地IP地址，而是代理服务器的IP地址。 国内高匿免费HTTP代理IP_国内高匿 西刺代理提供了很多可用的国内IP，可以直接拿来使用。 那么如何在爬虫里加入代理呢，看看requests的官方文档怎么说。高级用法 - Requests 2.10.0 文档 如果需要使用代理，你可以通过为任意请求方法提供 proxies 参数来配置单个请求: import requests proxies = { &quot;http&quot;: &quot;http://10.10.1.10:3128&quot;, &quot;https&quot;: &quot;http://10.10.1.10:1080&quot;, } requests.get(&quot;http://example.org&quot;, proxies=proxies) 用法很简单，加入proxies参数即可 import requests proxies = { &quot;http&quot;: &quot;http://121.201.24.248：8088&quot;, &quot;https&quot;: &quot;http://36.249.194.52：8118&quot;, } headers = {&apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&apos;} url = &apos;http://daily.zhihu.com/&apos; res = requests.get(url,headers=headers，proxies=proxies).text print(len(res)) 为了便于测试，只打印出返回数据的长度 C:\\Python35\\python.exe F:/PyCharm/爬虫/daily.py 10830 Process finished with exit code 0 发现代理服务器成功爬取知乎日报的信息，内容是10830，故意把代理IP写错一位数，看看结果 import requests proxies = { &quot;http&quot;: &quot;http://121.201.24.248：8088&quot;, &quot;https&quot;: &quot;http://36.249.194.52: 222&quot;, } headers = {&apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36&apos;} url = &apos;http://daily.zhihu.com/&apos; res = requests.get(url,headers=headers,proxies=proxies).text print(len(res)) 我们把”https”: “http://36.249.194.52：8118&quot;修改为&quot;https“: “http://36.249.194.52: 222”，此时返回的结果如下，发现不能获取网页数据。所以，在使用代理服务器爬去网站时，如果出现异常，要考虑代理IP是否失效了。 当然你也可以写一个爬虫，实时抓取最新的代理IP用来爬取。 Traceback (most recent call last): File &quot;F:/PyCharm/爬虫/daily.py&quot;, line 9, in &lt;module&gt; res = requests.get(url,headers=headers,proxies=proxies).text File &quot;C:\\Python35\\lib\\site-packages\\requests\\api.py&quot;, line 70, in get return request(&apos;get&apos;, url, params=params, **kwargs) File &quot;C:\\Python35\\lib\\site-packages\\requests\\api.py&quot;, line 56, in request return session.request(method=method, url=url, **kwargs) File &quot;C:\\Python35\\lib\\site-packages\\requests\\sessions.py&quot;, line 488, in request resp = self.send(prep, **send_kwargs) File &quot;C:\\Python35\\lib\\site-packages\\requests\\sessions.py&quot;, line 609, in send r = adapter.send(request, **kwargs) File &quot;C:\\Python35\\lib\\site-packages\\requests\\adapters.py&quot;, line 485, in send raise ProxyError(e, request=request) requests.exceptions.ProxyError: HTTPConnectionPool(host=&apos;121.201.24.248：8088&apos;, port=80): Max retries exceeded with url: http://daily.zhihu.com/ (Caused by ProxyError(&apos;Cannot connect to proxy.&apos;, NewConnectionError(&apos;&lt;requests.packages.urllib3.connection.HTTPConnection object at 0x0000000003860DA0&gt;: Failed to establish a new connection: [Errno 11004] getaddrinfo failed&apos;,))) 3、模拟登录有些网站是需要登录才能看到信息的，例如知乎，直接用requests获取知乎首页信息，返回数据是需要你登录的，只有登录了才能看到数据。 &lt;button type=&quot;button&quot; class=&quot;signin-switch-button&quot;&gt;手机验证码登录&lt;/button&gt; &lt;a class=&quot;unable-login&quot; href=&quot;#&quot;&gt;无法登录？&lt;/a&gt; &lt;/div&gt; &lt;div class=&quot;social-signup-wrapper&quot; data-za-module=&quot;SNSSignIn&quot;&gt; &lt;span class=&quot;name js-toggle-sns-buttons&quot;&gt;社交帐号登录&lt;/span&gt; &lt;div class=&quot;sns-buttons&quot;&gt; &lt;a title=&quot;微信登录&quot; class=&quot;js-bindwechat&quot; href=&quot;#&quot;&gt;&lt;i class=&quot;sprite-index-icon-wechat&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;a title=&quot;微博登录&quot; class=&quot;js-bindweibo&quot; href=&quot;#&quot;&gt;&lt;i class=&quot;sprite-index-icon-weibo&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;a title=&quot;QQ 登录&quot; class=&quot;js-bindqq&quot; href=&quot;#&quot;&gt;&lt;i class=&quot;sprite-index-icon-qq&quot;&gt;&lt;/i&gt;&lt;/a&gt; &lt;/div&gt; 再次回到官方文档快速上手 - Requests 2.10.0 文档 如果某个响应中包含一些 cookie，你可以快速访问它们： &gt;&gt;&gt; url = &apos;http://example.com/some/cookie/setting/url&apos; &gt;&gt;&gt; r = requests.get(url) &gt;&gt;&gt; r.cookies[&apos;example_cookie_name&apos;] &apos;example_cookie_value&apos; 要想发送你的cookies到服务器，可以使用 cookies 参数： &gt;&gt;&gt; url = &apos;http://httpbin.org/cookies&apos; &gt;&gt;&gt; cookies = dict(cookies_are=&apos;working&apos;) &gt;&gt;&gt; r = requests.get(url, cookies=cookies) &gt;&gt;&gt; r.text &apos;{&quot;cookies&quot;: {&quot;cookies_are&quot;: &quot;working&quot;}}&apos; 具体的分析过程可以参考xchaoinfo所写的文章和视频，讲解十分清晰Python 模拟登录哪些事儿 - 知乎专栏 下面是代码 import requests from bs4 import BeautifulSoup import os, time import re # import http.cookiejar as cookielib # 构造 Request headers agent = &apos;Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Mobile Safari/537.36&apos; headers = { &quot;Host&quot;: &quot;www.zhihu.com&quot;, &quot;Referer&quot;: &quot;https://www.zhihu.com/&quot;, &apos;User-Agent&apos;: agent } ######### 构造用于网络请求的session session = requests.Session() # session.cookies = cookielib.LWPCookieJar(filename=&apos;zhihucookie&apos;) # try: # session.cookies.load(ignore_discard=True) # except: # print(&apos;cookie 文件未能加载&apos;) ############ 获取xsrf_token homeurl = &apos;https://www.zhihu.com&apos; homeresponse = session.get(url=homeurl, headers=headers) homesoup = BeautifulSoup(homeresponse.text, &apos;html.parser&apos;) xsrfinput = homesoup.find(&apos;input&apos;, {&apos;name&apos;: &apos;_xsrf&apos;}) xsrf_token = xsrfinput[&apos;value&apos;] print(&quot;获取到的xsrf_token为： &quot;, xsrf_token) ########## 获取验证码文件 randomtime = str(int(time.time() * 1000)) captchaurl = &apos;https://www.zhihu.com/captcha.gif?r=&apos;+\\ randomtime+&quot;&amp;type=login&quot; captcharesponse = session.get(url=captchaurl, headers=headers) with open(&apos;checkcode.gif&apos;, &apos;wb&apos;) as f: f.write(captcharesponse.content) f.close() # os.startfile(&apos;checkcode.gif&apos;) captcha = input(&apos;请输入验证码：&apos;) print(captcha) ########### 开始登陆 headers[&apos;X-Xsrftoken&apos;] = xsrf_token headers[&apos;X-Requested-With&apos;] = &apos;XMLHttpRequest&apos; loginurl = &apos;https://www.zhihu.com/login/email&apos; postdata = { &apos;_xsrf&apos;: xsrf_token, &apos;email&apos;: &apos;邮箱@qq.com&apos;, &apos;password&apos;: &apos;密码&apos; } loginresponse = session.post(url=loginurl, headers=headers, data=postdata) print(&apos;服务器端返回响应码：&apos;, loginresponse.status_code) print(loginresponse.json()) # 验证码问题输入导致失败: 猜测这个问题是由于session中对于验证码的请求过期导致 if loginresponse.json()[&apos;r&apos;]==1: # 重新输入验证码，再次运行代码则正常。也就是说可以再第一次不输入验证码，或者输入一个错误的验证码，只有第二次才是有效的 randomtime = str(int(time.time() * 1000)) captchaurl = &apos;https://www.zhihu.com/captcha.gif?r=&apos; + \\ randomtime + &quot;&amp;type=login&quot; captcharesponse = session.get(url=captchaurl, headers=headers) with open(&apos;checkcode.gif&apos;, &apos;wb&apos;) as f: f.write(captcharesponse.content) f.close() os.startfile(&apos;checkcode.gif&apos;) captcha = input(&apos;请输入验证码：&apos;) print(captcha) postdata[&apos;captcha&apos;] = captcha loginresponse = session.post(url=loginurl, headers=headers, data=postdata) print(&apos;服务器端返回响应码：&apos;, loginresponse.status_code) print(loginresponse.json()) ##########################保存登陆后的cookie信息 # session.cookies.save() ############################判断是否登录成功 profileurl = &apos;https://www.zhihu.com/settings/profile&apos; profileresponse = session.get(url=profileurl, headers=headers) print(&apos;profile页面响应码：&apos;, profileresponse.status_code) profilesoup = BeautifulSoup(profileresponse.text, &apos;html.parser&apos;) div = profilesoup.find(&apos;div&apos;, {&apos;id&apos;: &apos;rename-section&apos;}) print(div) 好了关于爬虫的第一步，获取源码这一节讲了很多，其实大多数网站加上User-Agent和代理IP就可以正常爬取。下一节会讲讲如何利用xpath来解析网页，获取我们想要的数据。 喜欢爬虫、数据的可以关注一下我的微信公众号，多多交流。","tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://zhangslob.github.io/tags/爬虫/"},{"name":"Python入门","slug":"Python入门","permalink":"https://zhangslob.github.io/tags/Python入门/"}]},{"title":"知乎上妹子都爱取啥名？","date":"2017-05-20T09:45:48.000Z","path":"2017/05/20/知乎上妹子都爱取啥名？/","text":"这是崔斯特的第十二篇原创文章 闲来无事上知乎，看到好多妹子，于是抓取一波。 目标网址：轮子哥带我逛知乎 - 收藏夹 - 知乎 目标：抓取妹子的ID 1、抓取这次并没有使用Python做爬虫，使用工具来，速度更快。造数 - 新一代智能云爬虫 不到十分钟就完成了，遗失了部分数据，但是无所谓啦。保存下来，分析分析。 2、分析 使用pandas操作文件 import pandas as pd fp = pd.read_excel(&apos;D:\\Backup\\桌面\\lunzige.xlsx&apos;) fp name = fp[&apos;name&apos;].tolist() li1 = list(set(name)) li1 [&apos;阿蕾&apos;, &apos;杨面&apos;, &apos;陈10&apos;, &apos;杨顺顺&apos;, &apos;霧橤&apos;, &apos;真顺顺真&apos;, &apos;谢椿明&apos;, &apos;刀刀&apos;, &apos;水枪大帝&apos;, &apos;倾浅&apos;, &apos;Listening&apos;, &apos;小火龙&apos;, &apos;包子琛&apos;, &apos;杨笋笋&apos;, &apos;蜉蝣&apos;, &apos;十元&apos;, &apos;靡靡之音&apos;, &apos;Real机智张&apos;, &apos;陈梓小童鞋&apos;, &apos;花甲&apos;, &apos;窗里窗外&apos;, &apos;刘梓乔&apos;, &apos;璇璇97&apos;, &apos;Olivia菊香小姐姐&apos;, &apos;牛奶小夏目&apos;, &apos;周依宁&apos;, &apos;万阿咸&apos;, &apos;一蓑烟雨任平生&apos;, &apos;来都来了&apos;, &apos;就像周一&apos;, &apos;Mc蛋蛋&apos;, &apos;秉剑侯&apos;, &apos;李大梦Lee&apos;, &apos;Diss锐雯&apos;, &apos;雨音眞白&apos;, &apos;半仙幺幺&apos;, &apos;Natsuki是只蠢兔纸&apos;, &apos;夏冰莹&apos;, &apos;guuweihai&apos;, &apos;阿舞&apos;, &apos;肖柚妮&apos;, &apos;墨脱要开&apos;, &apos;芷珞&apos;, &apos;舒西婷&apos;, &apos;Childe0Q&apos;, &apos;被压扁的海螺&apos;, &apos;snow arc&apos;, &apos;灰灰灰灰灰plus&apos;, &apos;小兔子菲呀&apos;, &apos;士多啤梨羊咩咩&apos;, &apos;李小可可&apos;, &apos;谁来拽我的尾巴&apos;, &apos;飞鸽之舞&apos;, &apos;小美&apos;, &apos;樱雪绫sama&apos;, &apos;zshiyao&apos;, &apos;王漠里&apos;, &apos;Slivan&apos;, &apos;喵小虾&apos;, &apos;SUSAN苏&apos;, &apos;上官兰颜&apos;, &apos;这个杀手不太冷&apos;, &apos;看朱成碧纷思君&apos;, &apos;情绪&apos;, &apos;我系小忌廉&apos;, &apos;一只兔&apos;, &apos;June&apos;, &apos;我就想改名而已&apos;, &apos;温柔的大猫Leo&apos;, &apos;猫芙琳&apos;, &apos;以太&apos;, &apos;博丽魔理沙&apos;, &apos;洛丽塔&apos;, &apos;羽小团&apos;, &apos;娄良&apos;, &apos;Rosi&apos;, &apos;叶以北&apos;, &apos;吃不胖的小猫&apos;, &apos;Lina&apos;, &apos;ingrid&apos;, &apos;itttttx&apos;, &apos;胡杨&apos;, &apos;孙阿童&apos;, &apos;林美珍&apos;, &apos;赫蘿Taiga&apos;, &apos;宫曼曼&apos;, &apos;Yoonyicc&apos;, &apos;ZW711&apos;, &apos;笙箫&apos;, &apos;KIKI.Liu&apos;, &apos;另一只袜子&apos;, &apos;荒野大嫖客&apos;, &apos;少女诗&apos;, &apos;芸豆豆豆豆&apos;, &apos;璐璐噜&apos;, &apos;棹歌&apos;, &apos;梦里有只独角兽&apos;, &apos;Oo澄子oO&apos;, &apos;雷梅苔丝&apos;, &apos;CherryZhao&apos;, &apos;李萬一&apos;, &apos;琴脂&apos;, &apos;鹿斑比&apos;, &apos;Chris姬-云烟&apos;, &apos;hyoram&apos;, &apos;蔗蔗蔗&apos;, &apos;柚子Ruby&apos;, &apos;Sheena&apos;, &apos;孟德尔&apos;, &apos;kaka小师妹&apos;, &apos;桢视明&apos;, &apos;大豆苗&apos;, &apos;少女开膛手&apos;, &apos;陈诗茗&apos;] 那么，下一步就是对名字进行分词了，jieba分词，你值得拥有。fxsjy/jieba li2 = &apos;&apos;.join(li1) li2 &apos;阿蕾杨面陈10杨顺顺霧橤真顺顺真谢椿明刀刀水枪大帝倾浅Listening小火龙包子琛杨笋笋蜉蝣十元靡靡之音Real机智张陈梓小童鞋花甲窗里窗外刘梓乔璇璇97Olivia菊香小姐姐牛奶小夏目周依宁万阿咸一蓑烟雨任平生来都来了就像周一Mc蛋蛋秉剑侯李大梦LeeDiss锐雯雨音眞白半仙幺幺Natsuki是只蠢兔纸夏冰莹guuweihai阿舞肖柚妮墨脱要开芷珞舒西婷Childe0Q被压扁的海螺snow arc灰灰灰灰灰plus小兔子菲呀士多啤梨羊咩咩李小可可谁来拽我的尾巴飞鸽之舞小美樱雪绫samazshiyao王漠里Slivan喵小虾SUSAN苏上官兰颜这个杀手不太冷看朱成碧纷思君情绪我系小忌廉一只兔June我就想改名而已温柔的大猫Leo猫芙琳以太博丽魔理沙洛丽塔羽小团娄良Rosi叶以北吃不胖的小猫Linaingriditttttx胡杨孙阿童林美珍赫蘿Taiga宫曼曼YoonyiccZW711笙箫KIKI.Liu另一只袜子荒野大嫖客少女诗芸豆豆豆豆璐璐噜棹歌梦里有只独角兽Oo澄子oO雷梅苔丝CherryZhao李萬一琴脂鹿斑比Chris姬-云烟hyoram蔗蔗蔗柚子RubySheena孟德尔kaka小师妹桢视明大豆苗少女开膛手陈诗茗&apos; 有何感想？？ 下一步就是分词制作图云了 import jieba seg_list = jieba.cut(li2) word = &quot;/&quot;.join(seg_list) print(&quot;Full Mode: &quot; + &quot;/ &quot;.join(seg_list)) Building prefix dict from the default dictionary ... Dumping model to file cache C:\\Users\\ADMINI~1\\AppData\\Local\\Temp\\jieba.cache Loading model cost 1.148 seconds. Prefix dict has been built succesfully. Full Mode: 阿蕾/ 杨/ 面陈/ 10/ 杨/ 顺顺/ 霧/ 橤/ 真/ 顺顺/ 真/ 谢椿明/ 刀刀/ 水枪/ 大帝/ 倾浅/ Listening/ 小/ 火龙/ 包子/ 琛/ 杨笋/ 笋/ 蜉蝣/ 十元/ 靡靡之音/ Real/ 机智/ 张/ 陈梓/ 小/ 童鞋/ 花甲/ 窗里/ 窗外/ 刘梓乔/ 璇/ 璇/ 97Olivia/ 菊香/ 小姐姐/ 牛奶/ 小夏目/ 周依宁/ 万/ 阿/ 咸一/ 蓑/ 烟雨任/ 平生/ 来/ 都/ 来/ 了/ 就/ 像/ 周一/ Mc/ 蛋蛋/ 秉剑侯/ 李大梦/ LeeDiss/ 锐雯雨/ 音眞白/ 半仙/ 幺/ 幺/ Natsuki/ 是/ 只/ 蠢/ 兔纸/ 夏/ 冰莹/ guuweihai/ 阿舞/ 肖柚妮/ 墨脱/ 要/ 开芷/ 珞/ 舒西婷/ Childe0Q/ 被/ 压扁/ 的/ 海螺/ snow/ / arc/ 灰灰/ 灰灰/ 灰/ plus/ 小兔子/ 菲/ 呀/ 士多啤梨/ 羊/ 咩/ 咩/ 李小/ 可可/ 谁/ 来/ 拽/ 我/ 的/ 尾巴/ 飞鸽/ 之舞/ 小美/ 樱雪/ 绫/ samazshiyao/ 王漠/ 里/ Slivan/ 喵/ 小虾/ SUSAN/ 苏/ 上官/ 兰颜/ 这个/ 杀手/ 不/ 太冷/ 看朱成碧/ 纷思君/ 情绪/ 我系/ 小忌廉/ 一只/ 兔/ June/ 我/ 就/ 想/ 改名/ 而已/ 温柔/ 的/ 大猫/ Leo/ 猫/ 芙琳/ 以太/ 博丽/ 魔理沙/ 洛丽塔/ 羽小团/ 娄良/ Rosi/ 叶/ 以北/ 吃不胖/ 的/ 小猫/ Linaingriditttttx/ 胡杨/ 孙阿童/ 林美珍/ 赫蘿/ Taiga/ 宫曼曼/ YoonyiccZW711/ 笙箫/ KIKI/ ./ Liu/ 另一只/ 袜子/ 荒野/ 大/ 嫖客/ 少女/ 诗/ 芸豆/ 豆豆/ 豆璐璐噜/ 棹/ 歌梦里/ 有/ 只/ 独角兽/ Oo/ 澄子/ oO/ 雷梅/ 苔丝/ CherryZhao/ 李萬/ 一琴脂/ 鹿斑/ 比/ Chris/ 姬/ -/ 云烟/ hyoram/ 蔗蔗蔗/ 柚子/ RubySheena/ 孟德尔/ kaka/ 小/ 师妹/ 桢视/ 明大/ 豆苗/ 少女/ 开膛手/ 陈诗/ 茗 下一步绘制图云，用jupyter遇到了很多坑。。 # -*- coding: utf-8 -*- import matplotlib.pyplot as plt from wordcloud import WordCloud,STOPWORDS,ImageColorGenerator # 直接从文件读取数据 text = &apos;&apos;&apos;阿蕾/杨/面陈/10/杨/顺顺/霧/橤/真/顺顺/真/谢椿明/刀刀/水枪/大帝/倾浅/Listening/小/火龙/包子/琛/杨笋/笋/蜉蝣/十元/靡靡之音/Real/机智/张/陈梓/小/童鞋/花甲/窗里/窗外/刘梓乔/璇/璇/97Olivia/菊香/小姐姐/牛奶/小夏目/周依宁/万/阿/咸一/蓑/烟雨任/平生/来/都/来/了/就/像/周一/Mc/蛋蛋/秉剑侯/李大梦/LeeDiss/锐雯雨/音眞白/半仙/幺/幺/Natsuki/是/只/蠢/兔纸/夏/冰莹/guuweihai/阿舞/肖柚妮/墨脱/要/开芷/珞/舒西婷/Childe0Q/被/压扁/的/海螺/snow/ /arc/灰灰/灰灰/灰/plus/小兔子/菲/呀/士多啤梨/羊/咩/咩/李小/可可/谁/来/拽/我/的/尾巴/飞鸽/之舞/小美/樱雪/绫/samazshiyao/王漠/里/Slivan/喵/小虾/SUSAN/苏/上官/兰颜/这个/杀手/不/太冷/看朱成碧/纷思君/情绪/我系/小忌廉/一只/兔/June/我/就/想/改名/而已/温柔/的/大猫/Leo/猫/芙琳/以太/博丽/魔理沙/洛丽塔/羽小团/娄良/Rosi/叶/以北/吃不胖/的/小猫/Linaingriditttttx/胡杨/孙阿童/林美珍/赫蘿/Taiga/宫曼曼/YoonyiccZW711/笙箫/KIKI/./Liu/另一只/袜子/荒野/大/嫖客/少女/诗/芸豆/豆豆/豆璐璐噜/棹/歌梦里/有/只/独角兽/Oo/澄子/oO/雷梅/苔丝/CherryZhao/李萬/一琴脂/鹿斑/比/Chris/姬/-/云烟/hyoram/蔗蔗蔗/柚子/RubySheena/孟德尔/kaka/小/师妹/桢视/明大/豆苗/少女/开膛手/陈诗/茗&apos;&apos;&apos; backgroud_Image = plt.imread(&apos;girl.jpg&apos;) wc = WordCloud( background_color = &apos;white&apos;, # 设置背景颜色 mask = backgroud_Image, # 设置背景图片 max_words = 2000, # 设置最大现实的字数 stopwords = STOPWORDS, # 设置停用词 font_path = &apos;C:/Users/Windows/fonts/msyh.ttf&apos;,# 设置字体格式，如不设置显示不了中文 max_font_size = 300, # 设置字体最大值 random_state = 50, # 设置有多少种随机生成状态，即有多少种配色方案 ) wc.generate(text) image_colors = ImageColorGenerator(backgroud_Image) #wc.recolor(color_func = image_colors) plt.imshow(wc) plt.axis(&apos;off&apos;) plt.show() 来看看图云吧 其实这个并没有什么卵用，知识自己无聊时玩玩的。下面才是我想要的 0 陈诗茗 https://www.zhihu.com/people/chen-shi-ming-69 1 李大梦Lee https://www.zhihu.com/people/li-da-meng-58-44 2 snow arc https://www.zhihu.com/people/xiaoxueli 3 夏冰莹 https://www.zhihu.com/people/xia-bingying 4 Sheena https://www.zhihu.com/people/zhang-chu-yun-84 5 喵小虾 https://www.zhihu.com/people/maoxiaoxia233 6 李大梦Lee https://www.zhihu.com/people/li-da-meng-58-44 7 李大梦Lee https://www.zhihu.com/people/li-da-meng-58-44 8 以太 https://www.zhihu.com/people/elapse08 9 zshiyao https://www.zhihu.com/people/duo-rou-wan-zi-89 10 SUSAN苏 https://www.zhihu.com/people/susansu-66 11 温柔的大猫Leo https://www.zhihu.com/people/li-yue-90-56 12 琴脂 https://www.zhihu.com/people/qin-zhi-49 13 王漠里 https://www.zhihu.com/people/wang-mo-li-66 14 花甲 https://www.zhihu.com/people/hua-jia-1-71 15 雷梅苔丝 https://www.zhihu.com/people/lei-mei-tai-si-15 16 Olivia菊香小姐姐 https://www.zhihu.com/people/olivia-60-10 17 芷珞 https://www.zhihu.com/people/zhi-luo-90-6 18 Mc蛋蛋 https://www.zhihu.com/people/lee2egg 19 少女诗 https://www.zhihu.com/people/shao-nu-shi-75 20 ingrid https://www.zhihu.com/people/da-da-yao-guai 21 博丽魔理沙 https://www.zhihu.com/people/nan-xiao-niao-94-5 22 赫蘿Taiga https://www.zhihu.com/people/he-luo-taiga 23 kaka小师妹 https://www.zhihu.com/people/kakasis 24 芸豆豆豆豆 https://www.zhihu.com/people/yun-dou-dou-dou-dou 25 林美珍 https://www.zhihu.com/people/lin-mei-zhen 26 喵小虾 https://www.zhihu.com/people/maoxiaoxia233 27 这个杀手不太冷 https://www.zhihu.com/people/wei-jun-jie-9 28 喵小虾 https://www.zhihu.com/people/maoxiaoxia233 29 Rosi https://www.zhihu.com/people/rosi-91 ... ... ... 111 洛丽塔 https://www.zhihu.com/people/hua-hua-gu-niang-5 112 洛丽塔 https://www.zhihu.com/people/hua-hua-gu-niang-5 113 洛丽塔 https://www.zhihu.com/people/hua-hua-gu-niang-5 114 洛丽塔 https://www.zhihu.com/people/hua-hua-gu-niang-5 115 Diss锐雯 https://www.zhihu.com/people/DSRiven 116 水枪大帝 https://www.zhihu.com/people/shuiqiangge 117 樱雪绫sama https://www.zhihu.com/people/lin-xuan-ting-1 118 李小可可 https://www.zhihu.com/people/li-gao-xing-2 119 士多啤梨羊咩咩 https://www.zhihu.com/people/shi-duo-pi-li-yan... 120 李萬一 https://www.zhihu.com/people/moire 121 万阿咸 https://www.zhihu.com/people/wan-a-xian-58 122 笙箫 https://www.zhihu.com/people/sheng-xiao-36 123 谢椿明 https://www.zhihu.com/people/xie-chun-ming-16 124 孙阿童 https://www.zhihu.com/people/sun-a-tong 125 宫曼曼 https://www.zhihu.com/people/gong-nuo-6 126 荒野大嫖客 https://www.zhihu.com/people/ji-da-fa-37 127 我就想改名而已 https://www.zhihu.com/people/wowjessica 128 就像周一 https://www.zhihu.com/people/yin-qing-chu-kai 129 胡杨 https://www.zhihu.com/people/hu-yang-49-22 130 杨笋笋 https://www.zhihu.com/people/yang-sun-sun-98 131 蜉蝣 https://www.zhihu.com/people/yuan-xia-66 132 羽小团 https://www.zhihu.com/people/xiao-yu-bao-er 133 杨笋笋 https://www.zhihu.com/people/yang-sun-sun-98 134 Lina https://www.zhihu.com/people/li-nuo-84-28 135 另一只袜子 https://www.zhihu.com/people/151231 136 刘梓乔 https://www.zhihu.com/people/liu-zi-qiao-42 137 guuweihai https://www.zhihu.com/people/guuweihai 138 陈10 https://www.zhihu.com/people/chen-10-80 139 ZW711 https://www.zhihu.com/people/zw711 140 看朱成碧纷思君 https://www.zhihu.com/people/kan-zhu-cheng-bi-... 下周二晚上8点，我会在趣直播聊一聊Python爬虫，如果你感兴趣，欢迎你来参加。 趣直播 - 知识直播平台","tags":[{"name":"知乎","slug":"知乎","permalink":"https://zhangslob.github.io/tags/知乎/"},{"name":"妹子","slug":"妹子","permalink":"https://zhangslob.github.io/tags/妹子/"}]},{"title":"Leetcode_4.Median of Two Sorted Arrays","date":"2017-05-19T14:03:18.147Z","path":"2017/05/19/Leetcode-4-Median-of-Two-Sorted-Arrays/","text":"这是崔斯特的第十一篇原创文章 参考Median of Two Sorted Arrays 1、题目There are two sorted arrays nums1 and nums2 of size m and n respectively. Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)). Example 1: nums1 = [1, 3] nums2 = [2] The median is 2.0 Example 2: nums1 = [1, 2] nums2 = [3, 4] The median is (2 + 3)/2 = 2.5 2、思路蛋疼的说，我有看不懂题目了，尤其是O(log (m+n))，啥玩意。没办法，去网上搜索，看看前辈们的想法。 翻译如下： 给你两个排序数组，容量为m的数组A，容量为n的数组B。求出两个数组的中位数（啥玩意？），硬性要求时间复杂度O(log (m+n)). 1：太汗颜了，median到底是个啥，查一下： 中位数是在一组数据中居于中间的数(特别注意的地方是：这组数据之前已经经过升序排列！！！)，即在这组数据中，有一半的数据比它大，有一半的数据比它小。如果这组数据包含偶数个数字，中值是位于中间的两个数的平均值。 2：好吧，中位数是这么个玩意，那么理论上首先我们需要先将两个数组合为一，再求这个新合并的数组的中位数。 3：但是，已经限定死了时间复杂度为log（m+n），原来LeetCode的题目也思路不开放嘛。 4：问题可以转化成两个有序序列找第num大的数，由于时间复杂度已经限定死了，只能采用类似二分的思想，每个步骤去掉一半数据元素。 出现了一个词语：时间复杂度，这是个啥？ 完全不懂，换个思路来吧，不去看题目了，直接看第四点： 问题可以转化成两个有序序列找第num大的数，由于时间复杂度已经限定死了，只能采用类似二分的思想，每个步骤去掉一半数据元素。 二分，又是二分，赶紧去复习下。 二分查找就是将查找的键和子数组的中间键作比较，如果被查找的键小于中间键，就在左子数组继续查找；如果大于中间键，就在右子数组中查找，否则中间键就是要找的元素。 这个好像还可以看得懂，嘿嘿。我还发现了Python源代码（百度这样说的）： def bin_search(data_list, val): low = 0 # 最小数下标 high = len(data_list) - 1 # 最大数下标 while low &lt;= high: mid = (low + high) // 2 # 中间数下标 if data_list[mid] == val: # 如果中间数下标等于val, 返回 return mid elif data_list[mid] &gt; val: # 如果val在中间数左边, 移动high下标 high = mid - 1 else: # 如果val在中间数右边, 移动low下标 low = mid + 1 return # val不存在, 返回None ret = bin_search(list(range(1, 10)), 3) print(ret) 大概明白他的意思了。 3、解法很多解法都提到：如果我们可以在两个数列中求出第K小的元素，便可以解决该问题 解题思路：这道题要求两个已经排好序的数列的中位数。中位数的定义：如果数列有偶数个数，那么中位数为中间两个数的平均值；如果数列有奇数个数，那么中位数为中间的那个数。比如{1，2，3，4，5}的中位数为3。{1，2，3，4，5，6}的中位数为（3+4）/ 2 = 3.5。那么这题最直接的思路就是将两个数列合并在一起，然后排序，然后找到中位数就行了。可是这样最快也要O((m+n)log(m+n))的时间复杂度，而题目要求O(log(m+n))的时间复杂度。这道题其实考察的是二分查找，是《算法导论》的一道课后习题，难度还是比较大的。 首先我们来看如何找到两个数列的第k小个数，即程序中getKth(A, B , k)函数的实现。用一个例子来说明这个问题：A = {1，3，5，7}；B = {2，4，6，8，9，10}；如果要求第7个小的数，A数列的元素个数为4，B数列的元素个数为6；k/2 = 7/2 = 3，而A中的第3个数A[2]=5；B中的第3个数B[2]=6；而A[2]&lt;B[2]；则A[0]，A[1]，A[2]中必然不可能有第7个小的数。因为A[2]&lt;B[2]，所以比A[2]小的数最多可能为A[0], A[1], B[0], B[1]这四个数，也就是说A[2]最多可能是第5个大的数，由于我们要求的是getKth(A, B, 7)；现在就变成了求getKth(A’, B, 4)；即A’ = {7}；B不变，求这两个数列的第4个小的数，因为A[0]，A[1]，A[2]中没有解，所以我们直接删掉它们就可以了。这个可以使用递归来实现。 class Solution: # @return a float # @line20 must multiply 0.5 for return a float else it will return an int def getKth(self, A, B, k): lenA = len(A); lenB = len(B) if lenA &gt; lenB: return self.getKth(B, A, k) if lenA == 0: return B[k - 1] if k == 1: return min(A[0], B[0]) pa = min(k/2, lenA); pb = k - pa if A[pa - 1] &lt;= B[pb - 1]: return self.getKth(A[pa:], B, pb) else: return self.getKth(A, B[pb:], pa) def findMedianSortedArrays(self, A, B): lenA = len(A); lenB = len(B) if (lenA + lenB) % 2 == 1: return self.getKth(A, B, (lenA + lenB)/2 + 1) else: return (self.getKth(A, B, (lenA + lenB)/2) + self.getKth(A, B, (lenA + lenB)/2 + 1)) * 0.5 在我提交了代码之后，发现超过50.24 % 我找出最快的解法，来学习下： class Solution(object): def findMedianSortedArrays(self, a, b): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: float &quot;&quot;&quot; c = a+b c.sort() m = len(c) / 2 mm = len(c) % 2 if mm &gt; 0 : return c[m] return (c[m-1]+c[m])/2.# + (c[m-1]+c[m])%2 第二名的： class Solution(object): def findMedianSortedArrays(self, nums1, nums2): &quot;&quot;&quot; :type nums1: List[int] :type nums2: List[int] :rtype: float &quot;&quot;&quot; nums3 = nums1 + nums2 nums3.sort() l = len(nums3) if l%2 == 1: return nums3[l/2] else: return (float(nums3[l/2]) + float(nums3[l/2-1]))/2 每做一题，都会被打击好多次，但是算法是一定要学习的。","tags":[]},{"title":"Leetcode_2. Add Two Numbers","date":"2017-05-14T08:42:56.000Z","path":"2017/05/14/Leetcode-2-Add-Two-Numbers/","text":"这是崔斯特的第十篇原创文章 好久没写博客了，定个小目标，2天一篇，哈哈。 1、题目You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. You may assume the two numbers do not contain any leading zero, except the number 0 itself. Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 2、思路其实我并看不懂题目说得啥意思，如果说243+564，结果是807才是，但是很明显题目不会这么简单。怎么办？ 好像只能去看看别人的理解了，发现： 1.因为存储是反过来的，即数字342存成2-&gt;4-&gt;3，所以要注意进位是向后的； 2.链表l1或l2为空时，直接返回，这是边界条件，省掉多余的操作； 3.链表l1和l2长度可能不同，因此要注意处理某个链表剩余的高位； 4.2个数相加，可能会产生最高位的进位，因此要注意在完成以上1－3的操作后，判断进位是否为0，不为0则需要增加结点存储最高位的进位。 给个链接http://blog.csdn.net/zhouworld16/article/details/14045855 原来是倒着相加，342+465=807，结果倒序，正好是708，题目应该是这样理解的吧，哈哈。 思路本题的思路很简单，按照小学数学中学习的加法原理从末尾到首位，对每一位对齐相加即可。技巧在于如何处理不同长度的数字，以及进位和最高位的判断。这里对于不同长度的数字，我们通过将较短的数字补0来保证每一位都能相加。递归写法的思路比较直接，即判断该轮递归中两个ListNode是否为null。 全部为null时，返回进位值 有一个为null时，返回不为null的那个ListNode和进位相加的值 都不为null时，返回 两个ListNode和进位相加的值 来源一位大佬https://segmentfault.com/a/1190000002986101 原来是小学内容小学数学中学习的加法，使用递归写法。 递归，就是在运行的过程中调用自己。什么鬼啊，自己使用自己吗？ 目前我找到的对递归最恰当的比喻，就是查词典。 我们使用的词典，本身就是递归，为了解释一个词，需要使用更多的词。 当你查一个词，发现这个词的解释中某个词仍然不懂，于是你开始查这第二个词，可惜，第二个词里仍然有不懂的词，于是查第三个词，这样查下去，直到有一个词的解释是你完全能看懂的，那么递归走到了尽头，然后你开始后退，逐个明白之前查过的每一个词，最终，你明白了最开始那个词的意思。。。 好像明白了一点点~ 3、解法 #（Python）版本1 class Solution: def addTwoNumbers(self, l1, l2): addends = l1, l2 dummy = end = ListNode(0) carry = 0 while addends or carry: carry += sum(a.val for a in addends) addends = [a.next for a in addends if a.next] end.next = end = ListNode(carry % 10) carry /= 10 return dummy.next 版本2 class Solution: # @return a ListNode def addTwoNumbers(self, l1, l2): carry = 0 sum = ListNode(0) s = sum while l1 is not None or l2 is not None or carry: s.val = carry if l1: s.val += l1.val l1 = l1.next if l2: s.val += l2.val l2 = l2.next carry = s.val / 10 s.val = s.val % 10 if l1 or l2 or carry: s.next = ListNode(0) s = s.next return sum 好吧，承认版本1看不懂。至于版本2 ListNode 是一个元祖，然后。。。s.val是什么意思啊？又不懂。回去看看，原来是已经定义了ListNode # Definition for singly-linked list. # class ListNode(object): # def __init__(self, x): # self.val = x # self.next = None 也就是说有2个类，Solution 和 ListNode 今天先这样了，我需要去学习一下什么是“类”，也就是Python的面向对象编程","tags":[{"name":"leetcode","slug":"leetcode","permalink":"https://zhangslob.github.io/tags/leetcode/"},{"name":"刷题","slug":"刷题","permalink":"https://zhangslob.github.io/tags/刷题/"}]},{"title":"使用Python计算文章中的字词频率丨学习笔记和反思","date":"2017-03-28T10:58:18.000Z","path":"2017/03/28/使用Python计算文章中的字词频率丨学习笔记和反思/","text":"这是崔斯特的第九篇原创文章 来源：天善智能-商业智能和大数据在线社区，用心创造价值https://edu.hellobi.com/course/159/play/lesson/2531 丘祐玮https://ask.hellobi.com/people/DavidChiu人人都爱数据科学家！Python数据科学精华实战课程 环境：Anaconda3 建议使用Anaconda，下载源文件后再阅读本文：https://github.com/zhangslob/DanmuFenxi 选择经典演讲稿，奥巴马2009年9月8日开学演讲。。https://wenku.baidu.com/view/ad77bc1caf45b307e8719758.html THE PRESIDENT: Hello, everybody! Thank you. Thank you. Thank you, everybody. All right, everybody go ahead and have a seat. How is everybody doing today? (Applause.) How about Tim Spicer? (Applause.) I am here with students at Wakefield High School in Arlington, Virginia. And we’ve got students tuning in from all across America, from kindergarten through 12th grade. And I am just so glad that all could join us today. And I want to thank Wakefield for being such an outstanding host. Give yourselves a big round of applause. (Applause.)… 1、World Count(Version 1)把数据命名为speech_text，首先需要对英文进行分词。英文中主要是空格，使用split()函数 # coding: utf-8 # In[1]: speech_text=&apos;&apos;&apos;#长文本使用&apos;&apos;&apos;..&apos;&apos;&apos; THE PRESIDENT: Hello, everybody! Thank you. Thank you. Thank you, everybody. All right, everybody go ahead and have a seat. How is everybody doing today? (Applause.) How about Tim Spicer? (Applause.) I am here with students at Wakefield High School in Arlington, Virginia. And we&apos;ve got students tuning in from all across America, from kindergarten through 12th grade. And I am just so glad that all could join us today. And I want to thank Wakefield for being such an outstanding host. Give yourselves a big round of applause. (Applause.) ...#省略文字 &apos;&apos;&apos; # In[2]: speech=speech_text.split() # In[3]: speech 下一步，计算speech中词语出现的次数 # In[4]: dic={} for word in speech: if word not in dic: dic[word] = 1 else: dic[word] = dic[word] + 1 # In[5]: dic 通过 items() 函数以列表返回可遍历的(键, 值) 元组数组。 下一步，对词语进行排序 # In[7]: import operator swd=sorted(dic.items(),key=operator.itemgetter(1),reverse=True)#从大到小排序 # In[9]: swd 发现其中“to”、“the”等单词是常见词，借用nltk我们可以把这些词语去掉 from nltk.corpus import stopwords stop_words = stopwords.words(&apos;English&apos;) 虽说Anaconda已经安装了NLTK，但是我自己操作时stopwords貌似没有，出错请参考https://www.douban.com/note/534906136/ 看看英文中的去停词，下一步，遍历，打印出不含有去停词 for k,v in swd2: if k not in stop_words: print(k,v) 发现出现了很多“–”，回去原文中观察，发现确实有很多， 那么问题来了，为什么出现这么多“–”。萌新求解！ 2、World Count(Version 2)from collections import Counter c=Counter(speech2) 使用Python 的collections模块更简洁，详细见http://www.jb51.net/article/48771.htm 同样可以使用stop_word，还可以使用most_common打印出前几个 for sw in stop_words: del c[sw] 3、反思上一篇文章https://zhuanlan.zhihu.com/p/25983014写的比较粗糙，很多人要求把“观众” “礼物”筛选出来，那我来试试。 stop = [&apos;！&apos;,&apos;*&apos;,&apos;观众&apos;,&apos;礼物&apos;,&apos;:&apos;,&apos;？&apos;,&apos;。&apos;,&apos;，&apos;,&apos;~&apos;,&apos;1&apos;] 去停词只有这些、可以根据实际情况添删。 看来观众很喜欢说“xx学院发来贺电~~”","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"https://zhangslob.github.io/tags/学习笔记/"},{"name":"文字处理","slug":"文字处理","permalink":"https://zhangslob.github.io/tags/文字处理/"}]},{"title":"昨天看球时，球迷都说了啥——弹幕抓取与分析","date":"2017-03-24T12:41:58.000Z","path":"2017/03/24/昨天看球时，球迷都说了啥——弹幕抓取与分析/","text":"这是崔斯特的第八篇原创文章 数据来源：http://star.longzhu.com/teamchina 本次弹幕记录（开始时间: 2017-03-23-19:43:34，结束21:29:33)，共记录20788条数据。 使用OBS弹幕助手记录http://www.obsapp.com/apps/obsdanmu/ 1、分析 文件中含有时间记录，观众ID和送礼记录，其次是弹幕内容，所以决定对前两列内容不分析。 首先需要对文本分词，这里采用jieba分词 https://github.com/fxsjy/jieba/ 去除空格，使用strip()函数， 去掉换行符”\\n” line = line.strip(&apos;\\n&apos;) 把分析结果写入新的文档’text.txt’，Python join() 方法用于将序列中的元素以指定的字符连接生成一个新的字符串 text = &apos;&apos; with open(&apos;danmu.txt&apos;,encoding=&apos;utf-8&apos;) as fin: for line in fin.readlines(): line = line.strip(&apos;\\n&apos;) text += &apos;/&apos;.join(jieba.cut(line)) text += &apos; &apos; fout = open(&apos;text.txt&apos;,&apos;wb&apos;)#以二进制写模式写入 pickle.dump(text,fout) fout.close() 这样就完成了分词过程，结果如下： 2、绘制图云# 直接从文件读取数据 fr = open(&apos;text.txt&apos;,&apos;rb&apos;) text = pickle.load(fr) 使用word_cloud，具体用法https://github.com/amueller/word_cloud backgroud_Image = plt.imread(&apos;girl.jpg&apos;) wc = WordCloud( background_color = &apos;white&apos;, # 设置背景颜色 mask = backgroud_Image, # 设置背景图片 max_words = 2000, # 设置最大现实的字数 stopwords = STOPWORDS, # 设置停用词 font_path = &apos;C:/Users/Windows/fonts/msyh.ttf&apos;,# 设置字体格式，如不设置显示不了中文 max_font_size = 300, # 设置字体最大值 random_state = 50, # 设置有多少种随机生成状态，即有多少种配色方案 ) 使用matplotlib绘图http://matplotlib.org/2.0.0/index.html wc.generate(text) image_colors = ImageColorGenerator(backgroud_Image) #wc.recolor(color_func = image_colors) plt.imshow(wc) plt.axis(&apos;off&apos;) plt.show() OK，这样就完成了，附上结果 有没有你发过的弹幕呢？ 可自形修改数据，得到更好看图片。 能力有限，分析很少，如果你想进行更深入分析，请找我要文件。 对英雄联盟感兴趣的小伙伴可以看看这篇，对游戏直播弹幕的分析。 https://zhangslob.github.io/2017/03/24/%E5%88%A9%E7%94%A8Python%E5%AF%B9%E7%9B%B4%E6%92%AD%E5%BC%B9%E5%B9%95%E7%9A%84%E5%88%86%E6%9E%90/ github：https://github.com/zhangslob/DanmuFenxi","tags":[{"name":"足球","slug":"足球","permalink":"https://zhangslob.github.io/tags/足球/"},{"name":"数据分析","slug":"数据分析","permalink":"https://zhangslob.github.io/tags/数据分析/"}]},{"title":"利用Python对直播弹幕的分析","date":"2017-03-24T12:12:58.000Z","path":"2017/03/24/利用Python对直播弹幕的分析/","text":"这是崔斯特的第七篇原创文章 弹幕（ barrage），中文流行词语，原意指用大量或少量火炮提供密集炮击。而弹幕，顾名思义是指子弹多而形成的幕布， 大量吐槽评论从屏幕飘过时效果看上去像是飞行射击游戏里的弹幕。 今天就来说说游戏直播中， 弹幕都有哪些。 一、准备利用 danmu 弹幕接口对斗鱼主播赏金术士直播间的弹幕进行抓取，抓取时间约2 小时，共计 2534 条弹幕。赏金直播间： https://www.douyu.com/846805 二、 分析1、 弹幕词云词云， 由词汇组成类似云的彩色图形。 使用的是 Python 的模块 wordcloud。 通过 jieba 分词对弹幕中文分词， 使用 wordcloud 对结果构造词云， 最终结果为： 可以看到，高频率词语有： 外甥、无敌、厉害、可以、无限、火力、什么、垃圾、赏金。 2、关键词TextRank算法可以用来从文本中提取关键词和摘要 关键词： 不 0.010922664205428556 外甥 0.010484629632807344 玩 0.008177160003721682 无限 0.0058741805660283575 没 0.005665342357801469 说 0.005548941560115147 大 0.005541099430280024 主播 0.005498954448927515 出 0.0054948076800822405 看 0.0051528084835430555 可以看出来，作为汉字常用字，‘不’、‘玩’、‘没’、‘说’、‘大’、‘出’、‘看’这7个字出现频率高，这不奇怪。但是，‘外甥’、‘无限’、‘主播’就和英雄联盟主播赏金术士有责很大关系了。 外甥是赏金双排的一位选手、扮演着搞笑、逗乐的角色。‘无限’则是“无限火力”，一个特定模式，颇受玩家喜爱。主播可能是赏金，也有可能说别的主播。 关键短语： 对面不会 垃圾主播 不出 没带 不大 赏金玩 对面德玛 外甥说 大不 外甥大 摘要： 7337 0.0006968086282134394 真的有护眼模式666 3059 0.0006968086282134393 护眼模式为什么这么绿 10503 0.00047342729603724247 找儿子，爱好护眼 从摘要中看到三条弹幕中，都含有“护眼”二字，这是为什么呢？ lol护眼一词，其实主要来源于英雄联盟的直播平台，随着叫的人多了，这个词便火热了起来。起初是有人带节奏，说打护眼斗鱼可以进入护眼模式。一般在直播lol的主播使用的英雄死掉后，界面会呈现暗灰色的，亮度降低有利于防护眼睛，从而就有了lol护眼，当然意思就是嘲讽主播很菜的意思。 三、总结：由于自己所收集的数据过少、而且仅保存了一位主播的弹幕，造成结果不具有通用性，可以通过对各大直播平台的热门主播弹幕的爬取，获得观众的心理变化和网络风气。 以及主播有没有过气一说~ github：https://github.com/zhangslob/DanmuFenxi","tags":[{"name":"直播","slug":"直播","permalink":"https://zhangslob.github.io/tags/直播/"},{"name":"文本分析","slug":"文本分析","permalink":"https://zhangslob.github.io/tags/文本分析/"}]},{"title":"如何优雅的“轮带逛”初级篇——获取单张图片","date":"2017-03-20T12:35:00.000Z","path":"2017/03/20/如何优雅的“轮带逛”初级篇——获取单张图片/","text":"这是崔斯特的第六篇原创文章 轮子哥护体 首先上收藏夹 https://www.zhihu.com/collection/78172986?page=1 由@vega13创建，内容挺多的。例如， 等等，看的老夫脸都红了 写了一个简单爬取图片的程序。记录下过程。手动 @轮子哥 1、分析网页收藏夹只收藏了问题的一个答案，初步想法是获取当前页面的图片 因为上一次原因，直接去网页源代码 &lt;img src=&quot;https://pic4.zhimg.com/de5ecb16bcb912e99a83f647eb96c5bb_200x112.jpg&quot; data-rawwidth=&quot;1080&quot; data-rawheight=&quot;1080&quot; class=&quot;origin_image inline-img zh-lightbox-thumb&quot; data-original=&quot;https://pic4.zhimg.com/de5ecb16bcb912e99a83f647eb96c5bb_r.jpg&quot;&gt; &lt;img data-rawwidth=&quot;1280&quot; data-rawheight=&quot;1836&quot; src=&quot;https://pic2.zhimg.com/v2-61ba67d910104f99acdb805a3568ab05_200x112.jpg&quot; class=&quot;origin_image inline-img zh-lightbox-thumb&quot; data-original=&quot;https://pic2.zhimg.com/v2-61ba67d910104f99acdb805a3568ab05_r.jpg&quot;&gt; 在&lt;img&gt;标签下，src和data-original都含有图片链接，经验证data-original是大图，那就把每个问题的图片链接找到了，接下来就很简单了。 2、代码就18行的代码。简单吧~ import requests,urllib from lxml import etree def get_img(url): headers = {&apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&apos;} r= requests.get(url,headers=headers).text s = etree.HTML(r) #print(r) link = s.xpath(&apos;//img/@data-original&apos;) for i in link: print(i) name = i.split(&apos;/&apos;)[-1]#图片名称 urllib.request.urlretrieve(i,name) if __name__ == &apos;__main__&apos;: for i in range(1,43): url = &apos;https://www.zhihu.com/collection/78172986?page=&apos; + str(i) get_img(url) 但是这样存在一个问题 link = s.xpath(&apos;//img/@data-original&apos;) 这里的link只有每个回答的第一张图片，更多的图片藏在文本中，除了正则不知道还有没有更好的办法 只有200多张图片。结尾有百度云 下载了几分钟出现错误，有一张图片下载不了，知友们有什么好办法吗？ 三、“轮带逛”高级篇既然有初级篇，肯定还有高级篇。 其实这个收藏夹中每一个问题下面都含有很多回答，收藏夹只是选取其中一个，也就是被轮子哥点赞的那个，那么还有那些没有被点赞的呢？ 下一期讲一讲怎么获取所有图片链接。 放一张图片，卡死我程序的 —————————————最后的小广告—————————————– 有朋友竟然叫我去作一期直播，讲一讲Python。 打算根据自己的经历分享一些经验，主要是关于Python入门的，想听听可以私信我。 时间是周二晚9点~ 百度云下载 链接：http://pan.baidu.com/s/1dFOPbUx 密码：abrl","tags":[{"name":"知乎爬虫","slug":"知乎爬虫","permalink":"https://zhangslob.github.io/tags/知乎爬虫/"},{"name":"轮带逛","slug":"轮带逛","permalink":"https://zhangslob.github.io/tags/轮带逛/"}]},{"title":"Python爬虫实战——免费图片 - Pixabay","date":"2017-03-19T09:24:58.000Z","path":"2017/03/19/Python爬虫实战——免费图片-Pixabay/","text":"这是崔斯特的第五篇原创文章 Pixabay，一个挺不错的高清无码图片网站，可以免费下载。 https://pixabay.com/ 一些介绍 超过 900000 高质量照片、 插图和矢量图形。可免费用于商业用途。没有所需的归属。 Pixabay是一家高质量图片分享网站。最初，该网站由Hans Braxmeier和Simon Steinberger在德国发展起来。2013年2月，网站拥有由影师和其社区的插画家提供的大约7万张免费的照片和矢量图形。该公司于2010年12月在德国乌尔姆成立。 2012年3月，Pixabay开始从一个私人图像搜集网站转变成一个互动的网上社区，该网站支持20种语言。同年5月，网站推出公共应用程序编程接口，从而使第三方用户和网站开发人员搜索其图像数据库。网站还与Flickr，YouTube和维基共享资源。 Pixabay用户无需注册就可以获得免费版权的高质量图像。根据知识共享契约CC0相关的肖像权，用户在该网站通过上传图片就默认放弃图片版权，从而使图片广泛流通。网站允许任何人使用，修改图片 - 即便是在商业应用 - 不要求许可并且未认可。 Pixabay为了确保高品质图片标准，用户上传的所有图片将由网站工作人员手动审批。大约27％的用户会说英语，20％的用户会说西班牙语，11％的用户会说葡萄牙语，7％的用户会说德语和5％的用户会说法语。其用户主要是博客、图形设计师、作家、记者和广告商。 今天的目标就是爬取小编精选的图片 https://pixabay.com/zh/editors_choice/?media_type=photo&amp;pagi=1 一、分析我们需要写3个函数 一个Download(url)，用来下载图片 一个用来获取小编精选一共有的165页FullUrl() 最后用来调用main() 下面开始一个个写吧~ https://pixabay.com/zh/editors_choice/?media_type=photo&amp;pagi=1 打开网页，F12，查看图片链接所在的标签 可以看到图片链接都在&lt;img&gt;标签下，但是我自己发现前几张和后几张的属性是不一样的，提取出&lt;img&gt;中“src”就可以了，使用的是xpath import requests from lxml import etree header = {&apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&apos;} url = &apos;https://pixabay.com/zh/editors_choice/&apos; r = requests.get(url,headers=header).text s = etree.HTML(r) print(s.xpath(&apos;//img/@src&apos;)) 结果是 前面都是正确的图片链接，可是后面出现了’/static/img/blank.gif’，这个是什么鬼，查看网页源代码，搜索 可以发现确实有这一段字符串，我自己在这一点上花了很多时间。感谢@李宏杰的帮助，https://www.zhihu.com/question/57188290 浏览器中的代码是JavaScript修改过的, 你直接用requests请求然后打印出来看就会发现 &lt;div class=&quot;item&quot; data-w=&quot;640&quot; data-h=&quot;426&quot;&gt; &lt;a href=&quot;/zh/%E8%9B%8B%E7%B3%95-%E4%B8%80%E5%9D%97%E8%9B%8B%E7%B3%95-%E9%A3%9F%E8%B0%B1-%E4%B8%80%E7%89%87-%E7%B3%96%E6%9E%9C-%E6%8F%92%E5%9B%BE-%E7%83%98%E7%83%A4-%E7%94%9C%E7%82%B9-%E9%A3%9F%E5%93%81-1971556/&quot;&gt; &lt;img src=&quot;/static/img/blank.gif&quot; data-lazy-srcset=&quot;https://cdn.pixabay.com/photo/2017/01/11/11/33/cake-1971556__340.jpg 1x, https://cdn.pixabay.com/photo/2017/01/11/11/33/cake-1971556__480.jpg 2x&quot; data-lazy=&quot;https://cdn.pixabay.com/photo/2017/01/11/11/33/cake-1971556__340.jpg&quot; alt=&quot;&quot;&gt; &lt;/a&gt; &lt;div&gt; requests返回的数据中可以看到，“data-lazy”总含有我们需要的数据，修改代码 发现现在返回的数据是我们需要的，打开一张图片查看 下面的图片要清晰很多，我们只需要把__340换成_960_720即可 小编精选一共有165页，我们需要获取下一页URL https://pixabay.com/zh/editors_choice/?media_type=photo&amp;pagi=2 https://pixabay.com/zh/editors_choice/?media_type=photo&amp;pagi=3 。。。 规律很简单 full_link = [] for i in range(1,165): #print(i) full_link.append( &apos;https://pixabay.com/zh/editors_choice/?media_type=photo&amp;pagi=&apos;+ str(i)) 到现在，准备工作做好了，思路可能不是很清楚，请谅解~ 二、代码import requests from lxml import etree import time import urllib def Download(url): header = { &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&apos;} r = s.get(url, headers=header).text s = etree.HTML(r) r = s.xpath(&apos;//img/@data-lazy&apos;) for i in r: imglist = i.replace(&apos;__340&apos;, &apos;_960_720&apos;) name = imglist.split(&apos;/&apos;)[-1]#图片名称 urllib.request.urlretrieve(imglist,name) time.sleep(1) def FullUrl(): full_link = [] for i in range(2,165): #print(i) full_link.append( &apos;https://pixabay.com/zh/editors_choice/?media_type=photo&amp;pagi=&apos;+ str(i)) #print(full) return full_link if __name__ == &apos;__main__&apos;: urls = FullUrl() for url in urls: Download(url) 爬取图片的工作就完成了，粗略的计算6600张，每一张下载需要5秒钟，一分钟60秒、一小时60分钟，天呐，需要9个小时才能爬取全部的图片。想一想还是算了吧，整站爬取还是要使用Scrapy+mongodb。 &gt;&gt;&gt; 165*40 6600 &gt;&gt;&gt; from __future__ import division &gt;&gt;&gt; 6600*5/60/60 9.166666666666666 下载了700多张，108M，也算是留着看看吧。 一会上传到Github上 三、结语昨天学习了崔庆才老师的爬虫，感觉真的学习到了好多，对Python爬虫提高很有帮助，还有，原来他就是静觅，刚开始学习爬虫就在看他的博客，没想到他现在又在出爬虫教程，打算跟着学习。 分享内容： 1. 分析知乎Ajax请求及爬取逻辑 2. 用Scrapy实现递归爬取 3. 爬取结果存储到MongoDB 废话不多说，自己看看就知道了。 静觅丨崔庆才的个人博客http://cuiqingcai.com/ 微课录播 | 03月17日 爬取知乎所有用户详细信息https://edu.hellobi.com/course/163 最后的小广告 有朋友竟然叫我去作一期直播，讲一讲Python。 打算根据自己的经历分享一些经验，主要是关于Python入门的，想听听可以私信我。 时间是周二晚9点~ Hello World！ Try to be a Pythoner！","tags":[{"name":"爬虫","slug":"爬虫","permalink":"https://zhangslob.github.io/tags/爬虫/"},{"name":"图片下载","slug":"图片下载","permalink":"https://zhangslob.github.io/tags/图片下载/"}]},{"title":"Python练习第九题，爬取贴吧图片","date":"2017-03-14T11:56:07.000Z","path":"2017/03/14/Python练习第九题，爬取贴吧图片/","text":"这是崔斯特的第四篇原创文章 一、问题：用 Python爬取妹子图片 :) http://tieba.baidu.com/p/2166231880 二、分析贴吧网页源码打开网页http://tieba.baidu.com/p/2166231880，F12 发现图片链接都在&lt;img&gt;标签中 &lt;cc&gt; &lt;div...&gt; &lt;img...&gt; &lt;img...&gt; 测试发现，src中的链接就是图片链接。那么就很简单，只需要把&lt;img&gt;中的src的链接拿出来即可。 三、写代码环境：Python3，Pycharm 使用requests和xpath，最近才学了xpath，发现超级好用，比bs4简洁，有兴趣看看这个https://zhuanlan.zhihu.com/p/25572729 import requests from lxml import etree url = &apos;http://tieba.baidu.com/p/2166231880&apos; header = {&apos;User-Agent&apos;:&apos;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36&apos;} r = requests.get(url,headers=header).content s = etree.HTML(r) print(s.xpath(&apos;//div/img/@src&apos;)) 发现链接都已经拿到手，下一步就是下载了~ 下载图片的语句： import urllib.request path = &apos;......&apos; #下载链接 jpg_link ＝ &apos;......&apos; #图片链接 request.urlretrieve(jpg_link, path) 加在一起，大功告成。 四、总结经测试，贴吧里面其他网页如：http://tieba.baidu.com/p/1165861759 本代码都可以下载，顺便说一说问题。 1、图片名称使用图片链接中的名称，包含大量数字和字母，可以优化。 2、可以看到，下载文件中包含了一个表情，查看那是用户所发，说明筛选出了问题。 3、帖子数量多，翻页过后，需要在代码中加入获取下一页链接。 除此之外，还有什么问题呢？ 源码请见：https://github.com/zhangslob/TiebaImg","tags":[{"name":"福利","slug":"福利","permalink":"https://zhangslob.github.io/tags/福利/"},{"name":"美女图片","slug":"美女图片","permalink":"https://zhangslob.github.io/tags/美女图片/"}]},{"title":"Python练习第七题，我要倒过来看","date":"2017-03-06T10:47:46.000Z","path":"2017/03/06/Python练习第七题，我要倒过来看/","text":"这是崔斯特的第三篇原创文章 一、ChallengeUsing the Python language, have the function FirstReverse(str) take the str parameter being passed and return the string in reversed（颠倒的） order. For example: if the input string is “Hello World and Coders” then your program should return the string sredoC dna dlroW olleH.题目意思是，给定字符串，返回原来的倒序。例如给出的是“Hello World and Coders”，返回“sredoC dna dlroW olleH.” Sample Test Cases Input:”coderbyte” Output:”etybredoc” Input:”I Love Code” Output:”edoC evoL I” Hint Think of how you can loop through a string or array of characters backwards to produce a new string. def FirstReverse(str): # code goes here return str # keep this function call here print FirstReverse(raw_input()) 二、解法:切片环境：Python3.5 A simple way to reverse a string would be to create a new string and fill it with the characters from the original string, but backwards. To do this, we need to loop through the original string starting from the end, and every iteration of the loop we move to the previous character in the string. Here is an example: def FirstReverse(str): return str[::-1] print (FirstReverse(input())) 非常简洁str[::-1]就可以完成目标。 三、切片详解1、取字符串中第几个字符 &gt;&gt;&gt; &apos;hello&apos;[0]#表示输出字符串中第一个字符 &apos;h&apos; &gt;&gt;&gt; &apos;hello&apos;[-1]#表示输出字符串中最后一个字符 &apos;o&apos; 2、字符串分割 &gt;&gt;&gt; &apos;hello&apos;[1:3] &apos;el&apos; 第一个参数表示原来字符串中的下表第二个参数表示分割后剩下的字符串的第一个字符 在 原来字符串中的下标 注意，Python从0开始计数 3、几种特殊情况 &gt;&gt;&gt; &apos;hello&apos;[:3]#从第一个字符开始截取，直到最后 &apos;hel&apos; &gt;&gt;&gt; &apos;hello&apos;[0:]#从第一个字符开始截取，截取到最后 &apos;hello&apos; &gt;&gt;&gt; &apos;hello&apos;[:] &apos;hello&apos; 4、步长截取 &gt;&gt;&gt; &apos;abcde&apos;[::2]#表示从第一个字符开始截取，间隔2个字符取一个。 &apos;ace&apos; &gt;&gt;&gt; &apos;abcde&apos;[::-2] &apos;eca&apos; &gt;&gt;&gt; &apos;abcde&apos;[::-1] &apos;edcba&apos; 推荐阅读： 官方文档https://docs.python.org/3/tutorial/introduction.html#strings 廖雪峰的教程 http://www.liaoxuefeng.com/wiki/0014316089557264a6b348958f449949df42a6d3a2e542c000/001431756919644a792ee4ead724ef7afab3f7f771b04f5000 更多解法： def FirstReverse(str): # reversed(str) turns the string into an iterator object (similar to an array) # and reverses the order of the characters # then we join it with an empty string producing a final string for us return &apos;&apos;.join(reversed(str)) print(FirstReverse(input())) 使用了什么语法？评论中见。","tags":[{"name":"Python语法","slug":"Python语法","permalink":"https://zhangslob.github.io/tags/Python语法/"},{"name":"切片介绍","slug":"切片介绍","permalink":"https://zhangslob.github.io/tags/切片介绍/"}]},{"title":"教你免费搭建个人博客，Hexo&Github","date":"2017-02-28T12:01:50.000Z","path":"2017/02/28/教你免费搭建个人博客，Hexo-Github/","text":"这是崔斯特的第二篇原创文章 说在前面： 为什么自己搭建博客，知乎不行吗？可以看看刘未鹏 | Mind Hacks，前些天发布了某篇文章应该是被人举报了，结果知乎就删了。有自己的博客自由，自在。更多请看为什么要自建博客？https://www.zhihu.com/question/19916345 说在前面： 为什么自己搭建博客，知乎不行吗？可以看看刘未鹏 | Mind Hacks，前些天发布了某篇文章应该是被人举报了，结果知乎就删了。有自己的博客自由，自在。更多请看为什么要自建博客？https://www.zhihu.com/question/19916345 我用了多久才完成博客的搭建？不瞒您说，我花了有3天时间。对着别人的“5分钟 搭建免费个人博客”花了3天才完成，中间遇到了无数困难。查看很多资料，所以当你遇到困难，别放弃，仔细看文档或资料。 为了发布这篇教程，重新注册了Github，崔斯特的博客https://zhangslob.github.io/这个是我自己的博客，崔斯特测试所用博客https://zhihuya.github.io/这个是我一边写这篇教程一边搭建的。所以如果你也和我一样，喜欢自由，喜欢捣腾，那就来吧。 系统：windows 7 64位，编辑器：sublime text3，控制台：cmder搭建博客使用hexo+Github 什么是 Hexo？https://hexo.io/zh-cn/docs/ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 一、配置Github首先注册、登录 https://github.com/ 记住自己的Username（很重要） 然后右上角选择 Create a new repository https://github.com/new Repository name （填自己的名字） yourname.github.io(yourname与你的注册用户名一致,这个就是你博客的域名了) 例如，我的域名是github.com/zhihuya，就填入zhihuya.github.io。成功后出现下面的画面 二、环境安装（node、git）1、安装 Node.js https://nodejs.org/en/ 2、安装 Git https://github.com/waylau/git-for-win Git教程 https://github.com/waylau/git-for-win廖雪峰老师的教程，非常好。 3、安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，名称和邮箱是Github上的 4、安装 Hexo。所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。 $ npm install -g hexo-cli （使用的cmder，超级好用~~。等待时间可能有点长） 好了到这一步我们环境全部安装好了。 三、设置在电脑F盘（自己随意）目录下新建文件夹 test，进入test，按住Shift键点击鼠标右键 因为我有安装Cmder，没有安装的点击“在此处打开命令窗口”，输入 hexo init blog 稍微等待下，速度有点慢。成功提示 INFO Start blogging with Hexo! 因为你初始化hexo 之后source目录下自带一篇hello world文章, 所以直接执行下方命令 $ hexo generate # 启动本地服务器 $ hexo server # 在浏览器输入 http://localhost:4000/就可以看见网页和模板了 INFO Start processing INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 访问http://localhost:4000/，便可以看到网站初步的模样，不要激动，我们还要把网页发布到Github上去。 重新打开CMD，输入： ssh-keygen -t rsa -C &quot;Github的注册邮箱地址&quot; 一路Enter过来就好，得到信息： Your public key has been saved in /c/Users/user/.ssh/id_rsa.pub. 找到该文件，打开（sublime text），Ctrl + a复制里面的所有内容，然后进入Sign in to GitHub：https://github.com/settings/ssh New SSH key ——Title：blog —— Key：输入刚才复制的—— Add SSH key 四、配置博客在blog目录下，用sublime打开_config.yml文件，修改参数信息 特别提醒，在每个参数的：后都要加一个空格 修改网站相关信息 title: 崔斯特测试所用博客 subtitle: 副标题 description: 网页描述 author: 崔斯特 language: zh-CN timezone: Asia/Shanghai 配置部署（我的是zhihuya，修改成自己的） deploy: type: git repo: https://github.com/zhihuya/zhihuya.github.io.git branch: master 五、发表文章在CMD中输入 $ hexo new &quot;崔斯特测试文章&quot; INFO Created: F:\\test\\blog\\source\\_posts\\崔斯特测试文章.md 找到该文章，打开，使用Markdown语法，该语法介绍可以查看https://zhangslob.github.io/2017/02/26/%E5%88%A9%E7%94%A8HEXO%E6%90%AD%E5%BB%BA%E7%9A%84%E5%8D%9A%E5%AE%A2/ --- title: 崔斯特测试文章 date: 2017-02-28 13:03:44 tags: --- 这是一篇测试文章，欢迎关注作者博客[1]: https://zhangslob.github.io/ 保存，然后执行下列步骤： F:\\test\\blog $ hexo clean INFO Deleted database. INFO Deleted public folder. F:\\test\\blog $ hexo generate INFO Start processing INFO Files loaded in 1.48 s #省略 INFO 29 files generated in 4.27 s F:\\test\\blog $ hexo server INFO Start processing INFO Hexo is running at http://localhost:4000/. Press Ctrl+C to stop. 这个时候，打开http://localhost:4000/，发现刚才的文章已经成功了 最后一步，发布到网上，执行： F:\\test\\blog $ hexo deploy INFO Deploying: git INFO Clearing .deploy_git folder... INFO Copying files from public folder... #省略 其中会跳出Github登录，直接登录，如果没有问题输入zhihuya（换成你的）.github.io/ 崔斯特测试所用博客https://zhihuya.github.io/ 然后就可以看到已经发布了 六、总结发布文章的步骤： 1、hexo new 创建文章 2、Markdown语法编辑文章 3、部署（所有打开CMD都是在blog目录下） hexo clean #清除缓存 网页正常情况下可以忽略此条命令 hexo generate #生成 hexo server #启动服务预览，非必要，可本地浏览网页 hexo deploy #部署发布 简写Tips： hexo n “我的博客” == hexo new “我的博客” #新建文章 hexo p == hexo publish hexo g == hexo generate#生成 hexo s == hexo server #启动服务预览 hexo d == hexo deploy#部署 如果在执行 hexo deploy 后,出现 error deployer not found:github 的错误，执行： npm install hexo-deployer-git --save 出错是正常的，出错了自己先百度或google，实在不知道的可以询问我。 托管的话不仅有github可以用，还有个国内的https://coding.net/可选 到这里已经完成了博客的搭建，但是还有很多需要设置和调整的。这是我的博客，也许你会发现，我和刚才搭建的不一样，因为我修改了博客主题，简洁、优美。 主题介绍https://github.com/litten/hexo-theme-yilia 欢迎大家关注，定会有更多精彩 知乎https://www.zhihu.com/people/cuishite 博客https://zhangslob.github.io/","tags":[{"name":"个人博客","slug":"个人博客","permalink":"https://zhangslob.github.io/tags/个人博客/"},{"name":"Hexo&Github","slug":"Hexo-Github","permalink":"https://zhangslob.github.io/tags/Hexo-Github/"}]},{"title":"利用HEXO搭建的博客及Markdown语法介绍","date":"2017-02-26T09:20:57.000Z","path":"2017/02/26/利用HEXO搭建的博客/","text":"这是崔斯特的第一篇原创文章 Markdown的一些语法 花了不少时间。终于把自己的第一个博客搭建成功了。但是遇到新问题，发表文章需要使用Markdown语法，下面就来说说。 Markdown的文档介绍http://www.appinn.com/markdown/看看简单介绍就可以了，以后有需求再去学习。 1、标题和引用。Markdown 支持两种标题的语法，Setext 和 atx 形式。Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），Atx 形式在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶。 区块引用则使用 email 形式的 ‘&gt;’ 角括号。 如你所见，左边是编辑区，右边可以直接看到结果。编辑器是MarkdownPad，下载链接是http://markdownpad.com/download.html 2、修辞和强调。 3、链接和图片。（如果你有下载MarkdownPad这个编辑器，会更加方便哦） 4、加入代码,使用单引号。 这些应该可以帮助我完成一般书写，好的呢，第一篇文章就完成了。 欢迎评论。。 人生苦短，我学Python (๑• . •๑) 2017/2/27 19:11:11","tags":[{"name":"黑魔法","slug":"黑魔法","permalink":"https://zhangslob.github.io/tags/黑魔法/"},{"name":"个人博客","slug":"个人博客","permalink":"https://zhangslob.github.io/tags/个人博客/"},{"name":"Markdown语法","slug":"Markdown语法","permalink":"https://zhangslob.github.io/tags/Markdown语法/"}]}]